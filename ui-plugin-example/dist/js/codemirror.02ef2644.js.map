{"version":3,"file":"js/codemirror.02ef2644.js","mappings":"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","sources":["webpack://ui-plugin-examples/./node_modules/@rancher/shell/plugins/codemirror.js","webpack://ui-plugin-examples/./node_modules/codemirror/addon/dialog/dialog.js","webpack://ui-plugin-examples/./node_modules/codemirror/addon/edit/matchbrackets.js","webpack://ui-plugin-examples/./node_modules/codemirror/addon/hint/anyword-hint.js","webpack://ui-plugin-examples/./node_modules/codemirror/addon/hint/show-hint.js","webpack://ui-plugin-examples/./node_modules/codemirror/addon/lint/lint.js","webpack://ui-plugin-examples/./node_modules/codemirror/addon/lint/yaml-lint.js","webpack://ui-plugin-examples/./node_modules/codemirror/addon/search/searchcursor.js","webpack://ui-plugin-examples/./node_modules/codemirror/keymap/emacs.js","webpack://ui-plugin-examples/./node_modules/codemirror/keymap/sublime.js","webpack://ui-plugin-examples/./node_modules/codemirror/keymap/vim.js","webpack://ui-plugin-examples/./node_modules/codemirror/mode/javascript/javascript.js","webpack://ui-plugin-examples/./node_modules/codemirror/mode/yaml/yaml.js","webpack://ui-plugin-examples/./node_modules/codemirror/addon/hint/show-hint.css","webpack://ui-plugin-examples/./node_modules/codemirror/addon/lint/lint.css","webpack://ui-plugin-examples/./node_modules/codemirror/theme/base16-dark.css","webpack://ui-plugin-examples/./node_modules/codemirror/theme/base16-light.css","webpack://ui-plugin-examples/./node_modules/codemirror/addon/hint/show-hint.css?46e0","webpack://ui-plugin-examples/./node_modules/codemirror/addon/lint/lint.css?c388","webpack://ui-plugin-examples/./node_modules/codemirror/theme/base16-dark.css?9066","webpack://ui-plugin-examples/./node_modules/codemirror/theme/base16-light.css?2ba3"],"sourcesContent":["/*\n * NOTE: This isn't actually a real plugin anymore, it's is dynamically loaded in components/CodeMirror.vue\n * so that it doesn't all get loaded put into vendor.js\n */\n\nimport CodeMirror from 'codemirror';\n\nimport 'codemirror/lib/codemirror.css';\nimport 'codemirror/mode/yaml/yaml.js';\nimport 'codemirror/mode/javascript/javascript.js';\n\nimport 'codemirror/theme/base16-light.css';\nimport 'codemirror/theme/base16-dark.css';\n\nimport 'codemirror/keymap/vim.js';\nimport 'codemirror/keymap/emacs.js';\nimport 'codemirror/keymap/sublime.js';\n\nimport 'codemirror/addon/lint/lint.css';\nimport 'codemirror/addon/lint/lint.js';\nimport 'codemirror/addon/lint/yaml-lint.js';\n\nimport 'codemirror/addon/fold/foldgutter.css';\nimport 'codemirror/addon/fold/foldgutter.js';\n\nimport 'codemirror/addon/hint/show-hint.css';\nimport 'codemirror/addon/hint/show-hint.js';\nimport 'codemirror/addon/hint/anyword-hint.js';\n\nimport { strPad } from '@shell/utils/string';\n\nfunction isLineComment(cm, lineNo) {\n  return /\\bcomment\\b/.test(cm.getTokenTypeAt(CodeMirror.Pos(lineNo, 0)));\n}\n\nfunction commentIndent(cm, lineNo) {\n  const text = cm.getLine(lineNo).substr(1);\n  const spaceTo = text.search(/\\S/);\n\n  if (spaceTo === -1 ) {\n    return -1;\n  }\n\n  const out = CodeMirror.countColumn(text, null, cm.getOption('tabSize'));\n\n  return out;\n}\n\n// Like the regular indent in codemirror, but treat a YAML array\n// item that's at the same level as the parent key as intented on level more\n//\n// foo:\n// - a\n// - b\nfunction lineIndent(cm, lineNo) {\n  let text = cm.getLine(lineNo);\n  const match = text.match(/(\\s*(-\\s+)?)(\\S.*)/);\n\n  if ( !match ) {\n    return -1;\n  }\n\n  const spaceTo = match[1].length;\n\n  text = strPad('', spaceTo) + match[3];\n\n  if ( /\\bcomment\\b/.test(cm.getTokenTypeAt(CodeMirror.Pos(lineNo, spaceTo + 1)))) {\n    return -1;\n  }\n\n  return CodeMirror.countColumn(text, null, cm.getOption('tabSize'));\n}\n\n// https://github.com/codemirror/CodeMirror/blob/master/addon/fold/indent-fold.js\nCodeMirror.registerHelper('fold', 'indent', (cm, start) => {\n  const myIndent = lineIndent(cm, start.line);\n\n  if (myIndent < 0) {\n    return;\n  }\n  let lastLineInFold = null;\n\n  // Go through lines until we find a line that definitely doesn't belong in\n  // the block we're folding, or to the end.\n  for (let i = start.line + 1, end = cm.lastLine(); i <= end; ++i) {\n    const indent = lineIndent(cm, i);\n\n    if (indent === -1) {\n    } else if (indent > myIndent) {\n      // Lines with a greater indent are considered part of the block.\n      lastLineInFold = i;\n    } else {\n      // If this line has non-space, non-comment content, and is\n      // indented less or equal to the start line, it is the start of\n      // another block.\n      break;\n    }\n  }\n  if (lastLineInFold) {\n    return {\n      from: CodeMirror.Pos(start.line, cm.getLine(start.line).length),\n      to:   CodeMirror.Pos(lastLineInFold, cm.getLine(lastLineInFold).length)\n    };\n  }\n});\n\nCodeMirror.defineExtension('foldLinesMatching', function(regex) {\n  this.operation(() => {\n    for (let i = this.firstLine(), e = this.lastLine(); i <= e; i++) {\n      const line = this.getLine(i);\n\n      if ( line.match(regex) ) {\n        this.foldCode(CodeMirror.Pos(i, 0), null, 'fold');\n      }\n    }\n  });\n});\n\nfunction countSpaces(line) {\n  for (let i = 0; i < line.length; i++) {\n    if (line[i] !== ' ') {\n      return i;\n    }\n  }\n\n  return line.length;\n}\n\nCodeMirror.defineExtension('foldYaml', function(path) {\n  this.operation(() => {\n    let elements = [];\n\n    for (let i = this.firstLine(), e = this.lastLine(); i <= e; i++) {\n      const line = this.getLine(i);\n      const index = countSpaces(line);\n      const trimmed = line.trim();\n\n      if (trimmed.endsWith(':') || trimmed.endsWith(': >-')) {\n        const name = trimmed.split(':')[0].substr(0, trimmed.length - 1);\n\n        // Remove all elements of the same are greater index\n        elements = elements.filter((e) => e.index < index);\n\n        // Add on this one\n        elements.push({\n          index,\n          name\n        });\n\n        const currentPath = elements.map((e) => e.name).join('.');\n\n        if (currentPath === path) {\n          this.foldCode(CodeMirror.Pos(i, 0), null, 'fold');\n        }\n      }\n    }\n  });\n});\n\nCodeMirror.registerHelper('fold', 'yamlcomments', (cm, start) => {\n  if ( !isLineComment(cm, start.line) ) {\n    return;\n  }\n\n  const myIndent = commentIndent(cm, start.line);\n\n  if (myIndent < 0) {\n    return;\n  }\n\n  let lastLineInFold = null;\n\n  // Go through lines until we find a line that definitely doesn't belong in\n  // the block we're folding, or to the end.\n  for (let i = start.line + 1, end = cm.lastLine(); i <= end; ++i) {\n    if ( !isLineComment(cm, i) ) {\n      break;\n    }\n\n    const indent = commentIndent(cm, i);\n\n    if (indent === -1) {\n      // empty?\n    } else if (indent > myIndent) {\n      // Lines with a greater indent are considered part of the block.\n      lastLineInFold = i;\n    } else {\n      // If this line has non-space, non-comment content, and is\n      // indented less or equal to the start line, it is the start of\n      // another block.\n      break;\n    }\n  }\n\n  if (lastLineInFold) {\n    return {\n      from: CodeMirror.Pos(start.line, cm.getLine(start.line).length),\n      to:   CodeMirror.Pos(lastLineInFold, cm.getLine(lastLineInFold).length)\n    };\n  }\n});\n\n/**\n * It display a dot for each space character in the text;\n * used in combination with 'as-text-area' css properties in CodeMirror.vue to display line break markdowns\n */\nCodeMirror.defineOption('showMarkdownLineBreaks', false, (codeMirror) => {\n  codeMirror.addOverlay({\n    name:  'show-markdown-line-breaks',\n    token: (stream) => {\n      if (stream.string[stream.pos].match(/\\s/)) {\n        stream.next();\n\n        return stream.pos % 2 === 0 ? 'markdown-single-trailing-space-even' : 'markdown-single-trailing-space-odd';\n      }\n\n      stream.next();\n\n      return null;\n    }\n  });\n});\n\n/**\n * It enables the text color selection in CodeMirror.vue\n * references:\n *   demo:   https://codemirror.net/5/demo/markselection.html#\n *   add-on: https://codemirror.net/5/doc/manual.html#addon_mark-selection\n *   source: https://codemirror.net/5/addon/selection/mark-selection.js\n */\nCodeMirror.defineOption('styleSelectedText', false, (cm, val, old) => {\n  const prev = old && old !== CodeMirror.Init;\n\n  if (val && !prev) {\n    cm.state.markedSelection = [];\n    cm.state.markedSelectionStyle = typeof val === 'string' ? val : 'CodeMirror-selectedtext';\n    reset(cm);\n    cm.on('cursorActivity', onCursorActivity);\n    cm.on('change', onChange);\n  } else if (!val && prev) {\n    cm.off('cursorActivity', onCursorActivity);\n    cm.off('change', onChange);\n    clear(cm);\n    cm.state.markedSelection = cm.state.markedSelectionStyle = null;\n  }\n});\n\nfunction onCursorActivity(cm) {\n  if (cm.state.markedSelection) {\n    cm.operation(() => {\n      update(cm);\n    });\n  }\n}\n\nfunction onChange(cm) {\n  if (cm.state.markedSelection && cm.state.markedSelection.length) {\n    cm.operation(() => {\n      clear(cm);\n    });\n  }\n}\n\nconst CHUNK_SIZE = 8;\nconst Pos = CodeMirror.Pos;\nconst cmp = CodeMirror.cmpPos;\n\nfunction coverRange(cm, from, to, addAt) {\n  if (cmp(from, to) === 0) {\n    return;\n  }\n  const array = cm.state.markedSelection;\n  const cls = cm.state.markedSelectionStyle;\n\n  for (let line = from.line;;) {\n    const start = line === from.line ? from : Pos(line, 0);\n    const endLine = line + CHUNK_SIZE; const atEnd = endLine >= to.line;\n    const end = atEnd ? to : Pos(endLine, 0);\n    const mark = cm.markText(start, end, { className: cls });\n\n    if (addAt === null || addAt === undefined) {\n      array.push(mark);\n    } else {\n      array.splice(addAt++, 0, mark);\n    }\n    if (atEnd) {\n      break;\n    }\n    line = endLine;\n  }\n}\n\nfunction clear(cm) {\n  const array = cm.state.markedSelection;\n\n  for (let i = 0; i < array.length; ++i) {\n    array[i].clear();\n  }\n  array.length = 0;\n}\n\nfunction reset(cm) {\n  clear(cm);\n  const ranges = cm.listSelections();\n\n  for (let i = 0; i < ranges.length; i++) {\n    coverRange(cm, ranges[i].from(), ranges[i].to());\n  }\n}\n\nfunction update(cm) {\n  if (!cm.somethingSelected()) {\n    return clear(cm);\n  }\n  if (cm.listSelections().length > 1) {\n    return reset(cm);\n  }\n\n  const from = cm.getCursor('start'); const to = cm.getCursor('end');\n\n  const array = cm.state.markedSelection;\n\n  if (!array.length) {\n    return coverRange(cm, from, to);\n  }\n\n  let coverStart = array[0].find(); let coverEnd = array[array.length - 1].find();\n\n  if (!coverStart || !coverEnd || to.line - from.line <= CHUNK_SIZE ||\n      cmp(from, coverEnd.to) >= 0 || cmp(to, coverStart.from) <= 0) {\n    return reset(cm);\n  }\n\n  while (cmp(from, coverStart.from) > 0) {\n    array.shift().clear();\n    coverStart = array[0].find();\n  }\n  if (cmp(from, coverStart.from) < 0) {\n    if (coverStart.to.line - from.line < CHUNK_SIZE) {\n      array.shift().clear();\n      coverRange(cm, from, coverStart.to, 0);\n    } else {\n      coverRange(cm, from, coverStart.from, 0);\n    }\n  }\n\n  while (cmp(to, coverEnd.to) < 0) {\n    array.pop().clear();\n    coverEnd = array[array.length - 1].find();\n  }\n  if (cmp(to, coverEnd.to) > 0) {\n    if (to.line - coverEnd.from.line < CHUNK_SIZE) {\n      array.pop().clear();\n      coverRange(cm, coverEnd.from, to);\n    } else {\n      coverRange(cm, coverEnd.to, to);\n    }\n  }\n}\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n// Open simple dialogs on top of an editor. Relies on dialog.css.\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  function dialogDiv(cm, template, bottom) {\n    var wrap = cm.getWrapperElement();\n    var dialog;\n    dialog = wrap.appendChild(document.createElement(\"div\"));\n    if (bottom)\n      dialog.className = \"CodeMirror-dialog CodeMirror-dialog-bottom\";\n    else\n      dialog.className = \"CodeMirror-dialog CodeMirror-dialog-top\";\n\n    if (typeof template == \"string\") {\n      dialog.innerHTML = template;\n    } else { // Assuming it's a detached DOM element.\n      dialog.appendChild(template);\n    }\n    CodeMirror.addClass(wrap, 'dialog-opened');\n    return dialog;\n  }\n\n  function closeNotification(cm, newVal) {\n    if (cm.state.currentNotificationClose)\n      cm.state.currentNotificationClose();\n    cm.state.currentNotificationClose = newVal;\n  }\n\n  CodeMirror.defineExtension(\"openDialog\", function(template, callback, options) {\n    if (!options) options = {};\n\n    closeNotification(this, null);\n\n    var dialog = dialogDiv(this, template, options.bottom);\n    var closed = false, me = this;\n    function close(newVal) {\n      if (typeof newVal == 'string') {\n        inp.value = newVal;\n      } else {\n        if (closed) return;\n        closed = true;\n        CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');\n        dialog.parentNode.removeChild(dialog);\n        me.focus();\n\n        if (options.onClose) options.onClose(dialog);\n      }\n    }\n\n    var inp = dialog.getElementsByTagName(\"input\")[0], button;\n    if (inp) {\n      inp.focus();\n\n      if (options.value) {\n        inp.value = options.value;\n        if (options.selectValueOnOpen !== false) {\n          inp.select();\n        }\n      }\n\n      if (options.onInput)\n        CodeMirror.on(inp, \"input\", function(e) { options.onInput(e, inp.value, close);});\n      if (options.onKeyUp)\n        CodeMirror.on(inp, \"keyup\", function(e) {options.onKeyUp(e, inp.value, close);});\n\n      CodeMirror.on(inp, \"keydown\", function(e) {\n        if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) { return; }\n        if (e.keyCode == 27 || (options.closeOnEnter !== false && e.keyCode == 13)) {\n          inp.blur();\n          CodeMirror.e_stop(e);\n          close();\n        }\n        if (e.keyCode == 13) callback(inp.value, e);\n      });\n\n      if (options.closeOnBlur !== false) CodeMirror.on(dialog, \"focusout\", function (evt) {\n        if (evt.relatedTarget !== null) close();\n      });\n    } else if (button = dialog.getElementsByTagName(\"button\")[0]) {\n      CodeMirror.on(button, \"click\", function() {\n        close();\n        me.focus();\n      });\n\n      if (options.closeOnBlur !== false) CodeMirror.on(button, \"blur\", close);\n\n      button.focus();\n    }\n    return close;\n  });\n\n  CodeMirror.defineExtension(\"openConfirm\", function(template, callbacks, options) {\n    closeNotification(this, null);\n    var dialog = dialogDiv(this, template, options && options.bottom);\n    var buttons = dialog.getElementsByTagName(\"button\");\n    var closed = false, me = this, blurring = 1;\n    function close() {\n      if (closed) return;\n      closed = true;\n      CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');\n      dialog.parentNode.removeChild(dialog);\n      me.focus();\n    }\n    buttons[0].focus();\n    for (var i = 0; i < buttons.length; ++i) {\n      var b = buttons[i];\n      (function(callback) {\n        CodeMirror.on(b, \"click\", function(e) {\n          CodeMirror.e_preventDefault(e);\n          close();\n          if (callback) callback(me);\n        });\n      })(callbacks[i]);\n      CodeMirror.on(b, \"blur\", function() {\n        --blurring;\n        setTimeout(function() { if (blurring <= 0) close(); }, 200);\n      });\n      CodeMirror.on(b, \"focus\", function() { ++blurring; });\n    }\n  });\n\n  /*\n   * openNotification\n   * Opens a notification, that can be closed with an optional timer\n   * (default 5000ms timer) and always closes on click.\n   *\n   * If a notification is opened while another is opened, it will close the\n   * currently opened one and open the new one immediately.\n   */\n  CodeMirror.defineExtension(\"openNotification\", function(template, options) {\n    closeNotification(this, close);\n    var dialog = dialogDiv(this, template, options && options.bottom);\n    var closed = false, doneTimer;\n    var duration = options && typeof options.duration !== \"undefined\" ? options.duration : 5000;\n\n    function close() {\n      if (closed) return;\n      closed = true;\n      clearTimeout(doneTimer);\n      CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');\n      dialog.parentNode.removeChild(dialog);\n    }\n\n    CodeMirror.on(dialog, 'click', function(e) {\n      CodeMirror.e_preventDefault(e);\n      close();\n    });\n\n    if (duration)\n      doneTimer = setTimeout(close, duration);\n\n    return close;\n  });\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  var ie_lt8 = /MSIE \\d/.test(navigator.userAgent) &&\n    (document.documentMode == null || document.documentMode < 8);\n\n  var Pos = CodeMirror.Pos;\n\n  var matching = {\"(\": \")>\", \")\": \"(<\", \"[\": \"]>\", \"]\": \"[<\", \"{\": \"}>\", \"}\": \"{<\", \"<\": \">>\", \">\": \"<<\"};\n\n  function bracketRegex(config) {\n    return config && config.bracketRegex || /[(){}[\\]]/\n  }\n\n  function findMatchingBracket(cm, where, config) {\n    var line = cm.getLineHandle(where.line), pos = where.ch - 1;\n    var afterCursor = config && config.afterCursor\n    if (afterCursor == null)\n      afterCursor = /(^| )cm-fat-cursor($| )/.test(cm.getWrapperElement().className)\n    var re = bracketRegex(config)\n\n    // A cursor is defined as between two characters, but in vim command mode\n    // (i.e. not insert mode), the cursor is visually represented as a\n    // highlighted box on top of the 2nd character. Otherwise, we allow matches\n    // from before or after the cursor.\n    var match = (!afterCursor && pos >= 0 && re.test(line.text.charAt(pos)) && matching[line.text.charAt(pos)]) ||\n        re.test(line.text.charAt(pos + 1)) && matching[line.text.charAt(++pos)];\n    if (!match) return null;\n    var dir = match.charAt(1) == \">\" ? 1 : -1;\n    if (config && config.strict && (dir > 0) != (pos == where.ch)) return null;\n    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));\n\n    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style, config);\n    if (found == null) return null;\n    return {from: Pos(where.line, pos), to: found && found.pos,\n            match: found && found.ch == match.charAt(0), forward: dir > 0};\n  }\n\n  // bracketRegex is used to specify which type of bracket to scan\n  // should be a regexp, e.g. /[[\\]]/\n  //\n  // Note: If \"where\" is on an open bracket, then this bracket is ignored.\n  //\n  // Returns false when no bracket was found, null when it reached\n  // maxScanLines and gave up\n  function scanForBracket(cm, where, dir, style, config) {\n    var maxScanLen = (config && config.maxScanLineLength) || 10000;\n    var maxScanLines = (config && config.maxScanLines) || 1000;\n\n    var stack = [];\n    var re = bracketRegex(config)\n    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1)\n                          : Math.max(cm.firstLine() - 1, where.line - maxScanLines);\n    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {\n      var line = cm.getLine(lineNo);\n      if (!line) continue;\n      var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;\n      if (line.length > maxScanLen) continue;\n      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);\n      for (; pos != end; pos += dir) {\n        var ch = line.charAt(pos);\n        if (re.test(ch) && (style === undefined ||\n                            (cm.getTokenTypeAt(Pos(lineNo, pos + 1)) || \"\") == (style || \"\"))) {\n          var match = matching[ch];\n          if (match && (match.charAt(1) == \">\") == (dir > 0)) stack.push(ch);\n          else if (!stack.length) return {pos: Pos(lineNo, pos), ch: ch};\n          else stack.pop();\n        }\n      }\n    }\n    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;\n  }\n\n  function matchBrackets(cm, autoclear, config) {\n    // Disable brace matching in long lines, since it'll cause hugely slow updates\n    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000,\n      highlightNonMatching = config && config.highlightNonMatching;\n    var marks = [], ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++) {\n      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, config);\n      if (match && (match.match || highlightNonMatching !== false) && cm.getLine(match.from.line).length <= maxHighlightLen) {\n        var style = match.match ? \"CodeMirror-matchingbracket\" : \"CodeMirror-nonmatchingbracket\";\n        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {className: style}));\n        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)\n          marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {className: style}));\n      }\n    }\n\n    if (marks.length) {\n      // Kludge to work around the IE bug from issue #1193, where text\n      // input stops going to the textarea whenever this fires.\n      if (ie_lt8 && cm.state.focused) cm.focus();\n\n      var clear = function() {\n        cm.operation(function() {\n          for (var i = 0; i < marks.length; i++) marks[i].clear();\n        });\n      };\n      if (autoclear) setTimeout(clear, 800);\n      else return clear;\n    }\n  }\n\n  function doMatchBrackets(cm) {\n    cm.operation(function() {\n      if (cm.state.matchBrackets.currentlyHighlighted) {\n        cm.state.matchBrackets.currentlyHighlighted();\n        cm.state.matchBrackets.currentlyHighlighted = null;\n      }\n      cm.state.matchBrackets.currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);\n    });\n  }\n\n  function clearHighlighted(cm) {\n    if (cm.state.matchBrackets && cm.state.matchBrackets.currentlyHighlighted) {\n      cm.state.matchBrackets.currentlyHighlighted();\n      cm.state.matchBrackets.currentlyHighlighted = null;\n    }\n  }\n\n  CodeMirror.defineOption(\"matchBrackets\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      cm.off(\"cursorActivity\", doMatchBrackets);\n      cm.off(\"focus\", doMatchBrackets)\n      cm.off(\"blur\", clearHighlighted)\n      clearHighlighted(cm);\n    }\n    if (val) {\n      cm.state.matchBrackets = typeof val == \"object\" ? val : {};\n      cm.on(\"cursorActivity\", doMatchBrackets);\n      cm.on(\"focus\", doMatchBrackets)\n      cm.on(\"blur\", clearHighlighted)\n    }\n  });\n\n  CodeMirror.defineExtension(\"matchBrackets\", function() {matchBrackets(this, true);});\n  CodeMirror.defineExtension(\"findMatchingBracket\", function(pos, config, oldConfig){\n    // Backwards-compatibility kludge\n    if (oldConfig || typeof config == \"boolean\") {\n      if (!oldConfig) {\n        config = config ? {strict: true} : null\n      } else {\n        oldConfig.strict = config\n        config = oldConfig\n      }\n    }\n    return findMatchingBracket(this, pos, config)\n  });\n  CodeMirror.defineExtension(\"scanForBracket\", function(pos, dir, style, config){\n    return scanForBracket(this, pos, dir, style, config);\n  });\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var WORD = /[\\w$]+/, RANGE = 500;\n\n  CodeMirror.registerHelper(\"hint\", \"anyword\", function(editor, options) {\n    var word = options && options.word || WORD;\n    var range = options && options.range || RANGE;\n    var cur = editor.getCursor(), curLine = editor.getLine(cur.line);\n    var end = cur.ch, start = end;\n    while (start && word.test(curLine.charAt(start - 1))) --start;\n    var curWord = start != end && curLine.slice(start, end);\n\n    var list = options && options.list || [], seen = {};\n    var re = new RegExp(word.source, \"g\");\n    for (var dir = -1; dir <= 1; dir += 2) {\n      var line = cur.line, endLine = Math.min(Math.max(line + dir * range, editor.firstLine()), editor.lastLine()) + dir;\n      for (; line != endLine; line += dir) {\n        var text = editor.getLine(line), m;\n        while (m = re.exec(text)) {\n          if (line == cur.line && m[0] === curWord) continue;\n          if ((!curWord || m[0].lastIndexOf(curWord, 0) == 0) && !Object.prototype.hasOwnProperty.call(seen, m[0])) {\n            seen[m[0]] = true;\n            list.push(m[0]);\n          }\n        }\n      }\n    }\n    return {list: list, from: CodeMirror.Pos(cur.line, start), to: CodeMirror.Pos(cur.line, end)};\n  });\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n// declare global: DOMRect\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var HINT_ELEMENT_CLASS        = \"CodeMirror-hint\";\n  var ACTIVE_HINT_ELEMENT_CLASS = \"CodeMirror-hint-active\";\n\n  // This is the old interface, kept around for now to stay\n  // backwards-compatible.\n  CodeMirror.showHint = function(cm, getHints, options) {\n    if (!getHints) return cm.showHint(options);\n    if (options && options.async) getHints.async = true;\n    var newOpts = {hint: getHints};\n    if (options) for (var prop in options) newOpts[prop] = options[prop];\n    return cm.showHint(newOpts);\n  };\n\n  CodeMirror.defineExtension(\"showHint\", function(options) {\n    options = parseOptions(this, this.getCursor(\"start\"), options);\n    var selections = this.listSelections()\n    if (selections.length > 1) return;\n    // By default, don't allow completion when something is selected.\n    // A hint function can have a `supportsSelection` property to\n    // indicate that it can handle selections.\n    if (this.somethingSelected()) {\n      if (!options.hint.supportsSelection) return;\n      // Don't try with cross-line selections\n      for (var i = 0; i < selections.length; i++)\n        if (selections[i].head.line != selections[i].anchor.line) return;\n    }\n\n    if (this.state.completionActive) this.state.completionActive.close();\n    var completion = this.state.completionActive = new Completion(this, options);\n    if (!completion.options.hint) return;\n\n    CodeMirror.signal(this, \"startCompletion\", this);\n    completion.update(true);\n  });\n\n  CodeMirror.defineExtension(\"closeHint\", function() {\n    if (this.state.completionActive) this.state.completionActive.close()\n  })\n\n  function Completion(cm, options) {\n    this.cm = cm;\n    this.options = options;\n    this.widget = null;\n    this.debounce = 0;\n    this.tick = 0;\n    this.startPos = this.cm.getCursor(\"start\");\n    this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;\n\n    if (this.options.updateOnCursorActivity) {\n      var self = this;\n      cm.on(\"cursorActivity\", this.activityFunc = function() { self.cursorActivity(); });\n    }\n  }\n\n  var requestAnimationFrame = window.requestAnimationFrame || function(fn) {\n    return setTimeout(fn, 1000/60);\n  };\n  var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;\n\n  Completion.prototype = {\n    close: function() {\n      if (!this.active()) return;\n      this.cm.state.completionActive = null;\n      this.tick = null;\n      if (this.options.updateOnCursorActivity) {\n        this.cm.off(\"cursorActivity\", this.activityFunc);\n      }\n\n      if (this.widget && this.data) CodeMirror.signal(this.data, \"close\");\n      if (this.widget) this.widget.close();\n      CodeMirror.signal(this.cm, \"endCompletion\", this.cm);\n    },\n\n    active: function() {\n      return this.cm.state.completionActive == this;\n    },\n\n    pick: function(data, i) {\n      var completion = data.list[i], self = this;\n      this.cm.operation(function() {\n        if (completion.hint)\n          completion.hint(self.cm, data, completion);\n        else\n          self.cm.replaceRange(getText(completion), completion.from || data.from,\n                               completion.to || data.to, \"complete\");\n        CodeMirror.signal(data, \"pick\", completion);\n        self.cm.scrollIntoView();\n      });\n      if (this.options.closeOnPick) {\n        this.close();\n      }\n    },\n\n    cursorActivity: function() {\n      if (this.debounce) {\n        cancelAnimationFrame(this.debounce);\n        this.debounce = 0;\n      }\n\n      var identStart = this.startPos;\n      if(this.data) {\n        identStart = this.data.from;\n      }\n\n      var pos = this.cm.getCursor(), line = this.cm.getLine(pos.line);\n      if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch ||\n          pos.ch < identStart.ch || this.cm.somethingSelected() ||\n          (!pos.ch || this.options.closeCharacters.test(line.charAt(pos.ch - 1)))) {\n        this.close();\n      } else {\n        var self = this;\n        this.debounce = requestAnimationFrame(function() {self.update();});\n        if (this.widget) this.widget.disable();\n      }\n    },\n\n    update: function(first) {\n      if (this.tick == null) return\n      var self = this, myTick = ++this.tick\n      fetchHints(this.options.hint, this.cm, this.options, function(data) {\n        if (self.tick == myTick) self.finishUpdate(data, first)\n      })\n    },\n\n    finishUpdate: function(data, first) {\n      if (this.data) CodeMirror.signal(this.data, \"update\");\n\n      var picked = (this.widget && this.widget.picked) || (first && this.options.completeSingle);\n      if (this.widget) this.widget.close();\n\n      this.data = data;\n\n      if (data && data.list.length) {\n        if (picked && data.list.length == 1) {\n          this.pick(data, 0);\n        } else {\n          this.widget = new Widget(this, data);\n          CodeMirror.signal(data, \"shown\");\n        }\n      }\n    }\n  };\n\n  function parseOptions(cm, pos, options) {\n    var editor = cm.options.hintOptions;\n    var out = {};\n    for (var prop in defaultOptions) out[prop] = defaultOptions[prop];\n    if (editor) for (var prop in editor)\n      if (editor[prop] !== undefined) out[prop] = editor[prop];\n    if (options) for (var prop in options)\n      if (options[prop] !== undefined) out[prop] = options[prop];\n    if (out.hint.resolve) out.hint = out.hint.resolve(cm, pos)\n    return out;\n  }\n\n  function getText(completion) {\n    if (typeof completion == \"string\") return completion;\n    else return completion.text;\n  }\n\n  function buildKeyMap(completion, handle) {\n    var baseMap = {\n      Up: function() {handle.moveFocus(-1);},\n      Down: function() {handle.moveFocus(1);},\n      PageUp: function() {handle.moveFocus(-handle.menuSize() + 1, true);},\n      PageDown: function() {handle.moveFocus(handle.menuSize() - 1, true);},\n      Home: function() {handle.setFocus(0);},\n      End: function() {handle.setFocus(handle.length - 1);},\n      Enter: handle.pick,\n      Tab: handle.pick,\n      Esc: handle.close\n    };\n\n    var mac = /Mac/.test(navigator.platform);\n\n    if (mac) {\n      baseMap[\"Ctrl-P\"] = function() {handle.moveFocus(-1);};\n      baseMap[\"Ctrl-N\"] = function() {handle.moveFocus(1);};\n    }\n\n    var custom = completion.options.customKeys;\n    var ourMap = custom ? {} : baseMap;\n    function addBinding(key, val) {\n      var bound;\n      if (typeof val != \"string\")\n        bound = function(cm) { return val(cm, handle); };\n      // This mechanism is deprecated\n      else if (baseMap.hasOwnProperty(val))\n        bound = baseMap[val];\n      else\n        bound = val;\n      ourMap[key] = bound;\n    }\n    if (custom)\n      for (var key in custom) if (custom.hasOwnProperty(key))\n        addBinding(key, custom[key]);\n    var extra = completion.options.extraKeys;\n    if (extra)\n      for (var key in extra) if (extra.hasOwnProperty(key))\n        addBinding(key, extra[key]);\n    return ourMap;\n  }\n\n  function getHintElement(hintsElement, el) {\n    while (el && el != hintsElement) {\n      if (el.nodeName.toUpperCase() === \"LI\" && el.parentNode == hintsElement) return el;\n      el = el.parentNode;\n    }\n  }\n\n  function Widget(completion, data) {\n    this.id = \"cm-complete-\" + Math.floor(Math.random(1e6))\n    this.completion = completion;\n    this.data = data;\n    this.picked = false;\n    var widget = this, cm = completion.cm;\n    var ownerDocument = cm.getInputField().ownerDocument;\n    var parentWindow = ownerDocument.defaultView || ownerDocument.parentWindow;\n\n    var hints = this.hints = ownerDocument.createElement(\"ul\");\n    hints.setAttribute(\"role\", \"listbox\")\n    hints.setAttribute(\"aria-expanded\", \"true\")\n    hints.id = this.id\n    var theme = completion.cm.options.theme;\n    hints.className = \"CodeMirror-hints \" + theme;\n    this.selectedHint = data.selectedHint || 0;\n\n    var completions = data.list;\n    for (var i = 0; i < completions.length; ++i) {\n      var elt = hints.appendChild(ownerDocument.createElement(\"li\")), cur = completions[i];\n      var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? \"\" : \" \" + ACTIVE_HINT_ELEMENT_CLASS);\n      if (cur.className != null) className = cur.className + \" \" + className;\n      elt.className = className;\n      if (i == this.selectedHint) elt.setAttribute(\"aria-selected\", \"true\")\n      elt.id = this.id + \"-\" + i\n      elt.setAttribute(\"role\", \"option\")\n      if (cur.render) cur.render(elt, data, cur);\n      else elt.appendChild(ownerDocument.createTextNode(cur.displayText || getText(cur)));\n      elt.hintId = i;\n    }\n\n    var container = completion.options.container || ownerDocument.body;\n    var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);\n    var left = pos.left, top = pos.bottom, below = true;\n    var offsetLeft = 0, offsetTop = 0;\n    if (container !== ownerDocument.body) {\n      // We offset the cursor position because left and top are relative to the offsetParent's top left corner.\n      var isContainerPositioned = ['absolute', 'relative', 'fixed'].indexOf(parentWindow.getComputedStyle(container).position) !== -1;\n      var offsetParent = isContainerPositioned ? container : container.offsetParent;\n      var offsetParentPosition = offsetParent.getBoundingClientRect();\n      var bodyPosition = ownerDocument.body.getBoundingClientRect();\n      offsetLeft = (offsetParentPosition.left - bodyPosition.left - offsetParent.scrollLeft);\n      offsetTop = (offsetParentPosition.top - bodyPosition.top - offsetParent.scrollTop);\n    }\n    hints.style.left = (left - offsetLeft) + \"px\";\n    hints.style.top = (top - offsetTop) + \"px\";\n\n    // If we're at the edge of the screen, then we want the menu to appear on the left of the cursor.\n    var winW = parentWindow.innerWidth || Math.max(ownerDocument.body.offsetWidth, ownerDocument.documentElement.offsetWidth);\n    var winH = parentWindow.innerHeight || Math.max(ownerDocument.body.offsetHeight, ownerDocument.documentElement.offsetHeight);\n    container.appendChild(hints);\n    cm.getInputField().setAttribute(\"aria-autocomplete\", \"list\")\n    cm.getInputField().setAttribute(\"aria-owns\", this.id)\n    cm.getInputField().setAttribute(\"aria-activedescendant\", this.id + \"-\" + this.selectedHint)\n\n    var box = completion.options.moveOnOverlap ? hints.getBoundingClientRect() : new DOMRect();\n    var scrolls = completion.options.paddingForScrollbar ? hints.scrollHeight > hints.clientHeight + 1 : false;\n\n    // Compute in the timeout to avoid reflow on init\n    var startScroll;\n    setTimeout(function() { startScroll = cm.getScrollInfo(); });\n\n    var overlapY = box.bottom - winH;\n    if (overlapY > 0) { // Does not fit below\n      var height = box.bottom - box.top, spaceAbove = box.top - (pos.bottom - pos.top) - 2\n      if (winH - box.top < spaceAbove) { // More room at the top\n        if (height > spaceAbove) hints.style.height = (height = spaceAbove) + \"px\";\n        hints.style.top = ((top = pos.top - height) + offsetTop) + \"px\";\n        below = false;\n      } else {\n        hints.style.height = (winH - box.top - 2) + \"px\";\n      }\n    }\n    var overlapX = box.right - winW;\n    if (scrolls) overlapX += cm.display.nativeBarWidth;\n    if (overlapX > 0) {\n      if (box.right - box.left > winW) {\n        hints.style.width = (winW - 5) + \"px\";\n        overlapX -= (box.right - box.left) - winW;\n      }\n      hints.style.left = (left = Math.max(pos.left - overlapX - offsetLeft, 0)) + \"px\";\n    }\n    if (scrolls) for (var node = hints.firstChild; node; node = node.nextSibling)\n      node.style.paddingRight = cm.display.nativeBarWidth + \"px\"\n\n    cm.addKeyMap(this.keyMap = buildKeyMap(completion, {\n      moveFocus: function(n, avoidWrap) { widget.changeActive(widget.selectedHint + n, avoidWrap); },\n      setFocus: function(n) { widget.changeActive(n); },\n      menuSize: function() { return widget.screenAmount(); },\n      length: completions.length,\n      close: function() { completion.close(); },\n      pick: function() { widget.pick(); },\n      data: data\n    }));\n\n    if (completion.options.closeOnUnfocus) {\n      var closingOnBlur;\n      cm.on(\"blur\", this.onBlur = function() { closingOnBlur = setTimeout(function() { completion.close(); }, 100); });\n      cm.on(\"focus\", this.onFocus = function() { clearTimeout(closingOnBlur); });\n    }\n\n    cm.on(\"scroll\", this.onScroll = function() {\n      var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect();\n      if (!startScroll) startScroll = cm.getScrollInfo();\n      var newTop = top + startScroll.top - curScroll.top;\n      var point = newTop - (parentWindow.pageYOffset || (ownerDocument.documentElement || ownerDocument.body).scrollTop);\n      if (!below) point += hints.offsetHeight;\n      if (point <= editor.top || point >= editor.bottom) return completion.close();\n      hints.style.top = newTop + \"px\";\n      hints.style.left = (left + startScroll.left - curScroll.left) + \"px\";\n    });\n\n    CodeMirror.on(hints, \"dblclick\", function(e) {\n      var t = getHintElement(hints, e.target || e.srcElement);\n      if (t && t.hintId != null) {widget.changeActive(t.hintId); widget.pick();}\n    });\n\n    CodeMirror.on(hints, \"click\", function(e) {\n      var t = getHintElement(hints, e.target || e.srcElement);\n      if (t && t.hintId != null) {\n        widget.changeActive(t.hintId);\n        if (completion.options.completeOnSingleClick) widget.pick();\n      }\n    });\n\n    CodeMirror.on(hints, \"mousedown\", function() {\n      setTimeout(function(){cm.focus();}, 20);\n    });\n\n    // The first hint doesn't need to be scrolled to on init\n    var selectedHintRange = this.getSelectedHintRange();\n    if (selectedHintRange.from !== 0 || selectedHintRange.to !== 0) {\n      this.scrollToActive();\n    }\n\n    CodeMirror.signal(data, \"select\", completions[this.selectedHint], hints.childNodes[this.selectedHint]);\n    return true;\n  }\n\n  Widget.prototype = {\n    close: function() {\n      if (this.completion.widget != this) return;\n      this.completion.widget = null;\n      if (this.hints.parentNode) this.hints.parentNode.removeChild(this.hints);\n      this.completion.cm.removeKeyMap(this.keyMap);\n      var input = this.completion.cm.getInputField()\n      input.removeAttribute(\"aria-activedescendant\")\n      input.removeAttribute(\"aria-owns\")\n\n      var cm = this.completion.cm;\n      if (this.completion.options.closeOnUnfocus) {\n        cm.off(\"blur\", this.onBlur);\n        cm.off(\"focus\", this.onFocus);\n      }\n      cm.off(\"scroll\", this.onScroll);\n    },\n\n    disable: function() {\n      this.completion.cm.removeKeyMap(this.keyMap);\n      var widget = this;\n      this.keyMap = {Enter: function() { widget.picked = true; }};\n      this.completion.cm.addKeyMap(this.keyMap);\n    },\n\n    pick: function() {\n      this.completion.pick(this.data, this.selectedHint);\n    },\n\n    changeActive: function(i, avoidWrap) {\n      if (i >= this.data.list.length)\n        i = avoidWrap ? this.data.list.length - 1 : 0;\n      else if (i < 0)\n        i = avoidWrap ? 0  : this.data.list.length - 1;\n      if (this.selectedHint == i) return;\n      var node = this.hints.childNodes[this.selectedHint];\n      if (node) {\n        node.className = node.className.replace(\" \" + ACTIVE_HINT_ELEMENT_CLASS, \"\");\n        node.removeAttribute(\"aria-selected\")\n      }\n      node = this.hints.childNodes[this.selectedHint = i];\n      node.className += \" \" + ACTIVE_HINT_ELEMENT_CLASS;\n      node.setAttribute(\"aria-selected\", \"true\")\n      this.completion.cm.getInputField().setAttribute(\"aria-activedescendant\", node.id)\n      this.scrollToActive()\n      CodeMirror.signal(this.data, \"select\", this.data.list[this.selectedHint], node);\n    },\n\n    scrollToActive: function() {\n      var selectedHintRange = this.getSelectedHintRange();\n      var node1 = this.hints.childNodes[selectedHintRange.from];\n      var node2 = this.hints.childNodes[selectedHintRange.to];\n      var firstNode = this.hints.firstChild;\n      if (node1.offsetTop < this.hints.scrollTop)\n        this.hints.scrollTop = node1.offsetTop - firstNode.offsetTop;\n      else if (node2.offsetTop + node2.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)\n        this.hints.scrollTop = node2.offsetTop + node2.offsetHeight - this.hints.clientHeight + firstNode.offsetTop;\n    },\n\n    screenAmount: function() {\n      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;\n    },\n\n    getSelectedHintRange: function() {\n      var margin = this.completion.options.scrollMargin || 0;\n      return {\n        from: Math.max(0, this.selectedHint - margin),\n        to: Math.min(this.data.list.length - 1, this.selectedHint + margin),\n      };\n    }\n  };\n\n  function applicableHelpers(cm, helpers) {\n    if (!cm.somethingSelected()) return helpers\n    var result = []\n    for (var i = 0; i < helpers.length; i++)\n      if (helpers[i].supportsSelection) result.push(helpers[i])\n    return result\n  }\n\n  function fetchHints(hint, cm, options, callback) {\n    if (hint.async) {\n      hint(cm, callback, options)\n    } else {\n      var result = hint(cm, options)\n      if (result && result.then) result.then(callback)\n      else callback(result)\n    }\n  }\n\n  function resolveAutoHints(cm, pos) {\n    var helpers = cm.getHelpers(pos, \"hint\"), words\n    if (helpers.length) {\n      var resolved = function(cm, callback, options) {\n        var app = applicableHelpers(cm, helpers);\n        function run(i) {\n          if (i == app.length) return callback(null)\n          fetchHints(app[i], cm, options, function(result) {\n            if (result && result.list.length > 0) callback(result)\n            else run(i + 1)\n          })\n        }\n        run(0)\n      }\n      resolved.async = true\n      resolved.supportsSelection = true\n      return resolved\n    } else if (words = cm.getHelper(cm.getCursor(), \"hintWords\")) {\n      return function(cm) { return CodeMirror.hint.fromList(cm, {words: words}) }\n    } else if (CodeMirror.hint.anyword) {\n      return function(cm, options) { return CodeMirror.hint.anyword(cm, options) }\n    } else {\n      return function() {}\n    }\n  }\n\n  CodeMirror.registerHelper(\"hint\", \"auto\", {\n    resolve: resolveAutoHints\n  });\n\n  CodeMirror.registerHelper(\"hint\", \"fromList\", function(cm, options) {\n    var cur = cm.getCursor(), token = cm.getTokenAt(cur)\n    var term, from = CodeMirror.Pos(cur.line, token.start), to = cur\n    if (token.start < cur.ch && /\\w/.test(token.string.charAt(cur.ch - token.start - 1))) {\n      term = token.string.substr(0, cur.ch - token.start)\n    } else {\n      term = \"\"\n      from = cur\n    }\n    var found = [];\n    for (var i = 0; i < options.words.length; i++) {\n      var word = options.words[i];\n      if (word.slice(0, term.length) == term)\n        found.push(word);\n    }\n\n    if (found.length) return {list: found, from: from, to: to};\n  });\n\n  CodeMirror.commands.autocomplete = CodeMirror.showHint;\n\n  var defaultOptions = {\n    hint: CodeMirror.hint.auto,\n    completeSingle: true,\n    alignWithWord: true,\n    closeCharacters: /[\\s()\\[\\]{};:>,]/,\n    closeOnPick: true,\n    closeOnUnfocus: true,\n    updateOnCursorActivity: true,\n    completeOnSingleClick: true,\n    container: null,\n    customKeys: null,\n    extraKeys: null,\n    paddingForScrollbar: true,\n    moveOnOverlap: true,\n  };\n\n  CodeMirror.defineOption(\"hintOptions\", null);\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n  var GUTTER_ID = \"CodeMirror-lint-markers\";\n  var LINT_LINE_ID = \"CodeMirror-lint-line-\";\n\n  function showTooltip(cm, e, content) {\n    var tt = document.createElement(\"div\");\n    tt.className = \"CodeMirror-lint-tooltip cm-s-\" + cm.options.theme;\n    tt.appendChild(content.cloneNode(true));\n    if (cm.state.lint.options.selfContain)\n      cm.getWrapperElement().appendChild(tt);\n    else\n      document.body.appendChild(tt);\n\n    function position(e) {\n      if (!tt.parentNode) return CodeMirror.off(document, \"mousemove\", position);\n      var top = Math.max(0, e.clientY - tt.offsetHeight - 5);\n      var left = Math.max(0, Math.min(e.clientX + 5, tt.ownerDocument.defaultView.innerWidth - tt.offsetWidth));\n      tt.style.top = top + \"px\"\n      tt.style.left = left + \"px\";\n    }\n    CodeMirror.on(document, \"mousemove\", position);\n    position(e);\n    if (tt.style.opacity != null) tt.style.opacity = 1;\n    return tt;\n  }\n  function rm(elt) {\n    if (elt.parentNode) elt.parentNode.removeChild(elt);\n  }\n  function hideTooltip(tt) {\n    if (!tt.parentNode) return;\n    if (tt.style.opacity == null) rm(tt);\n    tt.style.opacity = 0;\n    setTimeout(function() { rm(tt); }, 600);\n  }\n\n  function showTooltipFor(cm, e, content, node) {\n    var tooltip = showTooltip(cm, e, content);\n    function hide() {\n      CodeMirror.off(node, \"mouseout\", hide);\n      if (tooltip) { hideTooltip(tooltip); tooltip = null; }\n    }\n    var poll = setInterval(function() {\n      if (tooltip) for (var n = node;; n = n.parentNode) {\n        if (n && n.nodeType == 11) n = n.host;\n        if (n == document.body) return;\n        if (!n) { hide(); break; }\n      }\n      if (!tooltip) return clearInterval(poll);\n    }, 400);\n    CodeMirror.on(node, \"mouseout\", hide);\n  }\n\n  function LintState(cm, conf, hasGutter) {\n    this.marked = [];\n    if (conf instanceof Function) conf = {getAnnotations: conf};\n    if (!conf || conf === true) conf = {};\n    this.options = {};\n    this.linterOptions = conf.options || {};\n    for (var prop in defaults) this.options[prop] = defaults[prop];\n    for (var prop in conf) {\n      if (defaults.hasOwnProperty(prop)) {\n        if (conf[prop] != null) this.options[prop] = conf[prop];\n      } else if (!conf.options) {\n        this.linterOptions[prop] = conf[prop];\n      }\n    }\n    this.timeout = null;\n    this.hasGutter = hasGutter;\n    this.onMouseOver = function(e) { onMouseOver(cm, e); };\n    this.waitingFor = 0\n  }\n\n  var defaults = {\n    highlightLines: false,\n    tooltips: true,\n    delay: 500,\n    lintOnChange: true,\n    getAnnotations: null,\n    async: false,\n    selfContain: null,\n    formatAnnotation: null,\n    onUpdateLinting: null\n  }\n\n  function clearMarks(cm) {\n    var state = cm.state.lint;\n    if (state.hasGutter) cm.clearGutter(GUTTER_ID);\n    if (state.options.highlightLines) clearErrorLines(cm);\n    for (var i = 0; i < state.marked.length; ++i)\n      state.marked[i].clear();\n    state.marked.length = 0;\n  }\n\n  function clearErrorLines(cm) {\n    cm.eachLine(function(line) {\n      var has = line.wrapClass && /\\bCodeMirror-lint-line-\\w+\\b/.exec(line.wrapClass);\n      if (has) cm.removeLineClass(line, \"wrap\", has[0]);\n    })\n  }\n\n  function makeMarker(cm, labels, severity, multiple, tooltips) {\n    var marker = document.createElement(\"div\"), inner = marker;\n    marker.className = \"CodeMirror-lint-marker CodeMirror-lint-marker-\" + severity;\n    if (multiple) {\n      inner = marker.appendChild(document.createElement(\"div\"));\n      inner.className = \"CodeMirror-lint-marker CodeMirror-lint-marker-multiple\";\n    }\n\n    if (tooltips != false) CodeMirror.on(inner, \"mouseover\", function(e) {\n      showTooltipFor(cm, e, labels, inner);\n    });\n\n    return marker;\n  }\n\n  function getMaxSeverity(a, b) {\n    if (a == \"error\") return a;\n    else return b;\n  }\n\n  function groupByLine(annotations) {\n    var lines = [];\n    for (var i = 0; i < annotations.length; ++i) {\n      var ann = annotations[i], line = ann.from.line;\n      (lines[line] || (lines[line] = [])).push(ann);\n    }\n    return lines;\n  }\n\n  function annotationTooltip(ann) {\n    var severity = ann.severity;\n    if (!severity) severity = \"error\";\n    var tip = document.createElement(\"div\");\n    tip.className = \"CodeMirror-lint-message CodeMirror-lint-message-\" + severity;\n    if (typeof ann.messageHTML != 'undefined') {\n      tip.innerHTML = ann.messageHTML;\n    } else {\n      tip.appendChild(document.createTextNode(ann.message));\n    }\n    return tip;\n  }\n\n  function lintAsync(cm, getAnnotations) {\n    var state = cm.state.lint\n    var id = ++state.waitingFor\n    function abort() {\n      id = -1\n      cm.off(\"change\", abort)\n    }\n    cm.on(\"change\", abort)\n    getAnnotations(cm.getValue(), function(annotations, arg2) {\n      cm.off(\"change\", abort)\n      if (state.waitingFor != id) return\n      if (arg2 && annotations instanceof CodeMirror) annotations = arg2\n      cm.operation(function() {updateLinting(cm, annotations)})\n    }, state.linterOptions, cm);\n  }\n\n  function startLinting(cm) {\n    var state = cm.state.lint;\n    if (!state) return;\n    var options = state.options;\n    /*\n     * Passing rules in `options` property prevents JSHint (and other linters) from complaining\n     * about unrecognized rules like `onUpdateLinting`, `delay`, `lintOnChange`, etc.\n     */\n    var getAnnotations = options.getAnnotations || cm.getHelper(CodeMirror.Pos(0, 0), \"lint\");\n    if (!getAnnotations) return;\n    if (options.async || getAnnotations.async) {\n      lintAsync(cm, getAnnotations)\n    } else {\n      var annotations = getAnnotations(cm.getValue(), state.linterOptions, cm);\n      if (!annotations) return;\n      if (annotations.then) annotations.then(function(issues) {\n        cm.operation(function() {updateLinting(cm, issues)})\n      });\n      else cm.operation(function() {updateLinting(cm, annotations)})\n    }\n  }\n\n  function updateLinting(cm, annotationsNotSorted) {\n    var state = cm.state.lint;\n    if (!state) return;\n    var options = state.options;\n    clearMarks(cm);\n\n    var annotations = groupByLine(annotationsNotSorted);\n\n    for (var line = 0; line < annotations.length; ++line) {\n      var anns = annotations[line];\n      if (!anns) continue;\n\n      var maxSeverity = null;\n      var tipLabel = state.hasGutter && document.createDocumentFragment();\n\n      for (var i = 0; i < anns.length; ++i) {\n        var ann = anns[i];\n        var severity = ann.severity;\n        if (!severity) severity = \"error\";\n        maxSeverity = getMaxSeverity(maxSeverity, severity);\n\n        if (options.formatAnnotation) ann = options.formatAnnotation(ann);\n        if (state.hasGutter) tipLabel.appendChild(annotationTooltip(ann));\n\n        if (ann.to) state.marked.push(cm.markText(ann.from, ann.to, {\n          className: \"CodeMirror-lint-mark CodeMirror-lint-mark-\" + severity,\n          __annotation: ann\n        }));\n      }\n      if (state.hasGutter)\n        cm.setGutterMarker(line, GUTTER_ID, makeMarker(cm, tipLabel, maxSeverity, anns.length > 1,\n                                                       options.tooltips));\n\n      if (options.highlightLines)\n        cm.addLineClass(line, \"wrap\", LINT_LINE_ID + maxSeverity);\n    }\n    if (options.onUpdateLinting) options.onUpdateLinting(annotationsNotSorted, annotations, cm);\n  }\n\n  function onChange(cm) {\n    var state = cm.state.lint;\n    if (!state) return;\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(function(){startLinting(cm);}, state.options.delay);\n  }\n\n  function popupTooltips(cm, annotations, e) {\n    var target = e.target || e.srcElement;\n    var tooltip = document.createDocumentFragment();\n    for (var i = 0; i < annotations.length; i++) {\n      var ann = annotations[i];\n      tooltip.appendChild(annotationTooltip(ann));\n    }\n    showTooltipFor(cm, e, tooltip, target);\n  }\n\n  function onMouseOver(cm, e) {\n    var target = e.target || e.srcElement;\n    if (!/\\bCodeMirror-lint-mark-/.test(target.className)) return;\n    var box = target.getBoundingClientRect(), x = (box.left + box.right) / 2, y = (box.top + box.bottom) / 2;\n    var spans = cm.findMarksAt(cm.coordsChar({left: x, top: y}, \"client\"));\n\n    var annotations = [];\n    for (var i = 0; i < spans.length; ++i) {\n      var ann = spans[i].__annotation;\n      if (ann) annotations.push(ann);\n    }\n    if (annotations.length) popupTooltips(cm, annotations, e);\n  }\n\n  CodeMirror.defineOption(\"lint\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      clearMarks(cm);\n      if (cm.state.lint.options.lintOnChange !== false)\n        cm.off(\"change\", onChange);\n      CodeMirror.off(cm.getWrapperElement(), \"mouseover\", cm.state.lint.onMouseOver);\n      clearTimeout(cm.state.lint.timeout);\n      delete cm.state.lint;\n    }\n\n    if (val) {\n      var gutters = cm.getOption(\"gutters\"), hasLintGutter = false;\n      for (var i = 0; i < gutters.length; ++i) if (gutters[i] == GUTTER_ID) hasLintGutter = true;\n      var state = cm.state.lint = new LintState(cm, val, hasLintGutter);\n      if (state.options.lintOnChange)\n        cm.on(\"change\", onChange);\n      if (state.options.tooltips != false && state.options.tooltips != \"gutter\")\n        CodeMirror.on(cm.getWrapperElement(), \"mouseover\", state.onMouseOver);\n\n      startLinting(cm);\n    }\n  });\n\n  CodeMirror.defineExtension(\"performLint\", function() {\n    startLinting(this);\n  });\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\n// Depends on js-yaml.js from https://github.com/nodeca/js-yaml\n\n// declare global: jsyaml\n\nCodeMirror.registerHelper(\"lint\", \"yaml\", function(text) {\n  var found = [];\n  if (!window.jsyaml) {\n    if (window.console) {\n      window.console.error(\"Error: window.jsyaml not defined, CodeMirror YAML linting cannot run.\");\n    }\n    return found;\n  }\n  try { jsyaml.loadAll(text); }\n  catch(e) {\n      var loc = e.mark,\n          // js-yaml YAMLException doesn't always provide an accurate lineno\n          // e.g., when there are multiple yaml docs\n          // ---\n          // ---\n          // foo:bar\n          from = loc ? CodeMirror.Pos(loc.line, loc.column) : CodeMirror.Pos(0, 0),\n          to = from;\n      found.push({ from: from, to: to, message: e.message });\n  }\n  return found;\n});\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"))\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod)\n  else // Plain browser env\n    mod(CodeMirror)\n})(function(CodeMirror) {\n  \"use strict\"\n  var Pos = CodeMirror.Pos\n\n  function regexpFlags(regexp) {\n    var flags = regexp.flags\n    return flags != null ? flags : (regexp.ignoreCase ? \"i\" : \"\")\n      + (regexp.global ? \"g\" : \"\")\n      + (regexp.multiline ? \"m\" : \"\")\n  }\n\n  function ensureFlags(regexp, flags) {\n    var current = regexpFlags(regexp), target = current\n    for (var i = 0; i < flags.length; i++) if (target.indexOf(flags.charAt(i)) == -1)\n      target += flags.charAt(i)\n    return current == target ? regexp : new RegExp(regexp.source, target)\n  }\n\n  function maybeMultiline(regexp) {\n    return /\\\\s|\\\\n|\\n|\\\\W|\\\\D|\\[\\^/.test(regexp.source)\n  }\n\n  function searchRegexpForward(doc, regexp, start) {\n    regexp = ensureFlags(regexp, \"g\")\n    for (var line = start.line, ch = start.ch, last = doc.lastLine(); line <= last; line++, ch = 0) {\n      regexp.lastIndex = ch\n      var string = doc.getLine(line), match = regexp.exec(string)\n      if (match)\n        return {from: Pos(line, match.index),\n                to: Pos(line, match.index + match[0].length),\n                match: match}\n    }\n  }\n\n  function searchRegexpForwardMultiline(doc, regexp, start) {\n    if (!maybeMultiline(regexp)) return searchRegexpForward(doc, regexp, start)\n\n    regexp = ensureFlags(regexp, \"gm\")\n    var string, chunk = 1\n    for (var line = start.line, last = doc.lastLine(); line <= last;) {\n      // This grows the search buffer in exponentially-sized chunks\n      // between matches, so that nearby matches are fast and don't\n      // require concatenating the whole document (in case we're\n      // searching for something that has tons of matches), but at the\n      // same time, the amount of retries is limited.\n      for (var i = 0; i < chunk; i++) {\n        if (line > last) break\n        var curLine = doc.getLine(line++)\n        string = string == null ? curLine : string + \"\\n\" + curLine\n      }\n      chunk = chunk * 2\n      regexp.lastIndex = start.ch\n      var match = regexp.exec(string)\n      if (match) {\n        var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\")\n        var startLine = start.line + before.length - 1, startCh = before[before.length - 1].length\n        return {from: Pos(startLine, startCh),\n                to: Pos(startLine + inside.length - 1,\n                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n                match: match}\n      }\n    }\n  }\n\n  function lastMatchIn(string, regexp, endMargin) {\n    var match, from = 0\n    while (from <= string.length) {\n      regexp.lastIndex = from\n      var newMatch = regexp.exec(string)\n      if (!newMatch) break\n      var end = newMatch.index + newMatch[0].length\n      if (end > string.length - endMargin) break\n      if (!match || end > match.index + match[0].length)\n        match = newMatch\n      from = newMatch.index + 1\n    }\n    return match\n  }\n\n  function searchRegexpBackward(doc, regexp, start) {\n    regexp = ensureFlags(regexp, \"g\")\n    for (var line = start.line, ch = start.ch, first = doc.firstLine(); line >= first; line--, ch = -1) {\n      var string = doc.getLine(line)\n      var match = lastMatchIn(string, regexp, ch < 0 ? 0 : string.length - ch)\n      if (match)\n        return {from: Pos(line, match.index),\n                to: Pos(line, match.index + match[0].length),\n                match: match}\n    }\n  }\n\n  function searchRegexpBackwardMultiline(doc, regexp, start) {\n    if (!maybeMultiline(regexp)) return searchRegexpBackward(doc, regexp, start)\n    regexp = ensureFlags(regexp, \"gm\")\n    var string, chunkSize = 1, endMargin = doc.getLine(start.line).length - start.ch\n    for (var line = start.line, first = doc.firstLine(); line >= first;) {\n      for (var i = 0; i < chunkSize && line >= first; i++) {\n        var curLine = doc.getLine(line--)\n        string = string == null ? curLine : curLine + \"\\n\" + string\n      }\n      chunkSize *= 2\n\n      var match = lastMatchIn(string, regexp, endMargin)\n      if (match) {\n        var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\")\n        var startLine = line + before.length, startCh = before[before.length - 1].length\n        return {from: Pos(startLine, startCh),\n                to: Pos(startLine + inside.length - 1,\n                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n                match: match}\n      }\n    }\n  }\n\n  var doFold, noFold\n  if (String.prototype.normalize) {\n    doFold = function(str) { return str.normalize(\"NFD\").toLowerCase() }\n    noFold = function(str) { return str.normalize(\"NFD\") }\n  } else {\n    doFold = function(str) { return str.toLowerCase() }\n    noFold = function(str) { return str }\n  }\n\n  // Maps a position in a case-folded line back to a position in the original line\n  // (compensating for codepoints increasing in number during folding)\n  function adjustPos(orig, folded, pos, foldFunc) {\n    if (orig.length == folded.length) return pos\n    for (var min = 0, max = pos + Math.max(0, orig.length - folded.length);;) {\n      if (min == max) return min\n      var mid = (min + max) >> 1\n      var len = foldFunc(orig.slice(0, mid)).length\n      if (len == pos) return mid\n      else if (len > pos) max = mid\n      else min = mid + 1\n    }\n  }\n\n  function searchStringForward(doc, query, start, caseFold) {\n    // Empty string would match anything and never progress, so we\n    // define it to match nothing instead.\n    if (!query.length) return null\n    var fold = caseFold ? doFold : noFold\n    var lines = fold(query).split(/\\r|\\n\\r?/)\n\n    search: for (var line = start.line, ch = start.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, ch = 0) {\n      var orig = doc.getLine(line).slice(ch), string = fold(orig)\n      if (lines.length == 1) {\n        var found = string.indexOf(lines[0])\n        if (found == -1) continue search\n        var start = adjustPos(orig, string, found, fold) + ch\n        return {from: Pos(line, adjustPos(orig, string, found, fold) + ch),\n                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold) + ch)}\n      } else {\n        var cutFrom = string.length - lines[0].length\n        if (string.slice(cutFrom) != lines[0]) continue search\n        for (var i = 1; i < lines.length - 1; i++)\n          if (fold(doc.getLine(line + i)) != lines[i]) continue search\n        var end = doc.getLine(line + lines.length - 1), endString = fold(end), lastLine = lines[lines.length - 1]\n        if (endString.slice(0, lastLine.length) != lastLine) continue search\n        return {from: Pos(line, adjustPos(orig, string, cutFrom, fold) + ch),\n                to: Pos(line + lines.length - 1, adjustPos(end, endString, lastLine.length, fold))}\n      }\n    }\n  }\n\n  function searchStringBackward(doc, query, start, caseFold) {\n    if (!query.length) return null\n    var fold = caseFold ? doFold : noFold\n    var lines = fold(query).split(/\\r|\\n\\r?/)\n\n    search: for (var line = start.line, ch = start.ch, first = doc.firstLine() - 1 + lines.length; line >= first; line--, ch = -1) {\n      var orig = doc.getLine(line)\n      if (ch > -1) orig = orig.slice(0, ch)\n      var string = fold(orig)\n      if (lines.length == 1) {\n        var found = string.lastIndexOf(lines[0])\n        if (found == -1) continue search\n        return {from: Pos(line, adjustPos(orig, string, found, fold)),\n                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold))}\n      } else {\n        var lastLine = lines[lines.length - 1]\n        if (string.slice(0, lastLine.length) != lastLine) continue search\n        for (var i = 1, start = line - lines.length + 1; i < lines.length - 1; i++)\n          if (fold(doc.getLine(start + i)) != lines[i]) continue search\n        var top = doc.getLine(line + 1 - lines.length), topString = fold(top)\n        if (topString.slice(topString.length - lines[0].length) != lines[0]) continue search\n        return {from: Pos(line + 1 - lines.length, adjustPos(top, topString, top.length - lines[0].length, fold)),\n                to: Pos(line, adjustPos(orig, string, lastLine.length, fold))}\n      }\n    }\n  }\n\n  function SearchCursor(doc, query, pos, options) {\n    this.atOccurrence = false\n    this.afterEmptyMatch = false\n    this.doc = doc\n    pos = pos ? doc.clipPos(pos) : Pos(0, 0)\n    this.pos = {from: pos, to: pos}\n\n    var caseFold\n    if (typeof options == \"object\") {\n      caseFold = options.caseFold\n    } else { // Backwards compat for when caseFold was the 4th argument\n      caseFold = options\n      options = null\n    }\n\n    if (typeof query == \"string\") {\n      if (caseFold == null) caseFold = false\n      this.matches = function(reverse, pos) {\n        return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos, caseFold)\n      }\n    } else {\n      query = ensureFlags(query, \"gm\")\n      if (!options || options.multiline !== false)\n        this.matches = function(reverse, pos) {\n          return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos)\n        }\n      else\n        this.matches = function(reverse, pos) {\n          return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos)\n        }\n    }\n  }\n\n  SearchCursor.prototype = {\n    findNext: function() {return this.find(false)},\n    findPrevious: function() {return this.find(true)},\n\n    find: function(reverse) {\n      var head = this.doc.clipPos(reverse ? this.pos.from : this.pos.to);\n      if (this.afterEmptyMatch && this.atOccurrence) {\n        // do not return the same 0 width match twice\n        head = Pos(head.line, head.ch)\n        if (reverse) {\n          head.ch--;\n          if (head.ch < 0) {\n            head.line--;\n            head.ch = (this.doc.getLine(head.line) || \"\").length;\n          }\n        } else {\n          head.ch++;\n          if (head.ch > (this.doc.getLine(head.line) || \"\").length) {\n            head.ch = 0;\n            head.line++;\n          }\n        }\n        if (CodeMirror.cmpPos(head, this.doc.clipPos(head)) != 0) {\n           return this.atOccurrence = false\n        }\n      }\n      var result = this.matches(reverse, head)\n      this.afterEmptyMatch = result && CodeMirror.cmpPos(result.from, result.to) == 0\n\n      if (result) {\n        this.pos = result\n        this.atOccurrence = true\n        return this.pos.match || true\n      } else {\n        var end = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0)\n        this.pos = {from: end, to: end}\n        return this.atOccurrence = false\n      }\n    },\n\n    from: function() {if (this.atOccurrence) return this.pos.from},\n    to: function() {if (this.atOccurrence) return this.pos.to},\n\n    replace: function(newText, origin) {\n      if (!this.atOccurrence) return\n      var lines = CodeMirror.splitLines(newText)\n      this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin)\n      this.pos.to = Pos(this.pos.from.line + lines.length - 1,\n                        lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0))\n    }\n  }\n\n  CodeMirror.defineExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this.doc, query, pos, caseFold)\n  })\n  CodeMirror.defineDocExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this, query, pos, caseFold)\n  })\n\n  CodeMirror.defineExtension(\"selectMatches\", function(query, caseFold) {\n    var ranges = []\n    var cur = this.getSearchCursor(query, this.getCursor(\"from\"), caseFold)\n    while (cur.findNext()) {\n      if (CodeMirror.cmpPos(cur.to(), this.getCursor(\"to\")) > 0) break\n      ranges.push({anchor: cur.from(), head: cur.to()})\n    }\n    if (ranges.length)\n      this.setSelections(ranges, 0)\n  })\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var cmds = CodeMirror.commands;\n  var Pos = CodeMirror.Pos;\n  function posEq(a, b) { return a.line == b.line && a.ch == b.ch; }\n\n  // Kill 'ring'\n\n  var killRing = [];\n  function addToRing(str) {\n    killRing.push(str);\n    if (killRing.length > 50) killRing.shift();\n  }\n  function growRingTop(str) {\n    if (!killRing.length) return addToRing(str);\n    killRing[killRing.length - 1] += str;\n  }\n  function getFromRing(n) { return killRing[killRing.length - (n ? Math.min(n, 1) : 1)] || \"\"; }\n  function popFromRing() { if (killRing.length > 1) killRing.pop(); return getFromRing(); }\n\n  var lastKill = null;\n\n  // Internal generic kill function, used by several mapped kill \"family\" functions.\n  function _kill(cm, from, to, ring, text) {\n    if (text == null) text = cm.getRange(from, to);\n\n    if (ring == \"grow\" && lastKill && lastKill.cm == cm && posEq(from, lastKill.pos) && cm.isClean(lastKill.gen))\n      growRingTop(text);\n    else if (ring !== false)\n      addToRing(text);\n    cm.replaceRange(\"\", from, to, \"+delete\");\n\n    if (ring == \"grow\") lastKill = {cm: cm, pos: from, gen: cm.changeGeneration()};\n    else lastKill = null;\n  }\n\n  // Boundaries of various units\n\n  function byChar(cm, pos, dir) {\n    return cm.findPosH(pos, dir, \"char\", true);\n  }\n\n  function byWord(cm, pos, dir) {\n    return cm.findPosH(pos, dir, \"word\", true);\n  }\n\n  function byLine(cm, pos, dir) {\n    return cm.findPosV(pos, dir, \"line\", cm.doc.sel.goalColumn);\n  }\n\n  function byPage(cm, pos, dir) {\n    return cm.findPosV(pos, dir, \"page\", cm.doc.sel.goalColumn);\n  }\n\n  function byParagraph(cm, pos, dir) {\n    var no = pos.line, line = cm.getLine(no);\n    var sawText = /\\S/.test(dir < 0 ? line.slice(0, pos.ch) : line.slice(pos.ch));\n    var fst = cm.firstLine(), lst = cm.lastLine();\n    for (;;) {\n      no += dir;\n      if (no < fst || no > lst)\n        return cm.clipPos(Pos(no - dir, dir < 0 ? 0 : null));\n      line = cm.getLine(no);\n      var hasText = /\\S/.test(line);\n      if (hasText) sawText = true;\n      else if (sawText) return Pos(no, 0);\n    }\n  }\n\n  function bySentence(cm, pos, dir) {\n    var line = pos.line, ch = pos.ch;\n    var text = cm.getLine(pos.line), sawWord = false;\n    for (;;) {\n      var next = text.charAt(ch + (dir < 0 ? -1 : 0));\n      if (!next) { // End/beginning of line reached\n        if (line == (dir < 0 ? cm.firstLine() : cm.lastLine())) return Pos(line, ch);\n        text = cm.getLine(line + dir);\n        if (!/\\S/.test(text)) return Pos(line, ch);\n        line += dir;\n        ch = dir < 0 ? text.length : 0;\n        continue;\n      }\n      if (sawWord && /[!?.]/.test(next)) return Pos(line, ch + (dir > 0 ? 1 : 0));\n      if (!sawWord) sawWord = /\\w/.test(next);\n      ch += dir;\n    }\n  }\n\n  function byExpr(cm, pos, dir) {\n    var wrap;\n    if (cm.findMatchingBracket && (wrap = cm.findMatchingBracket(pos, {strict: true}))\n        && wrap.match && (wrap.forward ? 1 : -1) == dir)\n      return dir > 0 ? Pos(wrap.to.line, wrap.to.ch + 1) : wrap.to;\n\n    for (var first = true;; first = false) {\n      var token = cm.getTokenAt(pos);\n      var after = Pos(pos.line, dir < 0 ? token.start : token.end);\n      if (first && dir > 0 && token.end == pos.ch || !/\\w/.test(token.string)) {\n        var newPos = cm.findPosH(after, dir, \"char\");\n        if (posEq(after, newPos)) return pos;\n        else pos = newPos;\n      } else {\n        return after;\n      }\n    }\n  }\n\n  // Prefixes (only crudely supported)\n\n  function getPrefix(cm, precise) {\n    var digits = cm.state.emacsPrefix;\n    if (!digits) return precise ? null : 1;\n    clearPrefix(cm);\n    return digits == \"-\" ? -1 : Number(digits);\n  }\n\n  function repeated(cmd) {\n    var f = typeof cmd == \"string\" ? function(cm) { cm.execCommand(cmd); } : cmd;\n    return function(cm) {\n      var prefix = getPrefix(cm);\n      f(cm);\n      for (var i = 1; i < prefix; ++i) f(cm);\n    };\n  }\n\n  function findEnd(cm, pos, by, dir) {\n    var prefix = getPrefix(cm);\n    if (prefix < 0) { dir = -dir; prefix = -prefix; }\n    for (var i = 0; i < prefix; ++i) {\n      var newPos = by(cm, pos, dir);\n      if (posEq(newPos, pos)) break;\n      pos = newPos;\n    }\n    return pos;\n  }\n\n  function move(by, dir) {\n    var f = function(cm) {\n      cm.extendSelection(findEnd(cm, cm.getCursor(), by, dir));\n    };\n    f.motion = true;\n    return f;\n  }\n\n  function killTo(cm, by, dir, ring) {\n    var selections = cm.listSelections(), cursor;\n    var i = selections.length;\n    while (i--) {\n      cursor = selections[i].head;\n      _kill(cm, cursor, findEnd(cm, cursor, by, dir), ring);\n    }\n  }\n\n  function _killRegion(cm, ring) {\n    if (cm.somethingSelected()) {\n      var selections = cm.listSelections(), selection;\n      var i = selections.length;\n      while (i--) {\n        selection = selections[i];\n        _kill(cm, selection.anchor, selection.head, ring);\n      }\n      return true;\n    }\n  }\n\n  function addPrefix(cm, digit) {\n    if (cm.state.emacsPrefix) {\n      if (digit != \"-\") cm.state.emacsPrefix += digit;\n      return;\n    }\n    // Not active yet\n    cm.state.emacsPrefix = digit;\n    cm.on(\"keyHandled\", maybeClearPrefix);\n    cm.on(\"inputRead\", maybeDuplicateInput);\n  }\n\n  var prefixPreservingKeys = {\"Alt-G\": true, \"Ctrl-X\": true, \"Ctrl-Q\": true, \"Ctrl-U\": true};\n\n  function maybeClearPrefix(cm, arg) {\n    if (!cm.state.emacsPrefixMap && !prefixPreservingKeys.hasOwnProperty(arg))\n      clearPrefix(cm);\n  }\n\n  function clearPrefix(cm) {\n    cm.state.emacsPrefix = null;\n    cm.off(\"keyHandled\", maybeClearPrefix);\n    cm.off(\"inputRead\", maybeDuplicateInput);\n  }\n\n  function maybeDuplicateInput(cm, event) {\n    var dup = getPrefix(cm);\n    if (dup > 1 && event.origin == \"+input\") {\n      var one = event.text.join(\"\\n\"), txt = \"\";\n      for (var i = 1; i < dup; ++i) txt += one;\n      cm.replaceSelection(txt);\n    }\n  }\n\n  function maybeRemovePrefixMap(cm, arg) {\n    if (typeof arg == \"string\" && (/^\\d$/.test(arg) || arg == \"Ctrl-U\")) return;\n    cm.removeKeyMap(prefixMap);\n    cm.state.emacsPrefixMap = false;\n    cm.off(\"keyHandled\", maybeRemovePrefixMap);\n    cm.off(\"inputRead\", maybeRemovePrefixMap);\n  }\n\n  // Utilities\n\n  cmds.setMark = function (cm) {\n    cm.setCursor(cm.getCursor());\n    cm.setExtending(!cm.getExtending());\n    cm.on(\"change\", function() { cm.setExtending(false); });\n  }\n\n  function clearMark(cm) {\n    cm.setExtending(false);\n    cm.setCursor(cm.getCursor());\n  }\n\n  function makePrompt(msg) {\n    var fragment = document.createDocumentFragment();\n    var input = document.createElement(\"input\");\n    input.setAttribute(\"type\", \"text\");\n    input.style.width = \"10em\";\n    fragment.appendChild(document.createTextNode(msg + \": \"));\n    fragment.appendChild(input);\n    return fragment;\n  }\n\n  function getInput(cm, msg, f) {\n    if (cm.openDialog)\n      cm.openDialog(makePrompt(msg), f, {bottom: true});\n    else\n      f(prompt(msg, \"\"));\n  }\n\n  function operateOnWord(cm, op) {\n    var start = cm.getCursor(), end = cm.findPosH(start, 1, \"word\");\n    cm.replaceRange(op(cm.getRange(start, end)), start, end);\n    cm.setCursor(end);\n  }\n\n  function toEnclosingExpr(cm) {\n    var pos = cm.getCursor(), line = pos.line, ch = pos.ch;\n    var stack = [];\n    while (line >= cm.firstLine()) {\n      var text = cm.getLine(line);\n      for (var i = ch == null ? text.length : ch; i > 0;) {\n        var ch = text.charAt(--i);\n        if (ch == \")\")\n          stack.push(\"(\");\n        else if (ch == \"]\")\n          stack.push(\"[\");\n        else if (ch == \"}\")\n          stack.push(\"{\");\n        else if (/[\\(\\{\\[]/.test(ch) && (!stack.length || stack.pop() != ch))\n          return cm.extendSelection(Pos(line, i));\n      }\n      --line; ch = null;\n    }\n  }\n\n  // Commands. Names should match emacs function names (albeit in camelCase)\n  // except where emacs function names collide with code mirror core commands.\n\n  cmds.killRegion = function(cm) {\n    _kill(cm, cm.getCursor(\"start\"), cm.getCursor(\"end\"), true);\n  };\n\n  // Maps to emacs kill-line\n  cmds.killLineEmacs = repeated(function(cm) {\n    var start = cm.getCursor(), end = cm.clipPos(Pos(start.line));\n    var text = cm.getRange(start, end);\n    if (!/\\S/.test(text)) {\n      text += \"\\n\";\n      end = Pos(start.line + 1, 0);\n    }\n    _kill(cm, start, end, \"grow\", text);\n  });\n\n  cmds.killRingSave = function(cm) {\n    addToRing(cm.getSelection());\n    clearMark(cm);\n  };\n\n  cmds.yank = function(cm) {\n    var start = cm.getCursor();\n    cm.replaceRange(getFromRing(getPrefix(cm)), start, start, \"paste\");\n    cm.setSelection(start, cm.getCursor());\n  };\n\n  cmds.yankPop = function(cm) {\n    cm.replaceSelection(popFromRing(), \"around\", \"paste\");\n  };\n\n  cmds.forwardChar = move(byChar, 1);\n\n  cmds.backwardChar = move(byChar, -1)\n\n  cmds.deleteChar = function(cm) { killTo(cm, byChar, 1, false); };\n\n  cmds.deleteForwardChar = function(cm) {\n    _killRegion(cm, false) || killTo(cm, byChar, 1, false);\n  };\n\n  cmds.deleteBackwardChar = function(cm) {\n    _killRegion(cm, false) || killTo(cm, byChar, -1, false);\n  };\n\n  cmds.forwardWord = move(byWord, 1);\n\n  cmds.backwardWord = move(byWord, -1);\n\n  cmds.killWord = function(cm) { killTo(cm, byWord, 1, \"grow\"); };\n\n  cmds.backwardKillWord = function(cm) { killTo(cm, byWord, -1, \"grow\"); };\n\n  cmds.nextLine = move(byLine, 1);\n\n  cmds.previousLine = move(byLine, -1);\n\n  cmds.scrollDownCommand = move(byPage, -1);\n\n  cmds.scrollUpCommand = move(byPage, 1);\n\n  cmds.backwardParagraph = move(byParagraph, -1);\n\n  cmds.forwardParagraph = move(byParagraph, 1);\n\n  cmds.backwardSentence = move(bySentence, -1);\n\n  cmds.forwardSentence = move(bySentence, 1);\n\n  cmds.killSentence = function(cm) { killTo(cm, bySentence, 1, \"grow\"); };\n\n  cmds.backwardKillSentence = function(cm) {\n    _kill(cm, cm.getCursor(), bySentence(cm, cm.getCursor(), 1), \"grow\");\n  };\n\n  cmds.killSexp = function(cm) { killTo(cm, byExpr, 1, \"grow\"); };\n\n  cmds.backwardKillSexp = function(cm) { killTo(cm, byExpr, -1, \"grow\"); };\n\n  cmds.forwardSexp = move(byExpr, 1);\n\n  cmds.backwardSexp = move(byExpr, -1);\n\n  cmds.markSexp = function(cm) {\n    var cursor = cm.getCursor();\n    cm.setSelection(findEnd(cm, cursor, byExpr, 1), cursor);\n  };\n\n  cmds.transposeSexps = function(cm) {\n    var leftStart = byExpr(cm, cm.getCursor(), -1);\n    var leftEnd = byExpr(cm, leftStart, 1);\n    var rightEnd = byExpr(cm, leftEnd, 1);\n    var rightStart = byExpr(cm, rightEnd, -1);\n    cm.replaceRange(cm.getRange(rightStart, rightEnd) +\n                    cm.getRange(leftEnd, rightStart) +\n                    cm.getRange(leftStart, leftEnd), leftStart, rightEnd);\n  };\n\n  cmds.backwardUpList = repeated(toEnclosingExpr);\n\n  cmds.justOneSpace = function(cm) {\n    var pos = cm.getCursor(), from = pos.ch;\n    var to = pos.ch, text = cm.getLine(pos.line);\n    while (from && /\\s/.test(text.charAt(from - 1))) --from;\n    while (to < text.length && /\\s/.test(text.charAt(to))) ++to;\n    cm.replaceRange(\" \", Pos(pos.line, from), Pos(pos.line, to));\n  };\n\n  cmds.openLine = repeated(function(cm) {\n    cm.replaceSelection(\"\\n\", \"start\");\n  });\n\n  // maps to emacs 'transpose-chars'\n  cmds.transposeCharsRepeatable = repeated(function(cm) {\n    cm.execCommand(\"transposeChars\");\n  });\n\n  cmds.capitalizeWord = repeated(function(cm) {\n    operateOnWord(cm, function(w) {\n      var letter = w.search(/\\w/);\n      if (letter == -1) return w;\n      return w.slice(0, letter) + w.charAt(letter).toUpperCase() +\n          w.slice(letter + 1).toLowerCase();\n    });\n  });\n\n  cmds.upcaseWord = repeated(function(cm) {\n    operateOnWord(cm, function(w) { return w.toUpperCase(); });\n  });\n\n  cmds.downcaseWord = repeated(function(cm) {\n    operateOnWord(cm, function(w) { return w.toLowerCase(); });\n  });\n\n  // maps to emacs 'undo'\n  cmds.undoRepeatable = repeated(\"undo\");\n\n  cmds.keyboardQuit = function(cm) {\n    cm.execCommand(\"clearSearch\");\n    clearMark(cm);\n  }\n\n  cmds.newline = repeated(function(cm) { cm.replaceSelection(\"\\n\", \"end\"); });\n\n  cmds.gotoLine = function(cm) {\n    var prefix = getPrefix(cm, true);\n    if (prefix != null && prefix > 0) return cm.setCursor(prefix - 1);\n\n    getInput(cm, \"Goto line\", function(str) {\n      var num;\n      if (str && !isNaN(num = Number(str)) && num == (num|0) && num > 0)\n      cm.setCursor(num - 1);\n    });\n  };\n\n  cmds.indentRigidly = function(cm) {\n    cm.indentSelection(getPrefix(cm, true) || cm.getOption(\"indentUnit\"));\n  };\n\n  cmds.exchangePointAndMark = function(cm) {\n    cm.setSelection(cm.getCursor(\"head\"), cm.getCursor(\"anchor\"));\n  };\n\n  cmds.quotedInsertTab = repeated(\"insertTab\");\n\n  cmds.universalArgument = function addPrefixMap(cm) {\n    cm.state.emacsPrefixMap = true;\n    cm.addKeyMap(prefixMap);\n    cm.on(\"keyHandled\", maybeRemovePrefixMap);\n    cm.on(\"inputRead\", maybeRemovePrefixMap);\n  };\n\n  CodeMirror.emacs = {kill: _kill, killRegion: _killRegion, repeated: repeated};\n\n  // Actual keymap\n  var keyMap = CodeMirror.keyMap.emacs = CodeMirror.normalizeKeyMap({\n    \"Ctrl-W\": \"killRegion\",\n    \"Ctrl-K\": \"killLineEmacs\",\n    \"Alt-W\": \"killRingSave\",\n    \"Ctrl-Y\": \"yank\",\n    \"Alt-Y\": \"yankPop\",\n    \"Ctrl-Space\": \"setMark\",\n    \"Ctrl-Shift-2\": \"setMark\",\n    \"Ctrl-F\": \"forwardChar\",\n    \"Ctrl-B\": \"backwardChar\",\n    \"Right\": \"forwardChar\",\n    \"Left\": \"backwardChar\",\n    \"Ctrl-D\": \"deleteChar\",\n    \"Delete\": \"deleteForwardChar\",\n    \"Ctrl-H\": \"deleteBackwardChar\",\n    \"Backspace\": \"deleteBackwardChar\",\n    \"Alt-F\": \"forwardWord\",\n    \"Alt-B\": \"backwardWord\",\n    \"Alt-Right\": \"forwardWord\",\n    \"Alt-Left\": \"backwardWord\",\n    \"Alt-D\": \"killWord\",\n    \"Alt-Backspace\": \"backwardKillWord\",\n    \"Ctrl-N\": \"nextLine\",\n    \"Ctrl-P\": \"previousLine\",\n    \"Down\": \"nextLine\",\n    \"Up\": \"previousLine\",\n    \"Ctrl-A\": \"goLineStart\",\n    \"Ctrl-E\": \"goLineEnd\",\n    \"End\": \"goLineEnd\",\n    \"Home\": \"goLineStart\",\n    \"Alt-V\": \"scrollDownCommand\",\n    \"Ctrl-V\": \"scrollUpCommand\",\n    \"PageUp\": \"scrollDownCommand\",\n    \"PageDown\": \"scrollUpCommand\",\n    \"Ctrl-Up\": \"backwardParagraph\",\n    \"Ctrl-Down\": \"forwardParagraph\",\n    \"Alt-{\": \"backwardParagraph\",\n    \"Alt-}\": \"forwardParagraph\",\n    \"Alt-A\": \"backwardSentence\",\n    \"Alt-E\": \"forwardSentence\",\n    \"Alt-K\": \"killSentence\",\n    \"Ctrl-X Delete\": \"backwardKillSentence\",\n    \"Ctrl-Alt-K\": \"killSexp\",\n    \"Ctrl-Alt-Backspace\": \"backwardKillSexp\",\n    \"Ctrl-Alt-F\": \"forwardSexp\",\n    \"Ctrl-Alt-B\": \"backwardSexp\",\n    \"Shift-Ctrl-Alt-2\": \"markSexp\",\n    \"Ctrl-Alt-T\": \"transposeSexps\",\n    \"Ctrl-Alt-U\": \"backwardUpList\",\n    \"Alt-Space\": \"justOneSpace\",\n    \"Ctrl-O\": \"openLine\",\n    \"Ctrl-T\": \"transposeCharsRepeatable\",\n    \"Alt-C\": \"capitalizeWord\",\n    \"Alt-U\": \"upcaseWord\",\n    \"Alt-L\": \"downcaseWord\",\n    \"Alt-;\": \"toggleComment\",\n    \"Ctrl-/\": \"undoRepeatable\",\n    \"Shift-Ctrl--\": \"undoRepeatable\",\n    \"Ctrl-Z\": \"undoRepeatable\",\n    \"Cmd-Z\": \"undoRepeatable\",\n    \"Ctrl-X U\": \"undoRepeatable\",\n    \"Shift-Ctrl-Z\": \"redo\",\n    \"Shift-Alt-,\": \"goDocStart\",\n    \"Shift-Alt-.\": \"goDocEnd\",\n    \"Ctrl-S\": \"findPersistentNext\",\n    \"Ctrl-R\": \"findPersistentPrev\",\n    \"Ctrl-G\": \"keyboardQuit\",\n    \"Shift-Alt-5\": \"replace\",\n    \"Alt-/\": \"autocomplete\",\n    \"Enter\": \"newlineAndIndent\",\n    \"Ctrl-J\": \"newline\",\n    \"Tab\": \"indentAuto\",\n    \"Alt-G G\": \"gotoLine\",\n    \"Ctrl-X Tab\": \"indentRigidly\",\n    \"Ctrl-X Ctrl-X\": \"exchangePointAndMark\",\n    \"Ctrl-X Ctrl-S\": \"save\",\n    \"Ctrl-X Ctrl-W\": \"save\",\n    \"Ctrl-X S\": \"saveAll\",\n    \"Ctrl-X F\": \"open\",\n    \"Ctrl-X K\": \"close\",\n    \"Ctrl-X H\": \"selectAll\",\n    \"Ctrl-Q Tab\": \"quotedInsertTab\",\n    \"Ctrl-U\": \"universalArgument\",\n    \"fallthrough\": \"default\"\n  });\n\n  var prefixMap = {\"Ctrl-G\": clearPrefix};\n  function regPrefix(d) {\n    prefixMap[d] = function(cm) { addPrefix(cm, d); };\n    keyMap[\"Ctrl-\" + d] = function(cm) { addPrefix(cm, d); };\n    prefixPreservingKeys[\"Ctrl-\" + d] = true;\n  }\n  for (var i = 0; i < 10; ++i) regPrefix(String(i));\n  regPrefix(\"-\");\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n// A rough approximation of Sublime Text's keybindings\n// Depends on addon/search/searchcursor.js and optionally addon/dialog/dialogs.js\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../lib/codemirror\"), require(\"../addon/search/searchcursor\"), require(\"../addon/edit/matchbrackets\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\", \"../addon/search/searchcursor\", \"../addon/edit/matchbrackets\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var cmds = CodeMirror.commands;\n  var Pos = CodeMirror.Pos;\n\n  // This is not exactly Sublime's algorithm. I couldn't make heads or tails of that.\n  function findPosSubword(doc, start, dir) {\n    if (dir < 0 && start.ch == 0) return doc.clipPos(Pos(start.line - 1));\n    var line = doc.getLine(start.line);\n    if (dir > 0 && start.ch >= line.length) return doc.clipPos(Pos(start.line + 1, 0));\n    var state = \"start\", type, startPos = start.ch;\n    for (var pos = startPos, e = dir < 0 ? 0 : line.length, i = 0; pos != e; pos += dir, i++) {\n      var next = line.charAt(dir < 0 ? pos - 1 : pos);\n      var cat = next != \"_\" && CodeMirror.isWordChar(next) ? \"w\" : \"o\";\n      if (cat == \"w\" && next.toUpperCase() == next) cat = \"W\";\n      if (state == \"start\") {\n        if (cat != \"o\") { state = \"in\"; type = cat; }\n        else startPos = pos + dir\n      } else if (state == \"in\") {\n        if (type != cat) {\n          if (type == \"w\" && cat == \"W\" && dir < 0) pos--;\n          if (type == \"W\" && cat == \"w\" && dir > 0) { // From uppercase to lowercase\n            if (pos == startPos + 1) { type = \"w\"; continue; }\n            else pos--;\n          }\n          break;\n        }\n      }\n    }\n    return Pos(start.line, pos);\n  }\n\n  function moveSubword(cm, dir) {\n    cm.extendSelectionsBy(function(range) {\n      if (cm.display.shift || cm.doc.extend || range.empty())\n        return findPosSubword(cm.doc, range.head, dir);\n      else\n        return dir < 0 ? range.from() : range.to();\n    });\n  }\n\n  cmds.goSubwordLeft = function(cm) { moveSubword(cm, -1); };\n  cmds.goSubwordRight = function(cm) { moveSubword(cm, 1); };\n\n  cmds.scrollLineUp = function(cm) {\n    var info = cm.getScrollInfo();\n    if (!cm.somethingSelected()) {\n      var visibleBottomLine = cm.lineAtHeight(info.top + info.clientHeight, \"local\");\n      if (cm.getCursor().line >= visibleBottomLine)\n        cm.execCommand(\"goLineUp\");\n    }\n    cm.scrollTo(null, info.top - cm.defaultTextHeight());\n  };\n  cmds.scrollLineDown = function(cm) {\n    var info = cm.getScrollInfo();\n    if (!cm.somethingSelected()) {\n      var visibleTopLine = cm.lineAtHeight(info.top, \"local\")+1;\n      if (cm.getCursor().line <= visibleTopLine)\n        cm.execCommand(\"goLineDown\");\n    }\n    cm.scrollTo(null, info.top + cm.defaultTextHeight());\n  };\n\n  cmds.splitSelectionByLine = function(cm) {\n    var ranges = cm.listSelections(), lineRanges = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var from = ranges[i].from(), to = ranges[i].to();\n      for (var line = from.line; line <= to.line; ++line)\n        if (!(to.line > from.line && line == to.line && to.ch == 0))\n          lineRanges.push({anchor: line == from.line ? from : Pos(line, 0),\n                           head: line == to.line ? to : Pos(line)});\n    }\n    cm.setSelections(lineRanges, 0);\n  };\n\n  cmds.singleSelectionTop = function(cm) {\n    var range = cm.listSelections()[0];\n    cm.setSelection(range.anchor, range.head, {scroll: false});\n  };\n\n  cmds.selectLine = function(cm) {\n    var ranges = cm.listSelections(), extended = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      extended.push({anchor: Pos(range.from().line, 0),\n                     head: Pos(range.to().line + 1, 0)});\n    }\n    cm.setSelections(extended);\n  };\n\n  function insertLine(cm, above) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    cm.operation(function() {\n      var len = cm.listSelections().length, newSelection = [], last = -1;\n      for (var i = 0; i < len; i++) {\n        var head = cm.listSelections()[i].head;\n        if (head.line <= last) continue;\n        var at = Pos(head.line + (above ? 0 : 1), 0);\n        cm.replaceRange(\"\\n\", at, null, \"+insertLine\");\n        cm.indentLine(at.line, null, true);\n        newSelection.push({head: at, anchor: at});\n        last = head.line + 1;\n      }\n      cm.setSelections(newSelection);\n    });\n    cm.execCommand(\"indentAuto\");\n  }\n\n  cmds.insertLineAfter = function(cm) { return insertLine(cm, false); };\n\n  cmds.insertLineBefore = function(cm) { return insertLine(cm, true); };\n\n  function wordAt(cm, pos) {\n    var start = pos.ch, end = start, line = cm.getLine(pos.line);\n    while (start && CodeMirror.isWordChar(line.charAt(start - 1))) --start;\n    while (end < line.length && CodeMirror.isWordChar(line.charAt(end))) ++end;\n    return {from: Pos(pos.line, start), to: Pos(pos.line, end), word: line.slice(start, end)};\n  }\n\n  cmds.selectNextOccurrence = function(cm) {\n    var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n    var fullWord = cm.state.sublimeFindFullWord == cm.doc.sel;\n    if (CodeMirror.cmpPos(from, to) == 0) {\n      var word = wordAt(cm, from);\n      if (!word.word) return;\n      cm.setSelection(word.from, word.to);\n      fullWord = true;\n    } else {\n      var text = cm.getRange(from, to);\n      var query = fullWord ? new RegExp(\"\\\\b\" + text + \"\\\\b\") : text;\n      var cur = cm.getSearchCursor(query, to);\n      var found = cur.findNext();\n      if (!found) {\n        cur = cm.getSearchCursor(query, Pos(cm.firstLine(), 0));\n        found = cur.findNext();\n      }\n      if (!found || isSelectedRange(cm.listSelections(), cur.from(), cur.to())) return\n      cm.addSelection(cur.from(), cur.to());\n    }\n    if (fullWord)\n      cm.state.sublimeFindFullWord = cm.doc.sel;\n  };\n\n  cmds.skipAndSelectNextOccurrence = function(cm) {\n    var prevAnchor = cm.getCursor(\"anchor\"), prevHead = cm.getCursor(\"head\");\n    cmds.selectNextOccurrence(cm);\n    if (CodeMirror.cmpPos(prevAnchor, prevHead) != 0) {\n      cm.doc.setSelections(cm.doc.listSelections()\n          .filter(function (sel) {\n            return sel.anchor != prevAnchor || sel.head != prevHead;\n          }));\n    }\n  }\n\n  function addCursorToSelection(cm, dir) {\n    var ranges = cm.listSelections(), newRanges = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      var newAnchor = cm.findPosV(\n          range.anchor, dir, \"line\", range.anchor.goalColumn);\n      var newHead = cm.findPosV(\n          range.head, dir, \"line\", range.head.goalColumn);\n      newAnchor.goalColumn = range.anchor.goalColumn != null ?\n          range.anchor.goalColumn : cm.cursorCoords(range.anchor, \"div\").left;\n      newHead.goalColumn = range.head.goalColumn != null ?\n          range.head.goalColumn : cm.cursorCoords(range.head, \"div\").left;\n      var newRange = {anchor: newAnchor, head: newHead};\n      newRanges.push(range);\n      newRanges.push(newRange);\n    }\n    cm.setSelections(newRanges);\n  }\n  cmds.addCursorToPrevLine = function(cm) { addCursorToSelection(cm, -1); };\n  cmds.addCursorToNextLine = function(cm) { addCursorToSelection(cm, 1); };\n\n  function isSelectedRange(ranges, from, to) {\n    for (var i = 0; i < ranges.length; i++)\n      if (CodeMirror.cmpPos(ranges[i].from(), from) == 0 &&\n          CodeMirror.cmpPos(ranges[i].to(), to) == 0) return true\n    return false\n  }\n\n  var mirror = \"(){}[]\";\n  function selectBetweenBrackets(cm) {\n    var ranges = cm.listSelections(), newRanges = []\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], pos = range.head, opening = cm.scanForBracket(pos, -1);\n      if (!opening) return false;\n      for (;;) {\n        var closing = cm.scanForBracket(pos, 1);\n        if (!closing) return false;\n        if (closing.ch == mirror.charAt(mirror.indexOf(opening.ch) + 1)) {\n          var startPos = Pos(opening.pos.line, opening.pos.ch + 1);\n          if (CodeMirror.cmpPos(startPos, range.from()) == 0 &&\n              CodeMirror.cmpPos(closing.pos, range.to()) == 0) {\n            opening = cm.scanForBracket(opening.pos, -1);\n            if (!opening) return false;\n          } else {\n            newRanges.push({anchor: startPos, head: closing.pos});\n            break;\n          }\n        }\n        pos = Pos(closing.pos.line, closing.pos.ch + 1);\n      }\n    }\n    cm.setSelections(newRanges);\n    return true;\n  }\n\n  cmds.selectScope = function(cm) {\n    selectBetweenBrackets(cm) || cm.execCommand(\"selectAll\");\n  };\n  cmds.selectBetweenBrackets = function(cm) {\n    if (!selectBetweenBrackets(cm)) return CodeMirror.Pass;\n  };\n\n  function puncType(type) {\n    return !type ? null : /\\bpunctuation\\b/.test(type) ? type : undefined\n  }\n\n  cmds.goToBracket = function(cm) {\n    cm.extendSelectionsBy(function(range) {\n      var next = cm.scanForBracket(range.head, 1, puncType(cm.getTokenTypeAt(range.head)));\n      if (next && CodeMirror.cmpPos(next.pos, range.head) != 0) return next.pos;\n      var prev = cm.scanForBracket(range.head, -1, puncType(cm.getTokenTypeAt(Pos(range.head.line, range.head.ch + 1))));\n      return prev && Pos(prev.pos.line, prev.pos.ch + 1) || range.head;\n    });\n  };\n\n  cmds.swapLineUp = function(cm) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    var ranges = cm.listSelections(), linesToMove = [], at = cm.firstLine() - 1, newSels = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], from = range.from().line - 1, to = range.to().line;\n      newSels.push({anchor: Pos(range.anchor.line - 1, range.anchor.ch),\n                    head: Pos(range.head.line - 1, range.head.ch)});\n      if (range.to().ch == 0 && !range.empty()) --to;\n      if (from > at) linesToMove.push(from, to);\n      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;\n      at = to;\n    }\n    cm.operation(function() {\n      for (var i = 0; i < linesToMove.length; i += 2) {\n        var from = linesToMove[i], to = linesToMove[i + 1];\n        var line = cm.getLine(from);\n        cm.replaceRange(\"\", Pos(from, 0), Pos(from + 1, 0), \"+swapLine\");\n        if (to > cm.lastLine())\n          cm.replaceRange(\"\\n\" + line, Pos(cm.lastLine()), null, \"+swapLine\");\n        else\n          cm.replaceRange(line + \"\\n\", Pos(to, 0), null, \"+swapLine\");\n      }\n      cm.setSelections(newSels);\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds.swapLineDown = function(cm) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    var ranges = cm.listSelections(), linesToMove = [], at = cm.lastLine() + 1;\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var range = ranges[i], from = range.to().line + 1, to = range.from().line;\n      if (range.to().ch == 0 && !range.empty()) from--;\n      if (from < at) linesToMove.push(from, to);\n      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;\n      at = to;\n    }\n    cm.operation(function() {\n      for (var i = linesToMove.length - 2; i >= 0; i -= 2) {\n        var from = linesToMove[i], to = linesToMove[i + 1];\n        var line = cm.getLine(from);\n        if (from == cm.lastLine())\n          cm.replaceRange(\"\", Pos(from - 1), Pos(from), \"+swapLine\");\n        else\n          cm.replaceRange(\"\", Pos(from, 0), Pos(from + 1, 0), \"+swapLine\");\n        cm.replaceRange(line + \"\\n\", Pos(to, 0), null, \"+swapLine\");\n      }\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds.toggleCommentIndented = function(cm) {\n    cm.toggleComment({ indent: true });\n  }\n\n  cmds.joinLines = function(cm) {\n    var ranges = cm.listSelections(), joined = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], from = range.from();\n      var start = from.line, end = range.to().line;\n      while (i < ranges.length - 1 && ranges[i + 1].from().line == end)\n        end = ranges[++i].to().line;\n      joined.push({start: start, end: end, anchor: !range.empty() && from});\n    }\n    cm.operation(function() {\n      var offset = 0, ranges = [];\n      for (var i = 0; i < joined.length; i++) {\n        var obj = joined[i];\n        var anchor = obj.anchor && Pos(obj.anchor.line - offset, obj.anchor.ch), head;\n        for (var line = obj.start; line <= obj.end; line++) {\n          var actual = line - offset;\n          if (line == obj.end) head = Pos(actual, cm.getLine(actual).length + 1);\n          if (actual < cm.lastLine()) {\n            cm.replaceRange(\" \", Pos(actual), Pos(actual + 1, /^\\s*/.exec(cm.getLine(actual + 1))[0].length));\n            ++offset;\n          }\n        }\n        ranges.push({anchor: anchor || head, head: head});\n      }\n      cm.setSelections(ranges, 0);\n    });\n  };\n\n  cmds.duplicateLine = function(cm) {\n    cm.operation(function() {\n      var rangeCount = cm.listSelections().length;\n      for (var i = 0; i < rangeCount; i++) {\n        var range = cm.listSelections()[i];\n        if (range.empty())\n          cm.replaceRange(cm.getLine(range.head.line) + \"\\n\", Pos(range.head.line, 0));\n        else\n          cm.replaceRange(cm.getRange(range.from(), range.to()), range.from());\n      }\n      cm.scrollIntoView();\n    });\n  };\n\n\n  function sortLines(cm, caseSensitive, direction) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    var ranges = cm.listSelections(), toSort = [], selected;\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      if (range.empty()) continue;\n      var from = range.from().line, to = range.to().line;\n      while (i < ranges.length - 1 && ranges[i + 1].from().line == to)\n        to = ranges[++i].to().line;\n      if (!ranges[i].to().ch) to--;\n      toSort.push(from, to);\n    }\n    if (toSort.length) selected = true;\n    else toSort.push(cm.firstLine(), cm.lastLine());\n\n    cm.operation(function() {\n      var ranges = [];\n      for (var i = 0; i < toSort.length; i += 2) {\n        var from = toSort[i], to = toSort[i + 1];\n        var start = Pos(from, 0), end = Pos(to);\n        var lines = cm.getRange(start, end, false);\n        if (caseSensitive)\n          lines.sort(function(a, b) { return a < b ? -direction : a == b ? 0 : direction; });\n        else\n          lines.sort(function(a, b) {\n            var au = a.toUpperCase(), bu = b.toUpperCase();\n            if (au != bu) { a = au; b = bu; }\n            return a < b ? -direction : a == b ? 0 : direction;\n          });\n        cm.replaceRange(lines, start, end);\n        if (selected) ranges.push({anchor: start, head: Pos(to + 1, 0)});\n      }\n      if (selected) cm.setSelections(ranges, 0);\n    });\n  }\n\n  cmds.sortLines = function(cm) { sortLines(cm, true, 1); };\n  cmds.reverseSortLines = function(cm) { sortLines(cm, true, -1); };\n  cmds.sortLinesInsensitive = function(cm) { sortLines(cm, false, 1); };\n  cmds.reverseSortLinesInsensitive = function(cm) { sortLines(cm, false, -1); };\n\n  cmds.nextBookmark = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) while (marks.length) {\n      var current = marks.shift();\n      var found = current.find();\n      if (found) {\n        marks.push(current);\n        return cm.setSelection(found.from, found.to);\n      }\n    }\n  };\n\n  cmds.prevBookmark = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) while (marks.length) {\n      marks.unshift(marks.pop());\n      var found = marks[marks.length - 1].find();\n      if (!found)\n        marks.pop();\n      else\n        return cm.setSelection(found.from, found.to);\n    }\n  };\n\n  cmds.toggleBookmark = function(cm) {\n    var ranges = cm.listSelections();\n    var marks = cm.state.sublimeBookmarks || (cm.state.sublimeBookmarks = []);\n    for (var i = 0; i < ranges.length; i++) {\n      var from = ranges[i].from(), to = ranges[i].to();\n      var found = ranges[i].empty() ? cm.findMarksAt(from) : cm.findMarks(from, to);\n      for (var j = 0; j < found.length; j++) {\n        if (found[j].sublimeBookmark) {\n          found[j].clear();\n          for (var k = 0; k < marks.length; k++)\n            if (marks[k] == found[j])\n              marks.splice(k--, 1);\n          break;\n        }\n      }\n      if (j == found.length)\n        marks.push(cm.markText(from, to, {sublimeBookmark: true, clearWhenEmpty: false}));\n    }\n  };\n\n  cmds.clearBookmarks = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) for (var i = 0; i < marks.length; i++) marks[i].clear();\n    marks.length = 0;\n  };\n\n  cmds.selectBookmarks = function(cm) {\n    var marks = cm.state.sublimeBookmarks, ranges = [];\n    if (marks) for (var i = 0; i < marks.length; i++) {\n      var found = marks[i].find();\n      if (!found)\n        marks.splice(i--, 0);\n      else\n        ranges.push({anchor: found.from, head: found.to});\n    }\n    if (ranges.length)\n      cm.setSelections(ranges, 0);\n  };\n\n  function modifyWordOrSelection(cm, mod) {\n    cm.operation(function() {\n      var ranges = cm.listSelections(), indices = [], replacements = [];\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (range.empty()) { indices.push(i); replacements.push(\"\"); }\n        else replacements.push(mod(cm.getRange(range.from(), range.to())));\n      }\n      cm.replaceSelections(replacements, \"around\", \"case\");\n      for (var i = indices.length - 1, at; i >= 0; i--) {\n        var range = ranges[indices[i]];\n        if (at && CodeMirror.cmpPos(range.head, at) > 0) continue;\n        var word = wordAt(cm, range.head);\n        at = word.from;\n        cm.replaceRange(mod(word.word), word.from, word.to);\n      }\n    });\n  }\n\n  cmds.smartBackspace = function(cm) {\n    if (cm.somethingSelected()) return CodeMirror.Pass;\n\n    cm.operation(function() {\n      var cursors = cm.listSelections();\n      var indentUnit = cm.getOption(\"indentUnit\");\n\n      for (var i = cursors.length - 1; i >= 0; i--) {\n        var cursor = cursors[i].head;\n        var toStartOfLine = cm.getRange({line: cursor.line, ch: 0}, cursor);\n        var column = CodeMirror.countColumn(toStartOfLine, null, cm.getOption(\"tabSize\"));\n\n        // Delete by one character by default\n        var deletePos = cm.findPosH(cursor, -1, \"char\", false);\n\n        if (toStartOfLine && !/\\S/.test(toStartOfLine) && column % indentUnit == 0) {\n          var prevIndent = new Pos(cursor.line,\n            CodeMirror.findColumn(toStartOfLine, column - indentUnit, indentUnit));\n\n          // Smart delete only if we found a valid prevIndent location\n          if (prevIndent.ch != cursor.ch) deletePos = prevIndent;\n        }\n\n        cm.replaceRange(\"\", deletePos, cursor, \"+delete\");\n      }\n    });\n  };\n\n  cmds.delLineRight = function(cm) {\n    cm.operation(function() {\n      var ranges = cm.listSelections();\n      for (var i = ranges.length - 1; i >= 0; i--)\n        cm.replaceRange(\"\", ranges[i].anchor, Pos(ranges[i].to().line), \"+delete\");\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds.upcaseAtCursor = function(cm) {\n    modifyWordOrSelection(cm, function(str) { return str.toUpperCase(); });\n  };\n  cmds.downcaseAtCursor = function(cm) {\n    modifyWordOrSelection(cm, function(str) { return str.toLowerCase(); });\n  };\n\n  cmds.setSublimeMark = function(cm) {\n    if (cm.state.sublimeMark) cm.state.sublimeMark.clear();\n    cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n  };\n  cmds.selectToSublimeMark = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) cm.setSelection(cm.getCursor(), found);\n  };\n  cmds.deleteToSublimeMark = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) {\n      var from = cm.getCursor(), to = found;\n      if (CodeMirror.cmpPos(from, to) > 0) { var tmp = to; to = from; from = tmp; }\n      cm.state.sublimeKilled = cm.getRange(from, to);\n      cm.replaceRange(\"\", from, to);\n    }\n  };\n  cmds.swapWithSublimeMark = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) {\n      cm.state.sublimeMark.clear();\n      cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n      cm.setCursor(found);\n    }\n  };\n  cmds.sublimeYank = function(cm) {\n    if (cm.state.sublimeKilled != null)\n      cm.replaceSelection(cm.state.sublimeKilled, null, \"paste\");\n  };\n\n  cmds.showInCenter = function(cm) {\n    var pos = cm.cursorCoords(null, \"local\");\n    cm.scrollTo(null, (pos.top + pos.bottom) / 2 - cm.getScrollInfo().clientHeight / 2);\n  };\n\n  function getTarget(cm) {\n    var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n    if (CodeMirror.cmpPos(from, to) == 0) {\n      var word = wordAt(cm, from);\n      if (!word.word) return;\n      from = word.from;\n      to = word.to;\n    }\n    return {from: from, to: to, query: cm.getRange(from, to), word: word};\n  }\n\n  function findAndGoTo(cm, forward) {\n    var target = getTarget(cm);\n    if (!target) return;\n    var query = target.query;\n    var cur = cm.getSearchCursor(query, forward ? target.to : target.from);\n\n    if (forward ? cur.findNext() : cur.findPrevious()) {\n      cm.setSelection(cur.from(), cur.to());\n    } else {\n      cur = cm.getSearchCursor(query, forward ? Pos(cm.firstLine(), 0)\n                                              : cm.clipPos(Pos(cm.lastLine())));\n      if (forward ? cur.findNext() : cur.findPrevious())\n        cm.setSelection(cur.from(), cur.to());\n      else if (target.word)\n        cm.setSelection(target.from, target.to);\n    }\n  };\n  cmds.findUnder = function(cm) { findAndGoTo(cm, true); };\n  cmds.findUnderPrevious = function(cm) { findAndGoTo(cm,false); };\n  cmds.findAllUnder = function(cm) {\n    var target = getTarget(cm);\n    if (!target) return;\n    var cur = cm.getSearchCursor(target.query);\n    var matches = [];\n    var primaryIndex = -1;\n    while (cur.findNext()) {\n      matches.push({anchor: cur.from(), head: cur.to()});\n      if (cur.from().line <= target.from.line && cur.from().ch <= target.from.ch)\n        primaryIndex++;\n    }\n    cm.setSelections(matches, primaryIndex);\n  };\n\n\n  var keyMap = CodeMirror.keyMap;\n  keyMap.macSublime = {\n    \"Cmd-Left\": \"goLineStartSmart\",\n    \"Shift-Tab\": \"indentLess\",\n    \"Shift-Ctrl-K\": \"deleteLine\",\n    \"Alt-Q\": \"wrapLines\",\n    \"Ctrl-Left\": \"goSubwordLeft\",\n    \"Ctrl-Right\": \"goSubwordRight\",\n    \"Ctrl-Alt-Up\": \"scrollLineUp\",\n    \"Ctrl-Alt-Down\": \"scrollLineDown\",\n    \"Cmd-L\": \"selectLine\",\n    \"Shift-Cmd-L\": \"splitSelectionByLine\",\n    \"Esc\": \"singleSelectionTop\",\n    \"Cmd-Enter\": \"insertLineAfter\",\n    \"Shift-Cmd-Enter\": \"insertLineBefore\",\n    \"Cmd-D\": \"selectNextOccurrence\",\n    \"Shift-Cmd-Space\": \"selectScope\",\n    \"Shift-Cmd-M\": \"selectBetweenBrackets\",\n    \"Cmd-M\": \"goToBracket\",\n    \"Cmd-Ctrl-Up\": \"swapLineUp\",\n    \"Cmd-Ctrl-Down\": \"swapLineDown\",\n    \"Cmd-/\": \"toggleCommentIndented\",\n    \"Cmd-J\": \"joinLines\",\n    \"Shift-Cmd-D\": \"duplicateLine\",\n    \"F5\": \"sortLines\",\n    \"Shift-F5\": \"reverseSortLines\",\n    \"Cmd-F5\": \"sortLinesInsensitive\",\n    \"Shift-Cmd-F5\": \"reverseSortLinesInsensitive\",\n    \"F2\": \"nextBookmark\",\n    \"Shift-F2\": \"prevBookmark\",\n    \"Cmd-F2\": \"toggleBookmark\",\n    \"Shift-Cmd-F2\": \"clearBookmarks\",\n    \"Alt-F2\": \"selectBookmarks\",\n    \"Backspace\": \"smartBackspace\",\n    \"Cmd-K Cmd-D\": \"skipAndSelectNextOccurrence\",\n    \"Cmd-K Cmd-K\": \"delLineRight\",\n    \"Cmd-K Cmd-U\": \"upcaseAtCursor\",\n    \"Cmd-K Cmd-L\": \"downcaseAtCursor\",\n    \"Cmd-K Cmd-Space\": \"setSublimeMark\",\n    \"Cmd-K Cmd-A\": \"selectToSublimeMark\",\n    \"Cmd-K Cmd-W\": \"deleteToSublimeMark\",\n    \"Cmd-K Cmd-X\": \"swapWithSublimeMark\",\n    \"Cmd-K Cmd-Y\": \"sublimeYank\",\n    \"Cmd-K Cmd-C\": \"showInCenter\",\n    \"Cmd-K Cmd-G\": \"clearBookmarks\",\n    \"Cmd-K Cmd-Backspace\": \"delLineLeft\",\n    \"Cmd-K Cmd-1\": \"foldAll\",\n    \"Cmd-K Cmd-0\": \"unfoldAll\",\n    \"Cmd-K Cmd-J\": \"unfoldAll\",\n    \"Ctrl-Shift-Up\": \"addCursorToPrevLine\",\n    \"Ctrl-Shift-Down\": \"addCursorToNextLine\",\n    \"Cmd-F3\": \"findUnder\",\n    \"Shift-Cmd-F3\": \"findUnderPrevious\",\n    \"Alt-F3\": \"findAllUnder\",\n    \"Shift-Cmd-[\": \"fold\",\n    \"Shift-Cmd-]\": \"unfold\",\n    \"Cmd-I\": \"findIncremental\",\n    \"Shift-Cmd-I\": \"findIncrementalReverse\",\n    \"Cmd-H\": \"replace\",\n    \"F3\": \"findNext\",\n    \"Shift-F3\": \"findPrev\",\n    \"fallthrough\": \"macDefault\"\n  };\n  CodeMirror.normalizeKeyMap(keyMap.macSublime);\n\n  keyMap.pcSublime = {\n    \"Shift-Tab\": \"indentLess\",\n    \"Shift-Ctrl-K\": \"deleteLine\",\n    \"Alt-Q\": \"wrapLines\",\n    \"Ctrl-T\": \"transposeChars\",\n    \"Alt-Left\": \"goSubwordLeft\",\n    \"Alt-Right\": \"goSubwordRight\",\n    \"Ctrl-Up\": \"scrollLineUp\",\n    \"Ctrl-Down\": \"scrollLineDown\",\n    \"Ctrl-L\": \"selectLine\",\n    \"Shift-Ctrl-L\": \"splitSelectionByLine\",\n    \"Esc\": \"singleSelectionTop\",\n    \"Ctrl-Enter\": \"insertLineAfter\",\n    \"Shift-Ctrl-Enter\": \"insertLineBefore\",\n    \"Ctrl-D\": \"selectNextOccurrence\",\n    \"Shift-Ctrl-Space\": \"selectScope\",\n    \"Shift-Ctrl-M\": \"selectBetweenBrackets\",\n    \"Ctrl-M\": \"goToBracket\",\n    \"Shift-Ctrl-Up\": \"swapLineUp\",\n    \"Shift-Ctrl-Down\": \"swapLineDown\",\n    \"Ctrl-/\": \"toggleCommentIndented\",\n    \"Ctrl-J\": \"joinLines\",\n    \"Shift-Ctrl-D\": \"duplicateLine\",\n    \"F9\": \"sortLines\",\n    \"Shift-F9\": \"reverseSortLines\",\n    \"Ctrl-F9\": \"sortLinesInsensitive\",\n    \"Shift-Ctrl-F9\": \"reverseSortLinesInsensitive\",\n    \"F2\": \"nextBookmark\",\n    \"Shift-F2\": \"prevBookmark\",\n    \"Ctrl-F2\": \"toggleBookmark\",\n    \"Shift-Ctrl-F2\": \"clearBookmarks\",\n    \"Alt-F2\": \"selectBookmarks\",\n    \"Backspace\": \"smartBackspace\",\n    \"Ctrl-K Ctrl-D\": \"skipAndSelectNextOccurrence\",\n    \"Ctrl-K Ctrl-K\": \"delLineRight\",\n    \"Ctrl-K Ctrl-U\": \"upcaseAtCursor\",\n    \"Ctrl-K Ctrl-L\": \"downcaseAtCursor\",\n    \"Ctrl-K Ctrl-Space\": \"setSublimeMark\",\n    \"Ctrl-K Ctrl-A\": \"selectToSublimeMark\",\n    \"Ctrl-K Ctrl-W\": \"deleteToSublimeMark\",\n    \"Ctrl-K Ctrl-X\": \"swapWithSublimeMark\",\n    \"Ctrl-K Ctrl-Y\": \"sublimeYank\",\n    \"Ctrl-K Ctrl-C\": \"showInCenter\",\n    \"Ctrl-K Ctrl-G\": \"clearBookmarks\",\n    \"Ctrl-K Ctrl-Backspace\": \"delLineLeft\",\n    \"Ctrl-K Ctrl-1\": \"foldAll\",\n    \"Ctrl-K Ctrl-0\": \"unfoldAll\",\n    \"Ctrl-K Ctrl-J\": \"unfoldAll\",\n    \"Ctrl-Alt-Up\": \"addCursorToPrevLine\",\n    \"Ctrl-Alt-Down\": \"addCursorToNextLine\",\n    \"Ctrl-F3\": \"findUnder\",\n    \"Shift-Ctrl-F3\": \"findUnderPrevious\",\n    \"Alt-F3\": \"findAllUnder\",\n    \"Shift-Ctrl-[\": \"fold\",\n    \"Shift-Ctrl-]\": \"unfold\",\n    \"Ctrl-I\": \"findIncremental\",\n    \"Shift-Ctrl-I\": \"findIncrementalReverse\",\n    \"Ctrl-H\": \"replace\",\n    \"F3\": \"findNext\",\n    \"Shift-F3\": \"findPrev\",\n    \"fallthrough\": \"pcDefault\"\n  };\n  CodeMirror.normalizeKeyMap(keyMap.pcSublime);\n\n  var mac = keyMap.default == keyMap.macDefault;\n  keyMap.sublime = mac ? keyMap.macSublime : keyMap.pcSublime;\n});\n","(function(mod) {\n    if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n      mod(require(\"../lib/codemirror\"), require(\"../addon/search/searchcursor\"), require(\"../addon/dialog/dialog\"), require(\"../addon/edit/matchbrackets.js\"));\n    else if (typeof define == \"function\" && define.amd) // AMD\n      define([\"../lib/codemirror\", \"../addon/search/searchcursor\", \"../addon/dialog/dialog\", \"../addon/edit/matchbrackets\"], mod);\n    else // Plain browser env\n      mod(CodeMirror);\n  })(function(CodeMirror) {\n    'use strict';\n  // CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n/**\n * Supported keybindings:\n *   Too many to list. Refer to defaultKeymap below.\n *\n * Supported Ex commands:\n *   Refer to defaultExCommandMap below.\n *\n * Registers: unnamed, -, ., :, /, _, a-z, A-Z, 0-9\n *   (Does not respect the special case for number registers when delete\n *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )\n *   TODO: Implement the remaining registers.\n *\n * Marks: a-z, A-Z, and 0-9\n *   TODO: Implement the remaining special marks. They have more complex\n *       behavior.\n *\n * Events:\n *  'vim-mode-change' - raised on the editor anytime the current mode changes,\n *                      Event object: {mode: \"visual\", subMode: \"linewise\"}\n *\n * Code structure:\n *  1. Default keymap\n *  2. Variable declarations and short basic helpers\n *  3. Instance (External API) implementation\n *  4. Internal state tracking objects (input state, counter) implementation\n *     and instantiation\n *  5. Key handler (the main command dispatcher) implementation\n *  6. Motion, operator, and action implementations\n *  7. Helper functions for the key handler, motions, operators, and actions\n *  8. Set up Vim to work as a keymap for CodeMirror.\n *  9. Ex command implementations.\n */\n\nfunction initVim$1(CodeMirror) {\n\n  var Pos = CodeMirror.Pos;\n\n  function transformCursor(cm, range) {\n    var vim = cm.state.vim;\n    if (!vim || vim.insertMode) return range.head;\n    var head = vim.sel.head;\n    if (!head)  return range.head;\n\n    if (vim.visualBlock) {\n      if (range.head.line != head.line) {\n        return;\n      }\n    }\n    if (range.from() == range.anchor && !range.empty()) {\n      if (range.head.line == head.line && range.head.ch != head.ch)\n        return new Pos(range.head.line, range.head.ch - 1);\n    }\n\n    return range.head;\n  }\n\n  var defaultKeymap = [\n    // Key to key mapping. This goes first to make it possible to override\n    // existing mappings.\n    { keys: '<Left>', type: 'keyToKey', toKeys: 'h' },\n    { keys: '<Right>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<Up>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<Down>', type: 'keyToKey', toKeys: 'j' },\n    { keys: 'g<Up>', type: 'keyToKey', toKeys: 'gk' },\n    { keys: 'g<Down>', type: 'keyToKey', toKeys: 'gj' },\n    { keys: '<Space>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<BS>', type: 'keyToKey', toKeys: 'h', context: 'normal'},\n    { keys: '<Del>', type: 'keyToKey', toKeys: 'x', context: 'normal'},\n    { keys: '<C-Space>', type: 'keyToKey', toKeys: 'W' },\n    { keys: '<C-BS>', type: 'keyToKey', toKeys: 'B', context: 'normal' },\n    { keys: '<S-Space>', type: 'keyToKey', toKeys: 'w' },\n    { keys: '<S-BS>', type: 'keyToKey', toKeys: 'b', context: 'normal' },\n    { keys: '<C-n>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<C-p>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-Esc>', type: 'keyToKey', toKeys: '<Esc>' }, // ipad keyboard sends C-Esc instead of C-[\n    { keys: '<C-Esc>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: 's', type: 'keyToKey', toKeys: 'cl', context: 'normal' },\n    { keys: 's', type: 'keyToKey', toKeys: 'c', context: 'visual'},\n    { keys: 'S', type: 'keyToKey', toKeys: 'cc', context: 'normal' },\n    { keys: 'S', type: 'keyToKey', toKeys: 'VdO', context: 'visual' },\n    { keys: '<Home>', type: 'keyToKey', toKeys: '0' },\n    { keys: '<End>', type: 'keyToKey', toKeys: '$' },\n    { keys: '<PageUp>', type: 'keyToKey', toKeys: '<C-b>' },\n    { keys: '<PageDown>', type: 'keyToKey', toKeys: '<C-f>' },\n    { keys: '<CR>', type: 'keyToKey', toKeys: 'j^', context: 'normal' },\n    { keys: '<Ins>', type: 'keyToKey', toKeys: 'i', context: 'normal'},\n    { keys: '<Ins>', type: 'action', action: 'toggleOverwrite', context: 'insert' },\n    // Motions\n    { keys: 'H', type: 'motion', motion: 'moveToTopLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'M', type: 'motion', motion: 'moveToMiddleLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'L', type: 'motion', motion: 'moveToBottomLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'h', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: false }},\n    { keys: 'l', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: true }},\n    { keys: 'j', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, linewise: true }},\n    { keys: 'k', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, linewise: true }},\n    { keys: 'gj', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: true }},\n    { keys: 'gk', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: false }},\n    { keys: 'w', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false }},\n    { keys: 'W', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false, bigWord: true }},\n    { keys: 'e', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, inclusive: true }},\n    { keys: 'E', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: 'b', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }},\n    { keys: 'B', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false, bigWord: true }},\n    { keys: 'ge', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, inclusive: true }},\n    { keys: 'gE', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: '{', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: false, toJumplist: true }},\n    { keys: '}', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: true, toJumplist: true }},\n    { keys: '(', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: false }},\n    { keys: ')', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: true }},\n    { keys: '<C-f>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: true }},\n    { keys: '<C-b>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: false }},\n    { keys: '<C-d>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: true, explicitRepeat: true }},\n    { keys: '<C-u>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: false, explicitRepeat: true }},\n    { keys: 'gg', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: 'G', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true }},\n    {keys: \"g$\", type: \"motion\", motion: \"moveToEndOfDisplayLine\"},\n    {keys: \"g^\", type: \"motion\", motion: \"moveToStartOfDisplayLine\"},\n    {keys: \"g0\", type: \"motion\", motion: \"moveToStartOfDisplayLine\"},\n    { keys: '0', type: 'motion', motion: 'moveToStartOfLine' },\n    { keys: '^', type: 'motion', motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '+', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true }},\n    { keys: '-', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, toFirstChar:true }},\n    { keys: '_', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true, repeatOffset:-1 }},\n    { keys: '$', type: 'motion', motion: 'moveToEol', motionArgs: { inclusive: true }},\n    { keys: '%', type: 'motion', motion: 'moveToMatchedSymbol', motionArgs: { inclusive: true, toJumplist: true }},\n    { keys: 'f<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: true , inclusive: true }},\n    { keys: 'F<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: false }},\n    { keys: 't<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: true, inclusive: true }},\n    { keys: 'T<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: false }},\n    { keys: ';', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: true }},\n    { keys: ',', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: false }},\n    { keys: '\\'<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true, linewise: true}},\n    { keys: '`<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true}},\n    { keys: ']`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true } },\n    { keys: '[`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false } },\n    { keys: ']\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true, linewise: true } },\n    { keys: '[\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false, linewise: true } },\n    // the next two aren't motions but must come before more general motion declarations\n    { keys: ']p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true}},\n    { keys: '[p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true}},\n    { keys: ']<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: true, toJumplist: true}},\n    { keys: '[<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: false, toJumplist: true}},\n    { keys: '|', type: 'motion', motion: 'moveToColumn'},\n    { keys: 'o', type: 'motion', motion: 'moveToOtherHighlightedEnd', context:'visual'},\n    { keys: 'O', type: 'motion', motion: 'moveToOtherHighlightedEnd', motionArgs: {sameLine: true}, context:'visual'},\n    // Operators\n    { keys: 'd', type: 'operator', operator: 'delete' },\n    { keys: 'y', type: 'operator', operator: 'yank' },\n    { keys: 'c', type: 'operator', operator: 'change' },\n    { keys: '=', type: 'operator', operator: 'indentAuto' },\n    { keys: '>', type: 'operator', operator: 'indent', operatorArgs: { indentRight: true }},\n    { keys: '<', type: 'operator', operator: 'indent', operatorArgs: { indentRight: false }},\n    { keys: 'g~', type: 'operator', operator: 'changeCase' },\n    { keys: 'gu', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, isEdit: true },\n    { keys: 'gU', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, isEdit: true },\n    { keys: 'n', type: 'motion', motion: 'findNext', motionArgs: { forward: true, toJumplist: true }},\n    { keys: 'N', type: 'motion', motion: 'findNext', motionArgs: { forward: false, toJumplist: true }},\n    { keys: 'gn', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: true }},\n    { keys: 'gN', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: false }},\n    // Operator-Motion dual commands\n    { keys: 'x', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false }},\n    { keys: 'X', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true }},\n    { keys: 'D', type: 'operatorMotion', operator: 'delete', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'D', type: 'operator', operator: 'delete', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'Y', type: 'operatorMotion', operator: 'yank', motion: 'expandToLine', motionArgs: { linewise: true }, context: 'normal'},\n    { keys: 'Y', type: 'operator', operator: 'yank', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'C', type: 'operatorMotion', operator: 'change', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'C', type: 'operator', operator: 'change', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: '~', type: 'operatorMotion', operator: 'changeCase', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: 'normal'},\n    { keys: '~', type: 'operator', operator: 'changeCase', context: 'visual'},\n    { keys: '<C-u>', type: 'operatorMotion', operator: 'delete', motion: 'moveToStartOfLine', context: 'insert' },\n    { keys: '<C-w>', type: 'operatorMotion', operator: 'delete', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }, context: 'insert' },\n    //ignore C-w in normal mode\n    { keys: '<C-w>', type: 'idle', context: 'normal' },\n    // Actions\n    { keys: '<C-i>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: true }},\n    { keys: '<C-o>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: false }},\n    { keys: '<C-e>', type: 'action', action: 'scroll', actionArgs: { forward: true, linewise: true }},\n    { keys: '<C-y>', type: 'action', action: 'scroll', actionArgs: { forward: false, linewise: true }},\n    { keys: 'a', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'charAfter' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'eol' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'endOfSelectedArea' }, context: 'visual' },\n    { keys: 'i', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'inplace' }, context: 'normal' },\n    { keys: 'gi', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'lastEdit' }, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'firstNonBlank'}, context: 'normal' },\n    { keys: 'gI', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'bol'}, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'startOfSelectedArea' }, context: 'visual' },\n    { keys: 'o', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: 'normal' },\n    { keys: 'O', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: 'normal' },\n    { keys: 'v', type: 'action', action: 'toggleVisualMode' },\n    { keys: 'V', type: 'action', action: 'toggleVisualMode', actionArgs: { linewise: true }},\n    { keys: '<C-v>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: '<C-q>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: 'gv', type: 'action', action: 'reselectLastSelection' },\n    { keys: 'J', type: 'action', action: 'joinLines', isEdit: true },\n    { keys: 'gJ', type: 'action', action: 'joinLines', actionArgs: { keepSpaces: true }, isEdit: true },\n    { keys: 'p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true }},\n    { keys: 'P', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true }},\n    { keys: 'r<character>', type: 'action', action: 'replace', isEdit: true },\n    { keys: '@<character>', type: 'action', action: 'replayMacro' },\n    { keys: 'q<character>', type: 'action', action: 'enterMacroRecordMode' },\n    // Handle Replace-mode as a special case of insert mode.\n    { keys: 'R', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { replace: true }, context: 'normal'},\n    { keys: 'R', type: 'operator', operator: 'change', operatorArgs: { linewise: true, fullLine: true }, context: 'visual', exitVisualBlock: true},\n    { keys: 'u', type: 'action', action: 'undo', context: 'normal' },\n    { keys: 'u', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, context: 'visual', isEdit: true },\n    { keys: 'U', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, context: 'visual', isEdit: true },\n    { keys: '<C-r>', type: 'action', action: 'redo' },\n    { keys: 'm<character>', type: 'action', action: 'setMark' },\n    { keys: '\"<character>', type: 'action', action: 'setRegister' },\n    { keys: 'zz', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }},\n    { keys: 'z.', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zt', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }},\n    { keys: 'z<CR>', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zb', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }},\n    { keys: 'z-', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '.', type: 'action', action: 'repeatLastEdit' },\n    { keys: '<C-a>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: true, backtrack: false}},\n    { keys: '<C-x>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: false, backtrack: false}},\n    { keys: '<C-t>', type: 'action', action: 'indent', actionArgs: { indentRight: true }, context: 'insert' },\n    { keys: '<C-d>', type: 'action', action: 'indent', actionArgs: { indentRight: false }, context: 'insert' },\n    // Text object motions\n    { keys: 'a<character>', type: 'motion', motion: 'textObjectManipulation' },\n    { keys: 'i<character>', type: 'motion', motion: 'textObjectManipulation', motionArgs: { textObjectInner: true }},\n    // Search\n    { keys: '/', type: 'search', searchArgs: { forward: true, querySrc: 'prompt', toJumplist: true }},\n    { keys: '?', type: 'search', searchArgs: { forward: false, querySrc: 'prompt', toJumplist: true }},\n    { keys: '*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: '#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: 'g*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', toJumplist: true }},\n    { keys: 'g#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', toJumplist: true }},\n    // Ex command\n    { keys: ':', type: 'ex' }\n  ];\n  var defaultKeymapLength = defaultKeymap.length;\n\n  /**\n   * Ex commands\n   * Care must be taken when adding to the default Ex command map. For any\n   * pair of commands that have a shared prefix, at least one of their\n   * shortNames must not match the prefix of the other command.\n   */\n  var defaultExCommandMap = [\n    { name: 'colorscheme', shortName: 'colo' },\n    { name: 'map' },\n    { name: 'imap', shortName: 'im' },\n    { name: 'nmap', shortName: 'nm' },\n    { name: 'vmap', shortName: 'vm' },\n    { name: 'unmap' },\n    { name: 'write', shortName: 'w' },\n    { name: 'undo', shortName: 'u' },\n    { name: 'redo', shortName: 'red' },\n    { name: 'set', shortName: 'se' },\n    { name: 'setlocal', shortName: 'setl' },\n    { name: 'setglobal', shortName: 'setg' },\n    { name: 'sort', shortName: 'sor' },\n    { name: 'substitute', shortName: 's', possiblyAsync: true },\n    { name: 'nohlsearch', shortName: 'noh' },\n    { name: 'yank', shortName: 'y' },\n    { name: 'delmarks', shortName: 'delm' },\n    { name: 'registers', shortName: 'reg', excludeFromCommandHistory: true },\n    { name: 'vglobal', shortName: 'v' },\n    { name: 'global', shortName: 'g' }\n  ];\n\n    function enterVimMode(cm) {\n      cm.setOption('disableInput', true);\n      cm.setOption('showCursorWhenSelecting', false);\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      cm.on('cursorActivity', onCursorActivity);\n      maybeInitVimState(cm);\n      CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    }\n\n    function leaveVimMode(cm) {\n      cm.setOption('disableInput', false);\n      cm.off('cursorActivity', onCursorActivity);\n      CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n      cm.state.vim = null;\n      if (highlightTimeout) clearTimeout(highlightTimeout);\n    }\n\n    function detachVimMap(cm, next) {\n      if (this == CodeMirror.keyMap.vim) {\n        cm.options.$customCursor = null;\n        CodeMirror.rmClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n      }\n\n      if (!next || next.attach != attachVimMap)\n        leaveVimMode(cm);\n    }\n    function attachVimMap(cm, prev) {\n      if (this == CodeMirror.keyMap.vim) {\n        if (cm.curOp) cm.curOp.selectionChanged = true;\n        cm.options.$customCursor = transformCursor;\n        CodeMirror.addClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n      }\n\n      if (!prev || prev.attach != attachVimMap)\n        enterVimMode(cm);\n    }\n\n    // Deprecated, simply setting the keymap works again.\n    CodeMirror.defineOption('vimMode', false, function(cm, val, prev) {\n      if (val && cm.getOption(\"keyMap\") != \"vim\")\n        cm.setOption(\"keyMap\", \"vim\");\n      else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption(\"keyMap\")))\n        cm.setOption(\"keyMap\", \"default\");\n    });\n\n    function cmKey(key, cm) {\n      if (!cm) { return undefined; }\n      if (this[key]) { return this[key]; }\n      var vimKey = cmKeyToVimKey(key);\n      if (!vimKey) {\n        return false;\n      }\n      var cmd = vimApi.findKey(cm, vimKey);\n      if (typeof cmd == 'function') {\n        CodeMirror.signal(cm, 'vim-keypress', vimKey);\n      }\n      return cmd;\n    }\n\n    var modifiers = {Shift:'S',Ctrl:'C',Alt:'A',Cmd:'D',Mod:'A',CapsLock:''};\n    var specialKeys = {Enter:'CR',Backspace:'BS',Delete:'Del',Insert:'Ins'};\n    function cmKeyToVimKey(key) {\n      if (key.charAt(0) == '\\'') {\n        // Keypress character binding of format \"'a'\"\n        return key.charAt(1);\n      }\n      var pieces = key.split(/-(?!$)/);\n      var lastPiece = pieces[pieces.length - 1];\n      if (pieces.length == 1 && pieces[0].length == 1) {\n        // No-modifier bindings use literal character bindings above. Skip.\n        return false;\n      } else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {\n        // Ignore Shift+char bindings as they should be handled by literal character.\n        return false;\n      }\n      var hasCharacter = false;\n      for (var i = 0; i < pieces.length; i++) {\n        var piece = pieces[i];\n        if (piece in modifiers) { pieces[i] = modifiers[piece]; }\n        else { hasCharacter = true; }\n        if (piece in specialKeys) { pieces[i] = specialKeys[piece]; }\n      }\n      if (!hasCharacter) {\n        // Vim does not support modifier only keys.\n        return false;\n      }\n      // TODO: Current bindings expect the character to be lower case, but\n      // it looks like vim key notation uses upper case.\n      if (isUpperCase(lastPiece)) {\n        pieces[pieces.length - 1] = lastPiece.toLowerCase();\n      }\n      return '<' + pieces.join('-') + '>';\n    }\n\n    function getOnPasteFn(cm) {\n      var vim = cm.state.vim;\n      if (!vim.onPasteFn) {\n        vim.onPasteFn = function() {\n          if (!vim.insertMode) {\n            cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n            actions.enterInsertMode(cm, {}, vim);\n          }\n        };\n      }\n      return vim.onPasteFn;\n    }\n\n    var numberRegex = /[\\d]/;\n    var wordCharTest = [CodeMirror.isWordChar, function(ch) {\n      return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n    }], bigWordCharTest = [function(ch) {\n      return /\\S/.test(ch);\n    }];\n    function makeKeyRange(start, size) {\n      var keys = [];\n      for (var i = start; i < start + size; i++) {\n        keys.push(String.fromCharCode(i));\n      }\n      return keys;\n    }\n    var upperCaseAlphabet = makeKeyRange(65, 26);\n    var lowerCaseAlphabet = makeKeyRange(97, 26);\n    var numbers = makeKeyRange(48, 10);\n    var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);\n    var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '\"', '.', ':', '_', '/']);\n    var upperCaseChars;\n    try { upperCaseChars = new RegExp(\"^[\\\\p{Lu}]$\", \"u\"); }\n    catch (_) { upperCaseChars = /^[A-Z]$/; }\n\n    function isLine(cm, line) {\n      return line >= cm.firstLine() && line <= cm.lastLine();\n    }\n    function isLowerCase(k) {\n      return (/^[a-z]$/).test(k);\n    }\n    function isMatchableSymbol(k) {\n      return '()[]{}'.indexOf(k) != -1;\n    }\n    function isNumber(k) {\n      return numberRegex.test(k);\n    }\n    function isUpperCase(k) {\n      return upperCaseChars.test(k);\n    }\n    function isWhiteSpaceString(k) {\n      return (/^\\s*$/).test(k);\n    }\n    function isEndOfSentenceSymbol(k) {\n      return '.?!'.indexOf(k) != -1;\n    }\n    function inArray(val, arr) {\n      for (var i = 0; i < arr.length; i++) {\n        if (arr[i] == val) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    var options = {};\n    function defineOption(name, defaultValue, type, aliases, callback) {\n      if (defaultValue === undefined && !callback) {\n        throw Error('defaultValue is required unless callback is provided');\n      }\n      if (!type) { type = 'string'; }\n      options[name] = {\n        type: type,\n        defaultValue: defaultValue,\n        callback: callback\n      };\n      if (aliases) {\n        for (var i = 0; i < aliases.length; i++) {\n          options[aliases[i]] = options[name];\n        }\n      }\n      if (defaultValue) {\n        setOption(name, defaultValue);\n      }\n    }\n\n    function setOption(name, value, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.type == 'boolean') {\n        if (value && value !== true) {\n          return new Error('Invalid argument: ' + name + '=' + value);\n        } else if (value !== false) {\n          // Boolean options are set to true if value is not defined.\n          value = true;\n        }\n      }\n      if (option.callback) {\n        if (scope !== 'local') {\n          option.callback(value, undefined);\n        }\n        if (scope !== 'global' && cm) {\n          option.callback(value, cm);\n        }\n      } else {\n        if (scope !== 'local') {\n          option.value = option.type == 'boolean' ? !!value : value;\n        }\n        if (scope !== 'global' && cm) {\n          cm.state.vim.options[name] = {value: value};\n        }\n      }\n    }\n\n    function getOption(name, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.callback) {\n        var local = cm && option.callback(undefined, cm);\n        if (scope !== 'global' && local !== undefined) {\n          return local;\n        }\n        if (scope !== 'local') {\n          return option.callback();\n        }\n        return;\n      } else {\n        var local = (scope !== 'global') && (cm && cm.state.vim.options[name]);\n        return (local || (scope !== 'local') && option || {}).value;\n      }\n    }\n\n    defineOption('filetype', undefined, 'string', ['ft'], function(name, cm) {\n      // Option is local. Do nothing for global.\n      if (cm === undefined) {\n        return;\n      }\n      // The 'filetype' option proxies to the CodeMirror 'mode' option.\n      if (name === undefined) {\n        var mode = cm.getOption('mode');\n        return mode == 'null' ? '' : mode;\n      } else {\n        var mode = name == '' ? 'null' : name;\n        cm.setOption('mode', mode);\n      }\n    });\n\n    var createCircularJumpList = function() {\n      var size = 100;\n      var pointer = -1;\n      var head = 0;\n      var tail = 0;\n      var buffer = new Array(size);\n      function add(cm, oldCur, newCur) {\n        var current = pointer % size;\n        var curMark = buffer[current];\n        function useNextSlot(cursor) {\n          var next = ++pointer % size;\n          var trashMark = buffer[next];\n          if (trashMark) {\n            trashMark.clear();\n          }\n          buffer[next] = cm.setBookmark(cursor);\n        }\n        if (curMark) {\n          var markPos = curMark.find();\n          // avoid recording redundant cursor position\n          if (markPos && !cursorEqual(markPos, oldCur)) {\n            useNextSlot(oldCur);\n          }\n        } else {\n          useNextSlot(oldCur);\n        }\n        useNextSlot(newCur);\n        head = pointer;\n        tail = pointer - size + 1;\n        if (tail < 0) {\n          tail = 0;\n        }\n      }\n      function move(cm, offset) {\n        pointer += offset;\n        if (pointer > head) {\n          pointer = head;\n        } else if (pointer < tail) {\n          pointer = tail;\n        }\n        var mark = buffer[(size + pointer) % size];\n        // skip marks that are temporarily removed from text buffer\n        if (mark && !mark.find()) {\n          var inc = offset > 0 ? 1 : -1;\n          var newCur;\n          var oldCur = cm.getCursor();\n          do {\n            pointer += inc;\n            mark = buffer[(size + pointer) % size];\n            // skip marks that are the same as current position\n            if (mark &&\n                (newCur = mark.find()) &&\n                !cursorEqual(oldCur, newCur)) {\n              break;\n            }\n          } while (pointer < head && pointer > tail);\n        }\n        return mark;\n      }\n      function find(cm, offset) {\n        var oldPointer = pointer;\n        var mark = move(cm, offset);\n        pointer = oldPointer;\n        return mark && mark.find();\n      }\n      return {\n        cachedCursor: undefined, //used for # and * jumps\n        add: add,\n        find: find,\n        move: move\n      };\n    };\n\n    // Returns an object to track the changes associated insert mode.  It\n    // clones the object that is passed in, or creates an empty object one if\n    // none is provided.\n    var createInsertModeChanges = function(c) {\n      if (c) {\n        // Copy construction\n        return {\n          changes: c.changes,\n          expectCursorActivityForChange: c.expectCursorActivityForChange\n        };\n      }\n      return {\n        // Change list\n        changes: [],\n        // Set to true on change, false on cursorActivity.\n        expectCursorActivityForChange: false\n      };\n    };\n\n    function MacroModeState() {\n      this.latestRegister = undefined;\n      this.isPlaying = false;\n      this.isRecording = false;\n      this.replaySearchQueries = [];\n      this.onRecordingDone = undefined;\n      this.lastInsertModeChanges = createInsertModeChanges();\n    }\n    MacroModeState.prototype = {\n      exitMacroRecordMode: function() {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.onRecordingDone) {\n          macroModeState.onRecordingDone(); // close dialog\n        }\n        macroModeState.onRecordingDone = undefined;\n        macroModeState.isRecording = false;\n      },\n      enterMacroRecordMode: function(cm, registerName) {\n        var register =\n            vimGlobalState.registerController.getRegister(registerName);\n        if (register) {\n          register.clear();\n          this.latestRegister = registerName;\n          if (cm.openDialog) {\n            var template = dom('span', {class: 'cm-vim-message'}, 'recording @' + registerName);\n            this.onRecordingDone = cm.openDialog(template, null, {bottom:true});\n          }\n          this.isRecording = true;\n        }\n      }\n    };\n\n    function maybeInitVimState(cm) {\n      if (!cm.state.vim) {\n        // Store instance state in the CodeMirror object.\n        cm.state.vim = {\n          inputState: new InputState(),\n          // Vim's input state that triggered the last edit, used to repeat\n          // motions and operators with '.'.\n          lastEditInputState: undefined,\n          // Vim's action command before the last edit, used to repeat actions\n          // with '.' and insert mode repeat.\n          lastEditActionCommand: undefined,\n          // When using jk for navigation, if you move from a longer line to a\n          // shorter line, the cursor may clip to the end of the shorter line.\n          // If j is pressed again and cursor goes to the next line, the\n          // cursor should go back to its horizontal position on the longer\n          // line if it can. This is to keep track of the horizontal position.\n          lastHPos: -1,\n          // Doing the same with screen-position for gj/gk\n          lastHSPos: -1,\n          // The last motion command run. Cleared if a non-motion command gets\n          // executed in between.\n          lastMotion: null,\n          marks: {},\n          insertMode: false,\n          // Repeat count for changes made in insert mode, triggered by key\n          // sequences like 3,i. Only exists when insertMode is true.\n          insertModeRepeat: undefined,\n          visualMode: false,\n          // If we are in visual line mode. No effect if visualMode is false.\n          visualLine: false,\n          visualBlock: false,\n          lastSelection: null,\n          lastPastedText: null,\n          sel: {},\n          // Buffer-local/window-local values of vim options.\n          options: {}\n        };\n      }\n      return cm.state.vim;\n    }\n    var vimGlobalState;\n    function resetVimGlobalState() {\n      vimGlobalState = {\n        // The current search query.\n        searchQuery: null,\n        // Whether we are searching backwards.\n        searchIsReversed: false,\n        // Replace part of the last substituted pattern\n        lastSubstituteReplacePart: undefined,\n        jumpList: createCircularJumpList(),\n        macroModeState: new MacroModeState,\n        // Recording latest f, t, F or T motion command.\n        lastCharacterSearch: {increment:0, forward:true, selectedCharacter:''},\n        registerController: new RegisterController({}),\n        // search history buffer\n        searchHistoryController: new HistoryController(),\n        // ex Command history buffer\n        exCommandHistoryController : new HistoryController()\n      };\n      for (var optionName in options) {\n        var option = options[optionName];\n        option.value = option.defaultValue;\n      }\n    }\n\n    var lastInsertModeKeyTimer;\n    var vimApi = {\n      enterVimMode: enterVimMode,\n      buildKeyMap: function() {\n        // TODO: Convert keymap into dictionary format for fast lookup.\n      },\n      // Testing hook, though it might be useful to expose the register\n      // controller anyway.\n      getRegisterController: function() {\n        return vimGlobalState.registerController;\n      },\n      // Testing hook.\n      resetVimGlobalState_: resetVimGlobalState,\n\n      // Testing hook.\n      getVimGlobalState_: function() {\n        return vimGlobalState;\n      },\n\n      // Testing hook.\n      maybeInitVimState_: maybeInitVimState,\n\n      suppressErrorLogging: false,\n\n      InsertModeKey: InsertModeKey,\n      map: function(lhs, rhs, ctx) {\n        // Add user defined key bindings.\n        exCommandDispatcher.map(lhs, rhs, ctx);\n      },\n      unmap: function(lhs, ctx) {\n        return exCommandDispatcher.unmap(lhs, ctx);\n      },\n      // Non-recursive map function.\n      // NOTE: This will not create mappings to key maps that aren't present\n      // in the default key map. See TODO at bottom of function.\n      noremap: function(lhs, rhs, ctx) {\n        function toCtxArray(ctx) {\n          return ctx ? [ctx] : ['normal', 'insert', 'visual'];\n        }\n        var ctxsToMap = toCtxArray(ctx);\n        // Look through all actual defaults to find a map candidate.\n        var actualLength = defaultKeymap.length, origLength = defaultKeymapLength;\n        for (var i = actualLength - origLength;\n             i < actualLength && ctxsToMap.length;\n             i++) {\n          var mapping = defaultKeymap[i];\n          // Omit mappings that operate in the wrong context(s) and those of invalid type.\n          if (mapping.keys == rhs &&\n              (!ctx || !mapping.context || mapping.context === ctx) &&\n              mapping.type.substr(0, 2) !== 'ex' &&\n              mapping.type.substr(0, 3) !== 'key') {\n            // Make a shallow copy of the original keymap entry.\n            var newMapping = {};\n            for (var key in mapping) {\n              newMapping[key] = mapping[key];\n            }\n            // Modify it point to the new mapping with the proper context.\n            newMapping.keys = lhs;\n            if (ctx && !newMapping.context) {\n              newMapping.context = ctx;\n            }\n            // Add it to the keymap with a higher priority than the original.\n            this._mapCommand(newMapping);\n            // Record the mapped contexts as complete.\n            var mappedCtxs = toCtxArray(mapping.context);\n            ctxsToMap = ctxsToMap.filter(function(el) { return mappedCtxs.indexOf(el) === -1; });\n          }\n        }\n        // TODO: Create non-recursive keyToKey mappings for the unmapped contexts once those exist.\n      },\n      // Remove all user-defined mappings for the provided context.\n      mapclear: function(ctx) {\n        // Partition the existing keymap into user-defined and true defaults.\n        var actualLength = defaultKeymap.length,\n            origLength = defaultKeymapLength;\n        var userKeymap = defaultKeymap.slice(0, actualLength - origLength);\n        defaultKeymap = defaultKeymap.slice(actualLength - origLength);\n        if (ctx) {\n          // If a specific context is being cleared, we need to keep mappings\n          // from all other contexts.\n          for (var i = userKeymap.length - 1; i >= 0; i--) {\n            var mapping = userKeymap[i];\n            if (ctx !== mapping.context) {\n              if (mapping.context) {\n                this._mapCommand(mapping);\n              } else {\n                // `mapping` applies to all contexts so create keymap copies\n                // for each context except the one being cleared.\n                var contexts = ['normal', 'insert', 'visual'];\n                for (var j in contexts) {\n                  if (contexts[j] !== ctx) {\n                    var newMapping = {};\n                    for (var key in mapping) {\n                      newMapping[key] = mapping[key];\n                    }\n                    newMapping.context = contexts[j];\n                    this._mapCommand(newMapping);\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace\n      // them, or somehow make them work with the existing CodeMirror setOption/getOption API.\n      setOption: setOption,\n      getOption: getOption,\n      defineOption: defineOption,\n      defineEx: function(name, prefix, func){\n        if (!prefix) {\n          prefix = name;\n        } else if (name.indexOf(prefix) !== 0) {\n          throw new Error('(Vim.defineEx) \"'+prefix+'\" is not a prefix of \"'+name+'\", command not registered');\n        }\n        exCommands[name]=func;\n        exCommandDispatcher.commandMap_[prefix]={name:name, shortName:prefix, type:'api'};\n      },\n      handleKey: function (cm, key, origin) {\n        var command = this.findKey(cm, key, origin);\n        if (typeof command === 'function') {\n          return command();\n        }\n      },\n      multiSelectHandleKey: multiSelectHandleKey,\n\n      /**\n       * This is the outermost function called by CodeMirror, after keys have\n       * been mapped to their Vim equivalents.\n       *\n       * Finds a command based on the key (and cached keys if there is a\n       * multi-key sequence). Returns `undefined` if no key is matched, a noop\n       * function if a partial match is found (multi-key), and a function to\n       * execute the bound command if a a key is matched. The function always\n       * returns true.\n       */\n      findKey: function(cm, key, origin) {\n        var vim = maybeInitVimState(cm);\n        function handleMacroRecording() {\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            if (key == 'q') {\n              macroModeState.exitMacroRecordMode();\n              clearInputState(cm);\n              return true;\n            }\n            if (origin != 'mapping') {\n              logKey(macroModeState, key);\n            }\n          }\n        }\n        function handleEsc() {\n          if (key == '<Esc>') {\n            if (vim.visualMode) {\n              // Get back to normal mode.\n              exitVisualMode(cm);\n            } else if (vim.insertMode) {\n              // Get back to normal mode.\n              exitInsertMode(cm);\n            } else {\n              // We're already in normal mode. Let '<Esc>' be handled normally.\n              return;\n            }\n            clearInputState(cm);\n            return true;\n          }\n        }\n        function doKeyToKey(keys) {\n          // TODO: prevent infinite recursion.\n          var match;\n          while (keys) {\n            // Pull off one command key, which is either a single character\n            // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n            match = (/<\\w+-.+?>|<\\w+>|./).exec(keys);\n            key = match[0];\n            keys = keys.substring(match.index + key.length);\n            vimApi.handleKey(cm, key, 'mapping');\n          }\n        }\n\n        function handleKeyInsertMode() {\n          if (handleEsc()) { return true; }\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          var keysAreChars = key.length == 1;\n          var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n          // Need to check all key substrings in insert mode.\n          while (keys.length > 1 && match.type != 'full') {\n            var keys = vim.inputState.keyBuffer = keys.slice(1);\n            var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n            if (thisMatch.type != 'none') { match = thisMatch; }\n          }\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') {\n            if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n            lastInsertModeKeyTimer = window.setTimeout(\n              function() { if (vim.insertMode && vim.inputState.keyBuffer) { clearInputState(cm); } },\n              getOption('insertModeEscKeysTimeout'));\n            return !keysAreChars;\n          }\n\n          if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n          if (keysAreChars) {\n            var selections = cm.listSelections();\n            for (var i = 0; i < selections.length; i++) {\n              var here = selections[i].head;\n              cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input');\n            }\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n          }\n          clearInputState(cm);\n          return match.command;\n        }\n\n        function handleKeyNonInsertMode() {\n          if (handleMacroRecording() || handleEsc()) { return true; }\n\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          if (/^[1-9]\\d*$/.test(keys)) { return true; }\n\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (!keysMatcher) { clearInputState(cm); return false; }\n          var context = vim.visualMode ? 'visual' :\n                                         'normal';\n          var mainKey = keysMatcher[2] || keysMatcher[1];\n          if (vim.inputState.operatorShortcut && vim.inputState.operatorShortcut.slice(-1) == mainKey) {\n            // multikey operators act linewise by repeating only the last character\n            mainKey = vim.inputState.operatorShortcut;\n          }\n          var match = commandDispatcher.matchCommand(mainKey, defaultKeymap, vim.inputState, context);\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') { return true; }\n          else if (match.type == 'clear') { clearInputState(cm); return true; }\n\n          vim.inputState.keyBuffer = '';\n          keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (keysMatcher[1] && keysMatcher[1] != '0') {\n            vim.inputState.pushRepeatDigit(keysMatcher[1]);\n          }\n          return match.command;\n        }\n\n        var command;\n        if (vim.insertMode) { command = handleKeyInsertMode(); }\n        else { command = handleKeyNonInsertMode(); }\n        if (command === false) {\n          return !vim.insertMode && key.length === 1 ? function() { return true; } : undefined;\n        } else if (command === true) {\n          // TODO: Look into using CodeMirror's multi-key handling.\n          // Return no-op since we are caching the key. Counts as handled, but\n          // don't want act on it just yet.\n          return function() { return true; };\n        } else {\n          return function() {\n            return cm.operation(function() {\n              cm.curOp.isVimOp = true;\n              try {\n                if (command.type == 'keyToKey') {\n                  doKeyToKey(command.toKeys);\n                } else {\n                  commandDispatcher.processCommand(cm, vim, command);\n                }\n              } catch (e) {\n                // clear VIM state in case it's in a bad state.\n                cm.state.vim = undefined;\n                maybeInitVimState(cm);\n                if (!vimApi.suppressErrorLogging) {\n                  console['log'](e);\n                }\n                throw e;\n              }\n              return true;\n            });\n          };\n        }\n      },\n      handleEx: function(cm, input) {\n        exCommandDispatcher.processCommand(cm, input);\n      },\n\n      defineMotion: defineMotion,\n      defineAction: defineAction,\n      defineOperator: defineOperator,\n      mapCommand: mapCommand,\n      _mapCommand: _mapCommand,\n\n      defineRegister: defineRegister,\n\n      exitVisualMode: exitVisualMode,\n      exitInsertMode: exitInsertMode\n    };\n\n    // Represents the current input state.\n    function InputState() {\n      this.prefixRepeat = [];\n      this.motionRepeat = [];\n\n      this.operator = null;\n      this.operatorArgs = null;\n      this.motion = null;\n      this.motionArgs = null;\n      this.keyBuffer = []; // For matching multi-key commands.\n      this.registerName = null; // Defaults to the unnamed register.\n    }\n    InputState.prototype.pushRepeatDigit = function(n) {\n      if (!this.operator) {\n        this.prefixRepeat = this.prefixRepeat.concat(n);\n      } else {\n        this.motionRepeat = this.motionRepeat.concat(n);\n      }\n    };\n    InputState.prototype.getRepeat = function() {\n      var repeat = 0;\n      if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n        repeat = 1;\n        if (this.prefixRepeat.length > 0) {\n          repeat *= parseInt(this.prefixRepeat.join(''), 10);\n        }\n        if (this.motionRepeat.length > 0) {\n          repeat *= parseInt(this.motionRepeat.join(''), 10);\n        }\n      }\n      return repeat;\n    };\n\n    function clearInputState(cm, reason) {\n      cm.state.vim.inputState = new InputState();\n      CodeMirror.signal(cm, 'vim-command-done', reason);\n    }\n\n    /*\n     * Register stores information about copy and paste registers.  Besides\n     * text, a register must store whether it is linewise (i.e., when it is\n     * pasted, should it insert itself into a new line, or should the text be\n     * inserted at the cursor position.)\n     */\n    function Register(text, linewise, blockwise) {\n      this.clear();\n      this.keyBuffer = [text || ''];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    }\n    Register.prototype = {\n      setText: function(text, linewise, blockwise) {\n        this.keyBuffer = [text || ''];\n        this.linewise = !!linewise;\n        this.blockwise = !!blockwise;\n      },\n      pushText: function(text, linewise) {\n        // if this register has ever been set to linewise, use linewise.\n        if (linewise) {\n          if (!this.linewise) {\n            this.keyBuffer.push('\\n');\n          }\n          this.linewise = true;\n        }\n        this.keyBuffer.push(text);\n      },\n      pushInsertModeChanges: function(changes) {\n        this.insertModeChanges.push(createInsertModeChanges(changes));\n      },\n      pushSearchQuery: function(query) {\n        this.searchQueries.push(query);\n      },\n      clear: function() {\n        this.keyBuffer = [];\n        this.insertModeChanges = [];\n        this.searchQueries = [];\n        this.linewise = false;\n      },\n      toString: function() {\n        return this.keyBuffer.join('');\n      }\n    };\n\n    /**\n     * Defines an external register.\n     *\n     * The name should be a single character that will be used to reference the register.\n     * The register should support setText, pushText, clear, and toString(). See Register\n     * for a reference implementation.\n     */\n    function defineRegister(name, register) {\n      var registers = vimGlobalState.registerController.registers;\n      if (!name || name.length != 1) {\n        throw Error('Register name must be 1 character');\n      }\n      if (registers[name]) {\n        throw Error('Register already defined ' + name);\n      }\n      registers[name] = register;\n      validRegisters.push(name);\n    }\n\n    /*\n     * vim registers allow you to keep many independent copy and paste buffers.\n     * See http://usevim.com/2012/04/13/registers/ for an introduction.\n     *\n     * RegisterController keeps the state of all the registers.  An initial\n     * state may be passed in.  The unnamed register '\"' will always be\n     * overridden.\n     */\n    function RegisterController(registers) {\n      this.registers = registers;\n      this.unnamedRegister = registers['\"'] = new Register();\n      registers['.'] = new Register();\n      registers[':'] = new Register();\n      registers['/'] = new Register();\n    }\n    RegisterController.prototype = {\n      pushText: function(registerName, operator, text, linewise, blockwise) {\n        // The black hole register, \"_, means delete/yank to nowhere.\n        if (registerName === '_') return;\n        if (linewise && text.charAt(text.length - 1) !== '\\n'){\n          text += '\\n';\n        }\n        // Lowercase and uppercase registers refer to the same register.\n        // Uppercase just means append.\n        var register = this.isValidRegister(registerName) ?\n            this.getRegister(registerName) : null;\n        // if no register/an invalid register was specified, things go to the\n        // default registers\n        if (!register) {\n          switch (operator) {\n            case 'yank':\n              // The 0 register contains the text from the most recent yank.\n              this.registers['0'] = new Register(text, linewise, blockwise);\n              break;\n            case 'delete':\n            case 'change':\n              if (text.indexOf('\\n') == -1) {\n                // Delete less than 1 line. Update the small delete register.\n                this.registers['-'] = new Register(text, linewise);\n              } else {\n                // Shift down the contents of the numbered registers and put the\n                // deleted text into register 1.\n                this.shiftNumericRegisters_();\n                this.registers['1'] = new Register(text, linewise);\n              }\n              break;\n          }\n          // Make sure the unnamed register is set to what just happened\n          this.unnamedRegister.setText(text, linewise, blockwise);\n          return;\n        }\n\n        // If we've gotten to this point, we've actually specified a register\n        var append = isUpperCase(registerName);\n        if (append) {\n          register.pushText(text, linewise);\n        } else {\n          register.setText(text, linewise, blockwise);\n        }\n        // The unnamed register always has the same value as the last used\n        // register.\n        this.unnamedRegister.setText(register.toString(), linewise);\n      },\n      // Gets the register named @name.  If one of @name doesn't already exist,\n      // create it.  If @name is invalid, return the unnamedRegister.\n      getRegister: function(name) {\n        if (!this.isValidRegister(name)) {\n          return this.unnamedRegister;\n        }\n        name = name.toLowerCase();\n        if (!this.registers[name]) {\n          this.registers[name] = new Register();\n        }\n        return this.registers[name];\n      },\n      isValidRegister: function(name) {\n        return name && inArray(name, validRegisters);\n      },\n      shiftNumericRegisters_: function() {\n        for (var i = 9; i >= 2; i--) {\n          this.registers[i] = this.getRegister('' + (i - 1));\n        }\n      }\n    };\n    function HistoryController() {\n        this.historyBuffer = [];\n        this.iterator = 0;\n        this.initialPrefix = null;\n    }\n    HistoryController.prototype = {\n      // the input argument here acts a user entered prefix for a small time\n      // until we start autocompletion in which case it is the autocompleted.\n      nextMatch: function (input, up) {\n        var historyBuffer = this.historyBuffer;\n        var dir = up ? -1 : 1;\n        if (this.initialPrefix === null) this.initialPrefix = input;\n        for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i+= dir) {\n          var element = historyBuffer[i];\n          for (var j = 0; j <= element.length; j++) {\n            if (this.initialPrefix == element.substring(0, j)) {\n              this.iterator = i;\n              return element;\n            }\n          }\n        }\n        // should return the user input in case we reach the end of buffer.\n        if (i >= historyBuffer.length) {\n          this.iterator = historyBuffer.length;\n          return this.initialPrefix;\n        }\n        // return the last autocompleted query or exCommand as it is.\n        if (i < 0 ) return input;\n      },\n      pushInput: function(input) {\n        var index = this.historyBuffer.indexOf(input);\n        if (index > -1) this.historyBuffer.splice(index, 1);\n        if (input.length) this.historyBuffer.push(input);\n      },\n      reset: function() {\n        this.initialPrefix = null;\n        this.iterator = this.historyBuffer.length;\n      }\n    };\n    var commandDispatcher = {\n      matchCommand: function(keys, keyMap, inputState, context) {\n        var matches = commandMatches(keys, keyMap, context, inputState);\n        if (!matches.full && !matches.partial) {\n          return {type: 'none'};\n        } else if (!matches.full && matches.partial) {\n          return {type: 'partial'};\n        }\n\n        var bestMatch;\n        for (var i = 0; i < matches.full.length; i++) {\n          var match = matches.full[i];\n          if (!bestMatch) {\n            bestMatch = match;\n          }\n        }\n        if (bestMatch.keys.slice(-11) == '<character>') {\n          var character = lastChar(keys);\n          if (!character || character.length > 1) return {type: 'clear'};\n          inputState.selectedCharacter = character;\n        }\n        return {type: 'full', command: bestMatch};\n      },\n      processCommand: function(cm, vim, command) {\n        vim.inputState.repeatOverride = command.repeatOverride;\n        switch (command.type) {\n          case 'motion':\n            this.processMotion(cm, vim, command);\n            break;\n          case 'operator':\n            this.processOperator(cm, vim, command);\n            break;\n          case 'operatorMotion':\n            this.processOperatorMotion(cm, vim, command);\n            break;\n          case 'action':\n            this.processAction(cm, vim, command);\n            break;\n          case 'search':\n            this.processSearch(cm, vim, command);\n            break;\n          case 'ex':\n          case 'keyToEx':\n            this.processEx(cm, vim, command);\n            break;\n        }\n      },\n      processMotion: function(cm, vim, command) {\n        vim.inputState.motion = command.motion;\n        vim.inputState.motionArgs = copyArgs(command.motionArgs);\n        this.evalInput(cm, vim);\n      },\n      processOperator: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        if (inputState.operator) {\n          if (inputState.operator == command.operator) {\n            // Typing an operator twice like 'dd' makes the operator operate\n            // linewise\n            inputState.motion = 'expandToLine';\n            inputState.motionArgs = { linewise: true };\n            this.evalInput(cm, vim);\n            return;\n          } else {\n            // 2 different operators in a row doesn't make sense.\n            clearInputState(cm);\n          }\n        }\n        inputState.operator = command.operator;\n        inputState.operatorArgs = copyArgs(command.operatorArgs);\n        if (command.keys.length > 1) {\n          inputState.operatorShortcut = command.keys;\n        }\n        if (command.exitVisualBlock) {\n            vim.visualBlock = false;\n            updateCmSelection(cm);\n        }\n        if (vim.visualMode) {\n          // Operating on a selection in visual mode. We don't need a motion.\n          this.evalInput(cm, vim);\n        }\n      },\n      processOperatorMotion: function(cm, vim, command) {\n        var visualMode = vim.visualMode;\n        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n        if (operatorMotionArgs) {\n          // Operator motions may have special behavior in visual mode.\n          if (visualMode && operatorMotionArgs.visualLine) {\n            vim.visualLine = true;\n          }\n        }\n        this.processOperator(cm, vim, command);\n        if (!visualMode) {\n          this.processMotion(cm, vim, command);\n        }\n      },\n      processAction: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        var repeat = inputState.getRepeat();\n        var repeatIsExplicit = !!repeat;\n        var actionArgs = copyArgs(command.actionArgs) || {};\n        if (inputState.selectedCharacter) {\n          actionArgs.selectedCharacter = inputState.selectedCharacter;\n        }\n        // Actions may or may not have motions and operators. Do these first.\n        if (command.operator) {\n          this.processOperator(cm, vim, command);\n        }\n        if (command.motion) {\n          this.processMotion(cm, vim, command);\n        }\n        if (command.motion || command.operator) {\n          this.evalInput(cm, vim);\n        }\n        actionArgs.repeat = repeat || 1;\n        actionArgs.repeatIsExplicit = repeatIsExplicit;\n        actionArgs.registerName = inputState.registerName;\n        clearInputState(cm);\n        vim.lastMotion = null;\n        if (command.isEdit) {\n          this.recordLastEdit(vim, inputState, command);\n        }\n        actions[command.action](cm, actionArgs, vim);\n      },\n      processSearch: function(cm, vim, command) {\n        if (!cm.getSearchCursor) {\n          // Search depends on SearchCursor.\n          return;\n        }\n        var forward = command.searchArgs.forward;\n        var wholeWordOnly = command.searchArgs.wholeWordOnly;\n        getSearchState(cm).setReversed(!forward);\n        var promptPrefix = (forward) ? '/' : '?';\n        var originalQuery = getSearchState(cm).getQuery();\n        var originalScrollPos = cm.getScrollInfo();\n        function handleQuery(query, ignoreCase, smartCase) {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n          try {\n            updateSearchQuery(cm, query, ignoreCase, smartCase);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + query);\n            clearInputState(cm);\n            return;\n          }\n          commandDispatcher.processMotion(cm, vim, {\n            type: 'motion',\n            motion: 'findNext',\n            motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }\n          });\n        }\n        function onPromptClose(query) {\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          handleQuery(query, true /** ignoreCase */, true /** smartCase */);\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            logSearchQuery(macroModeState, query);\n          }\n        }\n        function onPromptKeyUp(e, query, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Up' || keyName == 'Down') {\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n            close(query);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.searchHistoryController.reset();\n          }\n          var parsedQuery;\n          try {\n            parsedQuery = updateSearchQuery(cm, query,\n                true /** ignoreCase */, true /** smartCase */);\n          } catch (e) {\n            // Swallow bad regexes for incremental search.\n          }\n          if (parsedQuery) {\n            cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n          } else {\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          }\n        }\n        function onPromptKeyDown(e, query, close) {\n          var keyName = CodeMirror.keyName(e);\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && query == '')) {\n            vimGlobalState.searchHistoryController.pushInput(query);\n            vimGlobalState.searchHistoryController.reset();\n            updateSearchQuery(cm, originalQuery);\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          } else if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          }\n        }\n        switch (command.searchArgs.querySrc) {\n          case 'prompt':\n            var macroModeState = vimGlobalState.macroModeState;\n            if (macroModeState.isPlaying) {\n              var query = macroModeState.replaySearchQueries.shift();\n              handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            } else {\n              showPrompt(cm, {\n                  onClose: onPromptClose,\n                  prefix: promptPrefix,\n                  desc: '(JavaScript regexp)',\n                  onKeyUp: onPromptKeyUp,\n                  onKeyDown: onPromptKeyDown\n              });\n            }\n            break;\n          case 'wordUnderCursor':\n            var word = expandWordUnderCursor(cm, false /** inclusive */,\n                true /** forward */, false /** bigWord */,\n                true /** noSymbol */);\n            var isKeyword = true;\n            if (!word) {\n              word = expandWordUnderCursor(cm, false /** inclusive */,\n                  true /** forward */, false /** bigWord */,\n                  false /** noSymbol */);\n              isKeyword = false;\n            }\n            if (!word) {\n              return;\n            }\n            var query = cm.getLine(word.start.line).substring(word.start.ch,\n                word.end.ch);\n            if (isKeyword && wholeWordOnly) {\n                query = '\\\\b' + query + '\\\\b';\n            } else {\n              query = escapeRegex(query);\n            }\n\n            // cachedCursor is used to save the old position of the cursor\n            // when * or # causes vim to seek for the nearest word and shift\n            // the cursor before entering the motion.\n            vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n            cm.setCursor(word.start);\n\n            handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            break;\n        }\n      },\n      processEx: function(cm, vim, command) {\n        function onPromptClose(input) {\n          // Give the prompt some time to close so that if processCommand shows\n          // an error, the elements don't overlap.\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n          exCommandDispatcher.processCommand(cm, input);\n          clearInputState(cm);\n        }\n        function onPromptKeyDown(e, input, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && input == '')) {\n            vimGlobalState.exCommandHistoryController.pushInput(input);\n            vimGlobalState.exCommandHistoryController.reset();\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          }\n          if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n            close(input);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.exCommandHistoryController.reset();\n          }\n        }\n        if (command.type == 'keyToEx') {\n          // Handle user defined Ex to Ex mappings\n          exCommandDispatcher.processCommand(cm, command.exArgs.input);\n        } else {\n          if (vim.visualMode) {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':', value: '\\'<,\\'>',\n                onKeyDown: onPromptKeyDown, selectValueOnOpen: false});\n          } else {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':',\n                onKeyDown: onPromptKeyDown});\n          }\n        }\n      },\n      evalInput: function(cm, vim) {\n        // If the motion command is set, execute both the operator and motion.\n        // Otherwise return.\n        var inputState = vim.inputState;\n        var motion = inputState.motion;\n        var motionArgs = inputState.motionArgs || {};\n        var operator = inputState.operator;\n        var operatorArgs = inputState.operatorArgs || {};\n        var registerName = inputState.registerName;\n        var sel = vim.sel;\n        // TODO: Make sure cm and vim selections are identical outside visual mode.\n        var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head): cm.getCursor('head'));\n        var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n        var oldHead = copyCursor(origHead);\n        var oldAnchor = copyCursor(origAnchor);\n        var newHead, newAnchor;\n        var repeat;\n        if (operator) {\n          this.recordLastEdit(vim, inputState);\n        }\n        if (inputState.repeatOverride !== undefined) {\n          // If repeatOverride is specified, that takes precedence over the\n          // input state's repeat. Used by Ex mode and can be user defined.\n          repeat = inputState.repeatOverride;\n        } else {\n          repeat = inputState.getRepeat();\n        }\n        if (repeat > 0 && motionArgs.explicitRepeat) {\n          motionArgs.repeatIsExplicit = true;\n        } else if (motionArgs.noRepeat ||\n            (!motionArgs.explicitRepeat && repeat === 0)) {\n          repeat = 1;\n          motionArgs.repeatIsExplicit = false;\n        }\n        if (inputState.selectedCharacter) {\n          // If there is a character input, stick it in all of the arg arrays.\n          motionArgs.selectedCharacter = operatorArgs.selectedCharacter =\n              inputState.selectedCharacter;\n        }\n        motionArgs.repeat = repeat;\n        clearInputState(cm);\n        if (motion) {\n          var motionResult = motions[motion](cm, origHead, motionArgs, vim, inputState);\n          vim.lastMotion = motions[motion];\n          if (!motionResult) {\n            return;\n          }\n          if (motionArgs.toJumplist) {\n            var jumpList = vimGlobalState.jumpList;\n            // if the current motion is # or *, use cachedCursor\n            var cachedCursor = jumpList.cachedCursor;\n            if (cachedCursor) {\n              recordJumpPosition(cm, cachedCursor, motionResult);\n              delete jumpList.cachedCursor;\n            } else {\n              recordJumpPosition(cm, origHead, motionResult);\n            }\n          }\n          if (motionResult instanceof Array) {\n            newAnchor = motionResult[0];\n            newHead = motionResult[1];\n          } else {\n            newHead = motionResult;\n          }\n          // TODO: Handle null returns from motion commands better.\n          if (!newHead) {\n            newHead = copyCursor(origHead);\n          }\n          if (vim.visualMode) {\n            if (!(vim.visualBlock && newHead.ch === Infinity)) {\n              newHead = clipCursorToContent(cm, newHead);\n            }\n            if (newAnchor) {\n              newAnchor = clipCursorToContent(cm, newAnchor);\n            }\n            newAnchor = newAnchor || oldAnchor;\n            sel.anchor = newAnchor;\n            sel.head = newHead;\n            updateCmSelection(cm);\n            updateMark(cm, vim, '<',\n                cursorIsBefore(newAnchor, newHead) ? newAnchor\n                    : newHead);\n            updateMark(cm, vim, '>',\n                cursorIsBefore(newAnchor, newHead) ? newHead\n                    : newAnchor);\n          } else if (!operator) {\n            newHead = clipCursorToContent(cm, newHead);\n            cm.setCursor(newHead.line, newHead.ch);\n          }\n        }\n        if (operator) {\n          if (operatorArgs.lastSel) {\n            // Replaying a visual mode operation\n            newAnchor = oldAnchor;\n            var lastSel = operatorArgs.lastSel;\n            var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n            var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n            if (lastSel.visualLine) {\n              // Linewise Visual mode: The same number of lines.\n              newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            } else if (lastSel.visualBlock) {\n              // Blockwise Visual mode: The same number of lines and columns.\n              newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n            } else if (lastSel.head.line == lastSel.anchor.line) {\n              // Normal Visual mode within one line: The same number of characters.\n              newHead = new Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n            } else {\n              // Normal Visual mode with several lines: The same number of lines, in the\n              // last line the same number of characters as in the last line the last time.\n              newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            }\n            vim.visualMode = true;\n            vim.visualLine = lastSel.visualLine;\n            vim.visualBlock = lastSel.visualBlock;\n            sel = vim.sel = {\n              anchor: newAnchor,\n              head: newHead\n            };\n            updateCmSelection(cm);\n          } else if (vim.visualMode) {\n            operatorArgs.lastSel = {\n              anchor: copyCursor(sel.anchor),\n              head: copyCursor(sel.head),\n              visualBlock: vim.visualBlock,\n              visualLine: vim.visualLine\n            };\n          }\n          var curStart, curEnd, linewise, mode;\n          var cmSel;\n          if (vim.visualMode) {\n            // Init visual op\n            curStart = cursorMin(sel.head, sel.anchor);\n            curEnd = cursorMax(sel.head, sel.anchor);\n            linewise = vim.visualLine || operatorArgs.linewise;\n            mode = vim.visualBlock ? 'block' :\n                   linewise ? 'line' :\n                   'char';\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode);\n            if (linewise) {\n              var ranges = cmSel.ranges;\n              if (mode == 'block') {\n                // Linewise operators in visual block mode extend to end of line\n                for (var i = 0; i < ranges.length; i++) {\n                  ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n                }\n              } else if (mode == 'line') {\n                ranges[0].head = new Pos(ranges[0].head.line + 1, 0);\n              }\n            }\n          } else {\n            // Init motion op\n            curStart = copyCursor(newAnchor || oldAnchor);\n            curEnd = copyCursor(newHead || oldHead);\n            if (cursorIsBefore(curEnd, curStart)) {\n              var tmp = curStart;\n              curStart = curEnd;\n              curEnd = tmp;\n            }\n            linewise = motionArgs.linewise || operatorArgs.linewise;\n            if (linewise) {\n              // Expand selection to entire line.\n              expandSelectionToLine(cm, curStart, curEnd);\n            } else if (motionArgs.forward) {\n              // Clip to trailing newlines only if the motion goes forward.\n              clipToLine(cm, curStart, curEnd);\n            }\n            mode = 'char';\n            var exclusive = !motionArgs.inclusive || linewise;\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode, exclusive);\n          }\n          cm.setSelections(cmSel.ranges, cmSel.primary);\n          vim.lastMotion = null;\n          operatorArgs.repeat = repeat; // For indent in visual mode.\n          operatorArgs.registerName = registerName;\n          // Keep track of linewise as it affects how paste and change behave.\n          operatorArgs.linewise = linewise;\n          var operatorMoveTo = operators[operator](\n            cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n          if (vim.visualMode) {\n            exitVisualMode(cm, operatorMoveTo != null);\n          }\n          if (operatorMoveTo) {\n            cm.setCursor(operatorMoveTo);\n          }\n        }\n      },\n      recordLastEdit: function(vim, inputState, actionCommand) {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        vim.lastEditInputState = inputState;\n        vim.lastEditActionCommand = actionCommand;\n        macroModeState.lastInsertModeChanges.changes = [];\n        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n        macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;\n      }\n    };\n\n    /**\n     * typedef {Object{line:number,ch:number}} Cursor An object containing the\n     *     position of the cursor.\n     */\n    // All of the functions below return Cursor objects.\n    var motions = {\n      moveToTopLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).top + motionArgs.repeat -1;\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToMiddleLine: function(cm) {\n        var range = getUserVisibleLines(cm);\n        var line = Math.floor((range.top + range.bottom) * 0.5);\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToBottomLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat +1;\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      expandToLine: function(_cm, head, motionArgs) {\n        // Expands forward to end of line, and then to next line if repeat is\n        // >1. Does not handle backward motion!\n        var cur = head;\n        return new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      },\n      findNext: function(cm, _head, motionArgs) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        if (!query) {\n          return;\n        }\n        var prev = !motionArgs.forward;\n        // If search is initiated with ? instead of /, negate direction.\n        prev = (state.isReversed()) ? !prev : prev;\n        highlightSearchMatches(cm, query);\n        return findNext(cm, prev/** prev */, query, motionArgs.repeat);\n      },\n      /**\n       * Find and select the next occurrence of the search query. If the cursor is currently\n       * within a match, then find and select the current match. Otherwise, find the next occurrence in the\n       * appropriate direction.\n       *\n       * This differs from `findNext` in the following ways:\n       *\n       * 1. Instead of only returning the \"from\", this returns a \"from\", \"to\" range.\n       * 2. If the cursor is currently inside a search match, this selects the current match\n       *    instead of the next match.\n       * 3. If there is no associated operator, this will turn on visual mode.\n       */\n      findAndSelectNextInclusive: function(cm, _head, motionArgs, vim, prevInputState) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n\n        if (!query) {\n          return;\n        }\n\n        var prev = !motionArgs.forward;\n        prev = (state.isReversed()) ? !prev : prev;\n\n        // next: [from, to] | null\n        var next = findNextFromAndToInclusive(cm, prev, query, motionArgs.repeat, vim);\n\n        // No matches.\n        if (!next) {\n          return;\n        }\n\n        // If there's an operator that will be executed, return the selection.\n        if (prevInputState.operator) {\n          return next;\n        }\n\n        // At this point, we know that there is no accompanying operator -- let's\n        // deal with visual mode in order to select an appropriate match.\n\n        var from = next[0];\n        // For whatever reason, when we use the \"to\" as returned by searchcursor.js directly,\n        // the resulting selection is extended by 1 char. Let's shrink it so that only the\n        // match is selected.\n        var to = new Pos(next[1].line, next[1].ch - 1);\n\n        if (vim.visualMode) {\n          // If we were in visualLine or visualBlock mode, get out of it.\n          if (vim.visualLine || vim.visualBlock) {\n            vim.visualLine = false;\n            vim.visualBlock = false;\n            CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: \"\"});\n          }\n\n          // If we're currently in visual mode, we should extend the selection to include\n          // the search result.\n          var anchor = vim.sel.anchor;\n          if (anchor) {\n            if (state.isReversed()) {\n              if (motionArgs.forward) {\n                return [anchor, from];\n              }\n\n              return [anchor, to];\n            } else {\n              if (motionArgs.forward) {\n                return [anchor, to];\n              }\n\n              return [anchor, from];\n            }\n          }\n        } else {\n          // Let's turn visual mode on.\n          vim.visualMode = true;\n          vim.visualLine = false;\n          vim.visualBlock = false;\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: \"\"});\n        }\n\n        return prev ? [to, from] : [from, to];\n      },\n      goToMark: function(cm, _head, motionArgs, vim) {\n        var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n        if (pos) {\n          return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;\n        }\n        return null;\n      },\n      moveToOtherHighlightedEnd: function(cm, _head, motionArgs, vim) {\n        if (vim.visualBlock && motionArgs.sameLine) {\n          var sel = vim.sel;\n          return [\n            clipCursorToContent(cm, new Pos(sel.anchor.line, sel.head.ch)),\n            clipCursorToContent(cm, new Pos(sel.head.line, sel.anchor.ch))\n          ];\n        } else {\n          return ([vim.sel.head, vim.sel.anchor]);\n        }\n      },\n      jumpToMark: function(cm, head, motionArgs, vim) {\n        var best = head;\n        for (var i = 0; i < motionArgs.repeat; i++) {\n          var cursor = best;\n          for (var key in vim.marks) {\n            if (!isLowerCase(key)) {\n              continue;\n            }\n            var mark = vim.marks[key].find();\n            var isWrongDirection = (motionArgs.forward) ?\n              cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n\n            if (isWrongDirection) {\n              continue;\n            }\n            if (motionArgs.linewise && (mark.line == cursor.line)) {\n              continue;\n            }\n\n            var equal = cursorEqual(cursor, best);\n            var between = (motionArgs.forward) ?\n              cursorIsBetween(cursor, mark, best) :\n              cursorIsBetween(best, mark, cursor);\n\n            if (equal || between) {\n              best = mark;\n            }\n          }\n        }\n\n        if (motionArgs.linewise) {\n          // Vim places the cursor on the first non-whitespace character of\n          // the line if there is one, else it places the cursor at the end\n          // of the line, regardless of whether a mark was found.\n          best = new Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n        }\n        return best;\n      },\n      moveByCharacters: function(_cm, head, motionArgs) {\n        var cur = head;\n        var repeat = motionArgs.repeat;\n        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n        return new Pos(cur.line, ch);\n      },\n      moveByLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        var endCh = cur.ch;\n        // Depending what our last motion was, we may want to do different\n        // things. If our last motion was moving vertically, we want to\n        // preserve the HPos from our last horizontal move.  If our last motion\n        // was going to the end of a line, moving vertically we should go to\n        // the end of the line, etc.\n        switch (vim.lastMotion) {\n          case this.moveByLines:\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveToColumn:\n          case this.moveToEol:\n            endCh = vim.lastHPos;\n            break;\n          default:\n            vim.lastHPos = endCh;\n        }\n        var repeat = motionArgs.repeat+(motionArgs.repeatOffset||0);\n        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n        var first = cm.firstLine();\n        var last = cm.lastLine();\n        var posV = cm.findPosV(cur, (motionArgs.forward ? repeat : -repeat), 'line', vim.lastHSPos);\n        var hasMarkedText = motionArgs.forward ? posV.line > line : posV.line < line;\n        if (hasMarkedText) {\n          line = posV.line;\n          endCh = posV.ch;\n        }\n        // Vim go to line begin or line end when cursor at first/last line and\n        // move to previous/next line is triggered.\n        if (line < first && cur.line == first){\n          return this.moveToStartOfLine(cm, head, motionArgs, vim);\n        } else if (line > last && cur.line == last){\n            return moveToEol(cm, head, motionArgs, vim, true);\n        }\n        if (motionArgs.toFirstChar){\n          endCh=findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n          vim.lastHPos = endCh;\n        }\n        vim.lastHSPos = cm.charCoords(new Pos(line, endCh),'div').left;\n        return new Pos(line, endCh);\n      },\n      moveByDisplayLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        switch (vim.lastMotion) {\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveByLines:\n          case this.moveToColumn:\n          case this.moveToEol:\n            break;\n          default:\n            vim.lastHSPos = cm.charCoords(cur,'div').left;\n        }\n        var repeat = motionArgs.repeat;\n        var res=cm.findPosV(cur,(motionArgs.forward ? repeat : -repeat),'line',vim.lastHSPos);\n        if (res.hitSide) {\n          if (motionArgs.forward) {\n            var lastCharCoords = cm.charCoords(res, 'div');\n            var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };\n            var res = cm.coordsChar(goalCoords, 'div');\n          } else {\n            var resCoords = cm.charCoords(new Pos(cm.firstLine(), 0), 'div');\n            resCoords.left = vim.lastHSPos;\n            res = cm.coordsChar(resCoords, 'div');\n          }\n        }\n        vim.lastHPos = res.ch;\n        return res;\n      },\n      moveByPage: function(cm, head, motionArgs) {\n        // CodeMirror only exposes functions that move the cursor page down, so\n        // doing this bad hack to move the cursor and move it back. evalInput\n        // will move the cursor to where it should be in the end.\n        var curStart = head;\n        var repeat = motionArgs.repeat;\n        return cm.findPosV(curStart, (motionArgs.forward ? repeat : -repeat), 'page');\n      },\n      moveByParagraph: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findParagraph(cm, head, motionArgs.repeat, dir);\n      },\n      moveBySentence: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findSentence(cm, head, motionArgs.repeat, dir);\n      },\n      moveByScroll: function(cm, head, motionArgs, vim) {\n        var scrollbox = cm.getScrollInfo();\n        var curEnd = null;\n        var repeat = motionArgs.repeat;\n        if (!repeat) {\n          repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n        }\n        var orig = cm.charCoords(head, 'local');\n        motionArgs.repeat = repeat;\n        curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n        if (!curEnd) {\n          return null;\n        }\n        var dest = cm.charCoords(curEnd, 'local');\n        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n        return curEnd;\n      },\n      moveByWords: function(cm, head, motionArgs) {\n        return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward,\n            !!motionArgs.wordEnd, !!motionArgs.bigWord);\n      },\n      moveTillCharacter: function(cm, _head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        var curEnd = moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter);\n        var increment = motionArgs.forward ? -1 : 1;\n        recordLastCharacterSearch(increment, motionArgs);\n        if (!curEnd) return null;\n        curEnd.ch += increment;\n        return curEnd;\n      },\n      moveToCharacter: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        recordLastCharacterSearch(0, motionArgs);\n        return moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToSymbol: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        return findSymbol(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToColumn: function(cm, head, motionArgs, vim) {\n        var repeat = motionArgs.repeat;\n        // repeat is equivalent to which column we want to move to!\n        vim.lastHPos = repeat - 1;\n        vim.lastHSPos = cm.charCoords(head,'div').left;\n        return moveToColumn(cm, repeat);\n      },\n      moveToEol: function(cm, head, motionArgs, vim) {\n        return moveToEol(cm, head, motionArgs, vim, false);\n      },\n      moveToFirstNonWhiteSpaceCharacter: function(cm, head) {\n        // Go to the start of the line where the text begins, or the end for\n        // whitespace-only lines\n        var cursor = head;\n        return new Pos(cursor.line,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n      },\n      moveToMatchedSymbol: function(cm, head) {\n        var cursor = head;\n        var line = cursor.line;\n        var ch = cursor.ch;\n        var lineText = cm.getLine(line);\n        var symbol;\n        for (; ch < lineText.length; ch++) {\n          symbol = lineText.charAt(ch);\n          if (symbol && isMatchableSymbol(symbol)) {\n            var style = cm.getTokenTypeAt(new Pos(line, ch + 1));\n            if (style !== \"string\" && style !== \"comment\") {\n              break;\n            }\n          }\n        }\n        if (ch < lineText.length) {\n          // Only include angle brackets in analysis if they are being matched.\n          var re = (ch === '<' || ch === '>') ? /[(){}[\\]<>]/ : /[(){}[\\]]/;\n          var matched = cm.findMatchingBracket(new Pos(line, ch), {bracketRegex: re});\n          return matched.to;\n        } else {\n          return cursor;\n        }\n      },\n      moveToStartOfLine: function(_cm, head) {\n        return new Pos(head.line, 0);\n      },\n      moveToLineOrEdgeOfDocument: function(cm, _head, motionArgs) {\n        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n        if (motionArgs.repeatIsExplicit) {\n          lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n        }\n        return new Pos(lineNum,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n      },\n      moveToStartOfDisplayLine: function(cm) {\n        cm.execCommand(\"goLineLeft\");\n        return cm.getCursor();\n      },\n      moveToEndOfDisplayLine: function(cm) {\n        cm.execCommand(\"goLineRight\");\n        var head = cm.getCursor();\n        if (head.sticky == \"before\") head.ch--;\n        return head;\n      },\n      textObjectManipulation: function(cm, head, motionArgs, vim) {\n        // TODO: lots of possible exceptions that can be thrown here. Try da(\n        //     outside of a () block.\n        var mirroredPairs = {'(': ')', ')': '(',\n                             '{': '}', '}': '{',\n                             '[': ']', ']': '[',\n                             '<': '>', '>': '<'};\n        var selfPaired = {'\\'': true, '\"': true, '`': true};\n\n        var character = motionArgs.selectedCharacter;\n        // 'b' refers to  '()' block.\n        // 'B' refers to  '{}' block.\n        if (character == 'b') {\n          character = '(';\n        } else if (character == 'B') {\n          character = '{';\n        }\n\n        // Inclusive is the difference between a and i\n        // TODO: Instead of using the additional text object map to perform text\n        //     object operations, merge the map into the defaultKeyMap and use\n        //     motionArgs to define behavior. Define separate entries for 'aw',\n        //     'iw', 'a[', 'i[', etc.\n        var inclusive = !motionArgs.textObjectInner;\n\n        var tmp;\n        if (mirroredPairs[character]) {\n          tmp = selectCompanionObject(cm, head, character, inclusive);\n        } else if (selfPaired[character]) {\n          tmp = findBeginningAndEnd(cm, head, character, inclusive);\n        } else if (character === 'W') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     true /** bigWord */);\n        } else if (character === 'w') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     false /** bigWord */);\n        } else if (character === 'p') {\n          tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n          motionArgs.linewise = true;\n          if (vim.visualMode) {\n            if (!vim.visualLine) { vim.visualLine = true; }\n          } else {\n            var operatorArgs = vim.inputState.operatorArgs;\n            if (operatorArgs) { operatorArgs.linewise = true; }\n            tmp.end.line--;\n          }\n        } else if (character === 't') {\n          tmp = expandTagUnderCursor(cm, head, inclusive);\n        } else if (character === 's') {\n          // account for cursor on end of sentence symbol\n          var content = cm.getLine(head.line);\n          if (head.ch > 0 && isEndOfSentenceSymbol(content[head.ch])) {\n            head.ch -= 1;\n          }\n          var end = getSentence(cm, head, motionArgs.repeat, 1, inclusive);\n          var start = getSentence(cm, head, motionArgs.repeat, -1, inclusive);\n          // closer vim behaviour, 'a' only takes the space after the sentence if there is one before and after\n          if (isWhiteSpaceString(cm.getLine(start.line)[start.ch])\n              && isWhiteSpaceString(cm.getLine(end.line)[end.ch -1])) {\n            start = {line: start.line, ch: start.ch + 1};\n          }\n          tmp = {start: start, end: end};\n        } else {\n          // No text object defined for this, don't move.\n          return null;\n        }\n\n        if (!cm.state.vim.visualMode) {\n          return [tmp.start, tmp.end];\n        } else {\n          return expandSelection(cm, tmp.start, tmp.end);\n        }\n      },\n\n      repeatLastCharacterSearch: function(cm, head, motionArgs) {\n        var lastSearch = vimGlobalState.lastCharacterSearch;\n        var repeat = motionArgs.repeat;\n        var forward = motionArgs.forward === lastSearch.forward;\n        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n        cm.moveH(-increment, 'char');\n        motionArgs.inclusive = forward ? true : false;\n        var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n        if (!curEnd) {\n          cm.moveH(increment, 'char');\n          return head;\n        }\n        curEnd.ch += increment;\n        return curEnd;\n      }\n    };\n\n    function defineMotion(name, fn) {\n      motions[name] = fn;\n    }\n\n    function fillArray(val, times) {\n      var arr = [];\n      for (var i = 0; i < times; i++) {\n        arr.push(val);\n      }\n      return arr;\n    }\n    /**\n     * An operator acts on a text selection. It receives the list of selections\n     * as input. The corresponding CodeMirror selection is guaranteed to\n    * match the input selection.\n     */\n    var operators = {\n      change: function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        var anchor = ranges[0].anchor,\n            head = ranges[0].head;\n        if (!vim.visualMode) {\n          text = cm.getRange(anchor, head);\n          var lastState = vim.lastEditInputState || {};\n          if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n            // Exclude trailing whitespace if the range is not all whitespace.\n            var match = (/\\s+$/).exec(text);\n            if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n              head = offsetCursor(head, 0, - match[0].length);\n              text = text.slice(0, - match[0].length);\n            }\n          }\n          var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);\n          var wasLastLine = cm.firstLine() == cm.lastLine();\n          if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {\n            cm.replaceRange('', prevLineEnd, head);\n          } else {\n            cm.replaceRange('', anchor, head);\n          }\n          if (args.linewise) {\n            // Push the next line back down, if there is a next line.\n            if (!wasLastLine) {\n              cm.setCursor(prevLineEnd);\n              CodeMirror.commands.newlineAndIndent(cm);\n            }\n            // make sure cursor ends up at the end of the line.\n            anchor.ch = Number.MAX_VALUE;\n          }\n          finalHead = anchor;\n        } else if (args.fullLine) {\n            head.ch = Number.MAX_VALUE;\n            head.line--;\n            cm.setSelection(anchor, head);\n            text = cm.getSelection();\n            cm.replaceSelection(\"\");\n            finalHead = anchor;\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'change', text,\n            args.linewise, ranges.length > 1);\n        actions.enterInsertMode(cm, {head: finalHead}, cm.state.vim);\n      },\n      // delete is a javascript keyword.\n      'delete': function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        if (!vim.visualBlock) {\n          var anchor = ranges[0].anchor,\n              head = ranges[0].head;\n          if (args.linewise &&\n              head.line != cm.firstLine() &&\n              anchor.line == cm.lastLine() &&\n              anchor.line == head.line - 1) {\n            // Special case for dd on last line (and first line).\n            if (anchor.line == cm.firstLine()) {\n              anchor.ch = 0;\n            } else {\n              anchor = new Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n            }\n          }\n          text = cm.getRange(anchor, head);\n          cm.replaceRange('', anchor, head);\n          finalHead = anchor;\n          if (args.linewise) {\n            finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n          }\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'delete', text,\n            args.linewise, vim.visualBlock);\n        return clipCursorToContent(cm, finalHead);\n      },\n      indent: function(cm, args, ranges) {\n        var vim = cm.state.vim;\n        if (cm.indentMore) {\n          var repeat = (vim.visualMode) ? args.repeat : 1;\n          for (var j = 0; j < repeat; j++) {\n            if (args.indentRight) cm.indentMore();\n            else cm.indentLess();\n          }\n        } else {\n          var startLine = ranges[0].anchor.line;\n          var endLine = vim.visualBlock ?\n            ranges[ranges.length - 1].anchor.line :\n            ranges[0].head.line;\n          // In visual mode, n> shifts the selection right n times, instead of\n          // shifting n lines right once.\n          var repeat = (vim.visualMode) ? args.repeat : 1;\n          if (args.linewise) {\n            // The only way to delete a newline is to delete until the start of\n            // the next line, so in linewise mode evalInput will include the next\n            // line. We don't want this in indent, so we go back a line.\n            endLine--;\n          }\n          for (var i = startLine; i <= endLine; i++) {\n            for (var j = 0; j < repeat; j++) {\n              cm.indentLine(i, args.indentRight);\n            }\n          }\n        }\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      indentAuto: function(cm, _args, ranges) {\n        cm.execCommand(\"indentAuto\");\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      changeCase: function(cm, args, ranges, oldAnchor, newHead) {\n        var selections = cm.getSelections();\n        var swapped = [];\n        var toLower = args.toLower;\n        for (var j = 0; j < selections.length; j++) {\n          var toSwap = selections[j];\n          var text = '';\n          if (toLower === true) {\n            text = toSwap.toLowerCase();\n          } else if (toLower === false) {\n            text = toSwap.toUpperCase();\n          } else {\n            for (var i = 0; i < toSwap.length; i++) {\n              var character = toSwap.charAt(i);\n              text += isUpperCase(character) ? character.toLowerCase() :\n                  character.toUpperCase();\n            }\n          }\n          swapped.push(text);\n        }\n        cm.replaceSelections(swapped);\n        if (args.shouldMoveCursor){\n          return newHead;\n        } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n          return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n        } else if (args.linewise){\n          return oldAnchor;\n        } else {\n          return cursorMin(ranges[0].anchor, ranges[0].head);\n        }\n      },\n      yank: function(cm, args, ranges, oldAnchor) {\n        var vim = cm.state.vim;\n        var text = cm.getSelection();\n        var endPos = vim.visualMode\n          ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor)\n          : oldAnchor;\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'yank',\n            text, args.linewise, vim.visualBlock);\n        return endPos;\n      }\n    };\n\n    function defineOperator(name, fn) {\n      operators[name] = fn;\n    }\n\n    var actions = {\n      jumpListWalk: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat;\n        var forward = actionArgs.forward;\n        var jumpList = vimGlobalState.jumpList;\n\n        var mark = jumpList.move(cm, forward ? repeat : -repeat);\n        var markPos = mark ? mark.find() : undefined;\n        markPos = markPos ? markPos : cm.getCursor();\n        cm.setCursor(markPos);\n      },\n      scroll: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat || 1;\n        var lineHeight = cm.defaultTextHeight();\n        var top = cm.getScrollInfo().top;\n        var delta = lineHeight * repeat;\n        var newPos = actionArgs.forward ? top + delta : top - delta;\n        var cursor = copyCursor(cm.getCursor());\n        var cursorCoords = cm.charCoords(cursor, 'local');\n        if (actionArgs.forward) {\n          if (newPos > cursorCoords.top) {\n             cursor.line += (newPos - cursorCoords.top) / lineHeight;\n             cursor.line = Math.ceil(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(null, cursorCoords.top);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        } else {\n          var newBottom = newPos + cm.getScrollInfo().clientHeight;\n          if (newBottom < cursorCoords.bottom) {\n             cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n             cursor.line = Math.floor(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(\n                 null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        }\n      },\n      scrollToCursor: function(cm, actionArgs) {\n        var lineNum = cm.getCursor().line;\n        var charCoords = cm.charCoords(new Pos(lineNum, 0), 'local');\n        var height = cm.getScrollInfo().clientHeight;\n        var y = charCoords.top;\n        switch (actionArgs.position) {\n          case 'center': y = charCoords.bottom - height / 2;\n            break;\n          case 'bottom':\n            var lineLastCharPos = new Pos(lineNum, cm.getLine(lineNum).length - 1);\n            var lineLastCharCoords = cm.charCoords(lineLastCharPos, 'local');\n            var lineHeight = lineLastCharCoords.bottom - y;\n            y = y - height + lineHeight;\n            break;\n        }\n        cm.scrollTo(null, y);\n      },\n      replayMacro: function(cm, actionArgs, vim) {\n        var registerName = actionArgs.selectedCharacter;\n        var repeat = actionArgs.repeat;\n        var macroModeState = vimGlobalState.macroModeState;\n        if (registerName == '@') {\n          registerName = macroModeState.latestRegister;\n        } else {\n          macroModeState.latestRegister = registerName;\n        }\n        while(repeat--){\n          executeMacroRegister(cm, vim, macroModeState, registerName);\n        }\n      },\n      enterMacroRecordMode: function(cm, actionArgs) {\n        var macroModeState = vimGlobalState.macroModeState;\n        var registerName = actionArgs.selectedCharacter;\n        if (vimGlobalState.registerController.isValidRegister(registerName)) {\n          macroModeState.enterMacroRecordMode(cm, registerName);\n        }\n      },\n      toggleOverwrite: function(cm) {\n        if (!cm.state.overwrite) {\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n      },\n      enterInsertMode: function(cm, actionArgs, vim) {\n        if (cm.getOption('readOnly')) { return; }\n        vim.insertMode = true;\n        vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n        var insertAt = (actionArgs) ? actionArgs.insertAt : null;\n        var sel = vim.sel;\n        var head = actionArgs.head || cm.getCursor('head');\n        var height = cm.listSelections().length;\n        if (insertAt == 'eol') {\n          head = new Pos(head.line, lineLength(cm, head.line));\n        } else if (insertAt == 'bol') {\n          head = new Pos(head.line, 0);\n        } else if (insertAt == 'charAfter') {\n          head = offsetCursor(head, 0, 1);\n        } else if (insertAt == 'firstNonBlank') {\n          head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head);\n        } else if (insertAt == 'startOfSelectedArea') {\n          if (!vim.visualMode)\n              return;\n          if (!vim.visualBlock) {\n            if (sel.head.line < sel.anchor.line) {\n              head = sel.head;\n            } else {\n              head = new Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = new Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.min(sel.head.ch, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'endOfSelectedArea') {\n            if (!vim.visualMode)\n              return;\n          if (!vim.visualBlock) {\n            if (sel.head.line >= sel.anchor.line) {\n              head = offsetCursor(sel.head, 0, 1);\n            } else {\n              head = new Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = new Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.max(sel.head.ch, sel.anchor.ch) + 1);\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'inplace') {\n          if (vim.visualMode){\n            return;\n          }\n        } else if (insertAt == 'lastEdit') {\n          head = getLastEditPos(cm) || head;\n        }\n        cm.setOption('disableInput', false);\n        if (actionArgs && actionArgs.replace) {\n          // Handle Replace-mode as a special case of insert mode.\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n        if (!vimGlobalState.macroModeState.isPlaying) {\n          // Only record if not replaying.\n          cm.on('change', onChange);\n          CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        selectForInsert(cm, head, height);\n      },\n      toggleVisualMode: function(cm, actionArgs, vim) {\n        var repeat = actionArgs.repeat;\n        var anchor = cm.getCursor();\n        var head;\n        // TODO: The repeat should actually select number of characters/lines\n        //     equal to the repeat times the size of the previous visual\n        //     operation.\n        if (!vim.visualMode) {\n          // Entering visual mode\n          vim.visualMode = true;\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          head = clipCursorToContent(\n              cm, new Pos(anchor.line, anchor.ch + repeat - 1));\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n        } else if (vim.visualLine ^ actionArgs.linewise ||\n            vim.visualBlock ^ actionArgs.blockwise) {\n          // Toggling between modes\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n        } else {\n          exitVisualMode(cm);\n        }\n      },\n      reselectLastSelection: function(cm, _actionArgs, vim) {\n        var lastSelection = vim.lastSelection;\n        if (vim.visualMode) {\n          updateLastSelection(cm, vim);\n        }\n        if (lastSelection) {\n          var anchor = lastSelection.anchorMark.find();\n          var head = lastSelection.headMark.find();\n          if (!anchor || !head) {\n            // If the marks have been destroyed due to edits, do nothing.\n            return;\n          }\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          vim.visualMode = true;\n          vim.visualLine = lastSelection.visualLine;\n          vim.visualBlock = lastSelection.visualBlock;\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n          CodeMirror.signal(cm, 'vim-mode-change', {\n            mode: 'visual',\n            subMode: vim.visualLine ? 'linewise' :\n                     vim.visualBlock ? 'blockwise' : ''});\n        }\n      },\n      joinLines: function(cm, actionArgs, vim) {\n        var curStart, curEnd;\n        if (vim.visualMode) {\n          curStart = cm.getCursor('anchor');\n          curEnd = cm.getCursor('head');\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curEnd;\n            curEnd = curStart;\n            curStart = tmp;\n          }\n          curEnd.ch = lineLength(cm, curEnd.line) - 1;\n        } else {\n          // Repeat is the number of lines to join. Minimum 2 lines.\n          var repeat = Math.max(actionArgs.repeat, 2);\n          curStart = cm.getCursor();\n          curEnd = clipCursorToContent(cm, new Pos(curStart.line + repeat - 1,\n                                               Infinity));\n        }\n        var finalCh = 0;\n        for (var i = curStart.line; i < curEnd.line; i++) {\n          finalCh = lineLength(cm, curStart.line);\n          var tmp = new Pos(curStart.line + 1,\n                        lineLength(cm, curStart.line + 1));\n          var text = cm.getRange(curStart, tmp);\n          text = actionArgs.keepSpaces\n            ? text.replace(/\\n\\r?/g, '')\n            : text.replace(/\\n\\s*/g, ' ');\n          cm.replaceRange(text, curStart, tmp);\n        }\n        var curFinalPos = new Pos(curStart.line, finalCh);\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curFinalPos);\n      },\n      newLineAndEnterInsertMode: function(cm, actionArgs, vim) {\n        vim.insertMode = true;\n        var insertAt = copyCursor(cm.getCursor());\n        if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n          // Special case for inserting newline before start of document.\n          cm.replaceRange('\\n', new Pos(cm.firstLine(), 0));\n          cm.setCursor(cm.firstLine(), 0);\n        } else {\n          insertAt.line = (actionArgs.after) ? insertAt.line :\n              insertAt.line - 1;\n          insertAt.ch = lineLength(cm, insertAt.line);\n          cm.setCursor(insertAt);\n          var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment ||\n              CodeMirror.commands.newlineAndIndent;\n          newlineFn(cm);\n        }\n        this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);\n      },\n      paste: function(cm, actionArgs, vim) {\n        var cur = copyCursor(cm.getCursor());\n        var register = vimGlobalState.registerController.getRegister(\n            actionArgs.registerName);\n        var text = register.toString();\n        if (!text) {\n          return;\n        }\n        if (actionArgs.matchIndent) {\n          var tabSize = cm.getOption(\"tabSize\");\n          // length that considers tabs and tabSize\n          var whitespaceLength = function(str) {\n            var tabs = (str.split(\"\\t\").length - 1);\n            var spaces = (str.split(\" \").length - 1);\n            return tabs * tabSize + spaces * 1;\n          };\n          var currentLine = cm.getLine(cm.getCursor().line);\n          var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n          // chomp last newline b/c don't want it to match /^\\s*/gm\n          var chompedText = text.replace(/\\n$/, '');\n          var wasChomped = text !== chompedText;\n          var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n          var text = chompedText.replace(/^\\s*/gm, function(wspace) {\n            var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n            if (newIndent < 0) {\n              return \"\";\n            }\n            else if (cm.getOption(\"indentWithTabs\")) {\n              var quotient = Math.floor(newIndent / tabSize);\n              return Array(quotient + 1).join('\\t');\n            }\n            else {\n              return Array(newIndent + 1).join(' ');\n            }\n          });\n          text += wasChomped ? \"\\n\" : \"\";\n        }\n        if (actionArgs.repeat > 1) {\n          var text = Array(actionArgs.repeat + 1).join(text);\n        }\n        var linewise = register.linewise;\n        var blockwise = register.blockwise;\n        if (blockwise) {\n          text = text.split('\\n');\n          if (linewise) {\n              text.pop();\n          }\n          for (var i = 0; i < text.length; i++) {\n            text[i] = (text[i] == '') ? ' ' : text[i];\n          }\n          cur.ch += actionArgs.after ? 1 : 0;\n          cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);\n        } else if (linewise) {\n          if(vim.visualMode) {\n            text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n          } else if (actionArgs.after) {\n            // Move the newline at the end to the start instead, and paste just\n            // before the newline character of the line we are on right now.\n            text = '\\n' + text.slice(0, text.length - 1);\n            cur.ch = lineLength(cm, cur.line);\n          } else {\n            cur.ch = 0;\n          }\n        } else {\n          cur.ch += actionArgs.after ? 1 : 0;\n        }\n        var curPosFinal;\n        var idx;\n        if (vim.visualMode) {\n          //  save the pasted text for reselection if the need arises\n          vim.lastPastedText = text;\n          var lastSelectionCurEnd;\n          var selectedArea = getSelectedAreaRange(cm, vim);\n          var selectionStart = selectedArea[0];\n          var selectionEnd = selectedArea[1];\n          var selectedText = cm.getSelection();\n          var selections = cm.listSelections();\n          var emptyStrings = new Array(selections.length).join('1').split('1');\n          // save the curEnd marker before it get cleared due to cm.replaceRange.\n          if (vim.lastSelection) {\n            lastSelectionCurEnd = vim.lastSelection.headMark.find();\n          }\n          // push the previously selected text to unnamed register\n          vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n          if (blockwise) {\n            // first delete the selected text\n            cm.replaceSelections(emptyStrings);\n            // Set new selections as per the block length of the yanked text\n            selectionEnd = new Pos(selectionStart.line + text.length-1, selectionStart.ch);\n            cm.setCursor(selectionStart);\n            selectBlock(cm, selectionEnd);\n            cm.replaceSelections(text);\n            curPosFinal = selectionStart;\n          } else if (vim.visualBlock) {\n            cm.replaceSelections(emptyStrings);\n            cm.setCursor(selectionStart);\n            cm.replaceRange(text, selectionStart, selectionStart);\n            curPosFinal = selectionStart;\n          } else {\n            cm.replaceRange(text, selectionStart, selectionEnd);\n            curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n          }\n          // restore the the curEnd marker\n          if(lastSelectionCurEnd) {\n            vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n          }\n          if (linewise) {\n            curPosFinal.ch=0;\n          }\n        } else {\n          if (blockwise) {\n            cm.setCursor(cur);\n            for (var i = 0; i < text.length; i++) {\n              var line = cur.line+i;\n              if (line > cm.lastLine()) {\n                cm.replaceRange('\\n',  new Pos(line, 0));\n              }\n              var lastCh = lineLength(cm, line);\n              if (lastCh < cur.ch) {\n                extendLineToColumn(cm, line, cur.ch);\n              }\n            }\n            cm.setCursor(cur);\n            selectBlock(cm, new Pos(cur.line + text.length-1, cur.ch));\n            cm.replaceSelections(text);\n            curPosFinal = cur;\n          } else {\n            cm.replaceRange(text, cur);\n            // Now fine tune the cursor to where we want it.\n            if (linewise && actionArgs.after) {\n              curPosFinal = new Pos(\n              cur.line + 1,\n              findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));\n            } else if (linewise && !actionArgs.after) {\n              curPosFinal = new Pos(\n                cur.line,\n                findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));\n            } else if (!linewise && actionArgs.after) {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length - 1);\n            } else {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length);\n            }\n          }\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curPosFinal);\n      },\n      undo: function(cm, actionArgs) {\n        cm.operation(function() {\n          repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n          cm.setCursor(cm.getCursor('anchor'));\n        });\n      },\n      redo: function(cm, actionArgs) {\n        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n      },\n      setRegister: function(_cm, actionArgs, vim) {\n        vim.inputState.registerName = actionArgs.selectedCharacter;\n      },\n      setMark: function(cm, actionArgs, vim) {\n        var markName = actionArgs.selectedCharacter;\n        updateMark(cm, vim, markName, cm.getCursor());\n      },\n      replace: function(cm, actionArgs, vim) {\n        var replaceWith = actionArgs.selectedCharacter;\n        var curStart = cm.getCursor();\n        var replaceTo;\n        var curEnd;\n        var selections = cm.listSelections();\n        if (vim.visualMode) {\n          curStart = cm.getCursor('start');\n          curEnd = cm.getCursor('end');\n        } else {\n          var line = cm.getLine(curStart.line);\n          replaceTo = curStart.ch + actionArgs.repeat;\n          if (replaceTo > line.length) {\n            replaceTo=line.length;\n          }\n          curEnd = new Pos(curStart.line, replaceTo);\n        }\n        if (replaceWith=='\\n') {\n          if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);\n          // special case, where vim help says to replace by just one line-break\n          (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n        } else {\n          var replaceWithStr = cm.getRange(curStart, curEnd);\n          //replace all characters in range by selected, but keep linebreaks\n          replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n          if (vim.visualBlock) {\n            // Tabs are split in visua block before replacing\n            var spaces = new Array(cm.getOption(\"tabSize\")+1).join(' ');\n            replaceWithStr = cm.getSelection();\n            replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n            cm.replaceSelections(replaceWithStr);\n          } else {\n            cm.replaceRange(replaceWithStr, curStart, curEnd);\n          }\n          if (vim.visualMode) {\n            curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ?\n                         selections[0].anchor : selections[0].head;\n            cm.setCursor(curStart);\n            exitVisualMode(cm, false);\n          } else {\n            cm.setCursor(offsetCursor(curEnd, 0, -1));\n          }\n        }\n      },\n      incrementNumberToken: function(cm, actionArgs) {\n        var cur = cm.getCursor();\n        var lineStr = cm.getLine(cur.line);\n        var re = /(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;\n        var match;\n        var start;\n        var end;\n        var numberStr;\n        while ((match = re.exec(lineStr)) !== null) {\n          start = match.index;\n          end = start + match[0].length;\n          if (cur.ch < end)break;\n        }\n        if (!actionArgs.backtrack && (end <= cur.ch))return;\n        if (match) {\n          var baseStr = match[2] || match[4];\n          var digits = match[3] || match[5];\n          var increment = actionArgs.increase ? 1 : -1;\n          var base = {'0b': 2, '0': 8, '': 10, '0x': 16}[baseStr.toLowerCase()];\n          var number = parseInt(match[1] + digits, base) + (increment * actionArgs.repeat);\n          numberStr = number.toString(base);\n          var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : '';\n          if (numberStr.charAt(0) === '-') {\n            numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);\n          } else {\n            numberStr = baseStr + zeroPadding + numberStr;\n          }\n          var from = new Pos(cur.line, start);\n          var to = new Pos(cur.line, end);\n          cm.replaceRange(numberStr, from, to);\n        } else {\n          return;\n        }\n        cm.setCursor(new Pos(cur.line, start + numberStr.length - 1));\n      },\n      repeatLastEdit: function(cm, actionArgs, vim) {\n        var lastEditInputState = vim.lastEditInputState;\n        if (!lastEditInputState) { return; }\n        var repeat = actionArgs.repeat;\n        if (repeat && actionArgs.repeatIsExplicit) {\n          vim.lastEditInputState.repeatOverride = repeat;\n        } else {\n          repeat = vim.lastEditInputState.repeatOverride || repeat;\n        }\n        repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\n      },\n      indent: function(cm, actionArgs) {\n        cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n      },\n      exitInsertMode: exitInsertMode\n    };\n\n    function defineAction(name, fn) {\n      actions[name] = fn;\n    }\n\n    /*\n     * Below are miscellaneous utility functions used by vim.js\n     */\n\n    /**\n     * Clips cursor to ensure that line is within the buffer's range\n     * If includeLineBreak is true, then allow cur.ch == lineLength.\n     */\n    function clipCursorToContent(cm, cur) {\n      var vim = cm.state.vim;\n      var includeLineBreak = vim.insertMode || vim.visualMode;\n      var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine() );\n      var maxCh = lineLength(cm, line) - 1 + !!includeLineBreak;\n      var ch = Math.min(Math.max(0, cur.ch), maxCh);\n      return new Pos(line, ch);\n    }\n    function copyArgs(args) {\n      var ret = {};\n      for (var prop in args) {\n        if (args.hasOwnProperty(prop)) {\n          ret[prop] = args[prop];\n        }\n      }\n      return ret;\n    }\n    function offsetCursor(cur, offsetLine, offsetCh) {\n      if (typeof offsetLine === 'object') {\n        offsetCh = offsetLine.ch;\n        offsetLine = offsetLine.line;\n      }\n      return new Pos(cur.line + offsetLine, cur.ch + offsetCh);\n    }\n    function commandMatches(keys, keyMap, context, inputState) {\n      // Partial matches are not applied. They inform the key handler\n      // that the current key sequence is a subsequence of a valid key\n      // sequence, so that the key buffer is not cleared.\n      var match, partial = [], full = [];\n      for (var i = 0; i < keyMap.length; i++) {\n        var command = keyMap[i];\n        if (context == 'insert' && command.context != 'insert' ||\n            command.context && command.context != context ||\n            inputState.operator && command.type == 'action' ||\n            !(match = commandMatch(keys, command.keys))) { continue; }\n        if (match == 'partial') { partial.push(command); }\n        if (match == 'full') { full.push(command); }\n      }\n      return {\n        partial: partial.length && partial,\n        full: full.length && full\n      };\n    }\n    function commandMatch(pressed, mapped) {\n      if (mapped.slice(-11) == '<character>') {\n        // Last character matches anything.\n        var prefixLen = mapped.length - 11;\n        var pressedPrefix = pressed.slice(0, prefixLen);\n        var mappedPrefix = mapped.slice(0, prefixLen);\n        return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' :\n               mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n      } else {\n        return pressed == mapped ? 'full' :\n               mapped.indexOf(pressed) == 0 ? 'partial' : false;\n      }\n    }\n    function lastChar(keys) {\n      var match = /^.*(<[^>]+>)$/.exec(keys);\n      var selectedCharacter = match ? match[1] : keys.slice(-1);\n      if (selectedCharacter.length > 1){\n        switch(selectedCharacter){\n          case '<CR>':\n            selectedCharacter='\\n';\n            break;\n          case '<Space>':\n            selectedCharacter=' ';\n            break;\n          default:\n            selectedCharacter='';\n            break;\n        }\n      }\n      return selectedCharacter;\n    }\n    function repeatFn(cm, fn, repeat) {\n      return function() {\n        for (var i = 0; i < repeat; i++) {\n          fn(cm);\n        }\n      };\n    }\n    function copyCursor(cur) {\n      return new Pos(cur.line, cur.ch);\n    }\n    function cursorEqual(cur1, cur2) {\n      return cur1.ch == cur2.ch && cur1.line == cur2.line;\n    }\n    function cursorIsBefore(cur1, cur2) {\n      if (cur1.line < cur2.line) {\n        return true;\n      }\n      if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n        return true;\n      }\n      return false;\n    }\n    function cursorMin(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n    }\n    function cursorMax(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n    }\n    function cursorIsBetween(cur1, cur2, cur3) {\n      // returns true if cur2 is between cur1 and cur3.\n      var cur1before2 = cursorIsBefore(cur1, cur2);\n      var cur2before3 = cursorIsBefore(cur2, cur3);\n      return cur1before2 && cur2before3;\n    }\n    function lineLength(cm, lineNum) {\n      return cm.getLine(lineNum).length;\n    }\n    function trim(s) {\n      if (s.trim) {\n        return s.trim();\n      }\n      return s.replace(/^\\s+|\\s+$/g, '');\n    }\n    function escapeRegex(s) {\n      return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n    }\n    function extendLineToColumn(cm, lineNum, column) {\n      var endCh = lineLength(cm, lineNum);\n      var spaces = new Array(column-endCh+1).join(' ');\n      cm.setCursor(new Pos(lineNum, endCh));\n      cm.replaceRange(spaces, cm.getCursor());\n    }\n    // This functions selects a rectangular block\n    // of text with selectionEnd as any of its corner\n    // Height of block:\n    // Difference in selectionEnd.line and first/last selection.line\n    // Width of the block:\n    // Distance between selectionEnd.ch and any(first considered here) selection.ch\n    function selectBlock(cm, selectionEnd) {\n      var selections = [], ranges = cm.listSelections();\n      var head = copyCursor(cm.clipPos(selectionEnd));\n      var isClipped = !cursorEqual(selectionEnd, head);\n      var curHead = cm.getCursor('head');\n      var primIndex = getIndex(ranges, curHead);\n      var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n      var max = ranges.length - 1;\n      var index = max - primIndex > primIndex ? max : 0;\n      var base = ranges[index].anchor;\n\n      var firstLine = Math.min(base.line, head.line);\n      var lastLine = Math.max(base.line, head.line);\n      var baseCh = base.ch, headCh = head.ch;\n\n      var dir = ranges[index].head.ch - baseCh;\n      var newDir = headCh - baseCh;\n      if (dir > 0 && newDir <= 0) {\n        baseCh++;\n        if (!isClipped) { headCh--; }\n      } else if (dir < 0 && newDir >= 0) {\n        baseCh--;\n        if (!wasClipped) { headCh++; }\n      } else if (dir < 0 && newDir == -1) {\n        baseCh--;\n        headCh++;\n      }\n      for (var line = firstLine; line <= lastLine; line++) {\n        var range = {anchor: new Pos(line, baseCh), head: new Pos(line, headCh)};\n        selections.push(range);\n      }\n      cm.setSelections(selections);\n      selectionEnd.ch = headCh;\n      base.ch = baseCh;\n      return base;\n    }\n    function selectForInsert(cm, head, height) {\n      var sel = [];\n      for (var i = 0; i < height; i++) {\n        var lineHead = offsetCursor(head, i, 0);\n        sel.push({anchor: lineHead, head: lineHead});\n      }\n      cm.setSelections(sel, 0);\n    }\n    // getIndex returns the index of the cursor in the selections.\n    function getIndex(ranges, cursor, end) {\n      for (var i = 0; i < ranges.length; i++) {\n        var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n        var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n        if (atAnchor || atHead) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    function getSelectedAreaRange(cm, vim) {\n      var lastSelection = vim.lastSelection;\n      var getCurrentSelectedAreaRange = function() {\n        var selections = cm.listSelections();\n        var start =  selections[0];\n        var end = selections[selections.length-1];\n        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n        return [selectionStart, selectionEnd];\n      };\n      var getLastSelectedAreaRange = function() {\n        var selectionStart = cm.getCursor();\n        var selectionEnd = cm.getCursor();\n        var block = lastSelection.visualBlock;\n        if (block) {\n          var width = block.width;\n          var height = block.height;\n          selectionEnd = new Pos(selectionStart.line + height, selectionStart.ch + width);\n          var selections = [];\n          // selectBlock creates a 'proper' rectangular block.\n          // We do not want that in all cases, so we manually set selections.\n          for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n            var anchor = new Pos(i, selectionStart.ch);\n            var head = new Pos(i, selectionEnd.ch);\n            var range = {anchor: anchor, head: head};\n            selections.push(range);\n          }\n          cm.setSelections(selections);\n        } else {\n          var start = lastSelection.anchorMark.find();\n          var end = lastSelection.headMark.find();\n          var line = end.line - start.line;\n          var ch = end.ch - start.ch;\n          selectionEnd = {line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch};\n          if (lastSelection.visualLine) {\n            selectionStart = new Pos(selectionStart.line, 0);\n            selectionEnd = new Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n          }\n          cm.setSelection(selectionStart, selectionEnd);\n        }\n        return [selectionStart, selectionEnd];\n      };\n      if (!vim.visualMode) {\n      // In case of replaying the action.\n        return getLastSelectedAreaRange();\n      } else {\n        return getCurrentSelectedAreaRange();\n      }\n    }\n    // Updates the previous selection with the current selection's values. This\n    // should only be called in visual mode.\n    function updateLastSelection(cm, vim) {\n      var anchor = vim.sel.anchor;\n      var head = vim.sel.head;\n      // To accommodate the effect of lastPastedText in the last selection\n      if (vim.lastPastedText) {\n        head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n        vim.lastPastedText = null;\n      }\n      vim.lastSelection = {'anchorMark': cm.setBookmark(anchor),\n                           'headMark': cm.setBookmark(head),\n                           'anchor': copyCursor(anchor),\n                           'head': copyCursor(head),\n                           'visualMode': vim.visualMode,\n                           'visualLine': vim.visualLine,\n                           'visualBlock': vim.visualBlock};\n    }\n    function expandSelection(cm, start, end) {\n      var sel = cm.state.vim.sel;\n      var head = sel.head;\n      var anchor = sel.anchor;\n      var tmp;\n      if (cursorIsBefore(end, start)) {\n        tmp = end;\n        end = start;\n        start = tmp;\n      }\n      if (cursorIsBefore(head, anchor)) {\n        head = cursorMin(start, head);\n        anchor = cursorMax(anchor, end);\n      } else {\n        anchor = cursorMin(start, anchor);\n        head = cursorMax(head, end);\n        head = offsetCursor(head, 0, -1);\n        if (head.ch == -1 && head.line != cm.firstLine()) {\n          head = new Pos(head.line - 1, lineLength(cm, head.line - 1));\n        }\n      }\n      return [anchor, head];\n    }\n    /**\n     * Updates the CodeMirror selection to match the provided vim selection.\n     * If no arguments are given, it uses the current vim selection state.\n     */\n    function updateCmSelection(cm, sel, mode) {\n      var vim = cm.state.vim;\n      sel = sel || vim.sel;\n      var mode = mode ||\n        vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n      var cmSel = makeCmSelection(cm, sel, mode);\n      cm.setSelections(cmSel.ranges, cmSel.primary);\n    }\n    function makeCmSelection(cm, sel, mode, exclusive) {\n      var head = copyCursor(sel.head);\n      var anchor = copyCursor(sel.anchor);\n      if (mode == 'char') {\n        var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        head = offsetCursor(sel.head, 0, headOffset);\n        anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'line') {\n        if (!cursorIsBefore(sel.head, sel.anchor)) {\n          anchor.ch = 0;\n\n          var lastLine = cm.lastLine();\n          if (head.line > lastLine) {\n            head.line = lastLine;\n          }\n          head.ch = lineLength(cm, head.line);\n        } else {\n          head.ch = 0;\n          anchor.ch = lineLength(cm, anchor.line);\n        }\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'block') {\n        var top = Math.min(anchor.line, head.line),\n            fromCh = anchor.ch,\n            bottom = Math.max(anchor.line, head.line),\n            toCh = head.ch;\n        if (fromCh < toCh) { toCh += 1; }\n        else { fromCh += 1; }        var height = bottom - top + 1;\n        var primary = head.line == top ? 0 : height - 1;\n        var ranges = [];\n        for (var i = 0; i < height; i++) {\n          ranges.push({\n            anchor: new Pos(top + i, fromCh),\n            head: new Pos(top + i, toCh)\n          });\n        }\n        return {\n          ranges: ranges,\n          primary: primary\n        };\n      }\n    }\n    function getHead(cm) {\n      var cur = cm.getCursor('head');\n      if (cm.getSelection().length == 1) {\n        // Small corner case when only 1 character is selected. The \"real\"\n        // head is the left of head and anchor.\n        cur = cursorMin(cur, cm.getCursor('anchor'));\n      }\n      return cur;\n    }\n\n    /**\n     * If moveHead is set to false, the CodeMirror selection will not be\n     * touched. The caller assumes the responsibility of putting the cursor\n    * in the right place.\n     */\n    function exitVisualMode(cm, moveHead) {\n      var vim = cm.state.vim;\n      if (moveHead !== false) {\n        cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n      }\n      updateLastSelection(cm, vim);\n      vim.visualMode = false;\n      vim.visualLine = false;\n      vim.visualBlock = false;\n      if (!vim.insertMode) CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n    }\n\n    // Remove any trailing newlines from the selection. For\n    // example, with the caret at the start of the last word on the line,\n    // 'dw' should word, but not the newline, while 'w' should advance the\n    // caret to the first character of the next line.\n    function clipToLine(cm, curStart, curEnd) {\n      var selection = cm.getRange(curStart, curEnd);\n      // Only clip if the selection ends with trailing newline + whitespace\n      if (/\\n\\s*$/.test(selection)) {\n        var lines = selection.split('\\n');\n        // We know this is all whitespace.\n        lines.pop();\n\n        // Cases:\n        // 1. Last word is an empty line - do not clip the trailing '\\n'\n        // 2. Last word is not an empty line - clip the trailing '\\n'\n        var line;\n        // Find the line containing the last word, and clip all whitespace up\n        // to it.\n        for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n          curEnd.line--;\n          curEnd.ch = 0;\n        }\n        // If the last word is not an empty line, clip an additional newline\n        if (line) {\n          curEnd.line--;\n          curEnd.ch = lineLength(cm, curEnd.line);\n        } else {\n          curEnd.ch = 0;\n        }\n      }\n    }\n\n    // Expand the selection to line ends.\n    function expandSelectionToLine(_cm, curStart, curEnd) {\n      curStart.ch = 0;\n      curEnd.ch = 0;\n      curEnd.line++;\n    }\n\n    function findFirstNonWhiteSpaceCharacter(text) {\n      if (!text) {\n        return 0;\n      }\n      var firstNonWS = text.search(/\\S/);\n      return firstNonWS == -1 ? text.length : firstNonWS;\n    }\n\n    function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {\n      var cur = getHead(cm);\n      var line = cm.getLine(cur.line);\n      var idx = cur.ch;\n\n      // Seek to first word or non-whitespace character, depending on if\n      // noSymbol is true.\n      var test = noSymbol ? wordCharTest[0] : bigWordCharTest [0];\n      while (!test(line.charAt(idx))) {\n        idx++;\n        if (idx >= line.length) { return null; }\n      }\n\n      if (bigWord) {\n        test = bigWordCharTest[0];\n      } else {\n        test = wordCharTest[0];\n        if (!test(line.charAt(idx))) {\n          test = wordCharTest[1];\n        }\n      }\n\n      var end = idx, start = idx;\n      while (test(line.charAt(end)) && end < line.length) { end++; }\n      while (test(line.charAt(start)) && start >= 0) { start--; }\n      start++;\n\n      if (inclusive) {\n        // If present, include all whitespace after word.\n        // Otherwise, include all whitespace before word, except indentation.\n        var wordEnd = end;\n        while (/\\s/.test(line.charAt(end)) && end < line.length) { end++; }\n        if (wordEnd == end) {\n          var wordStart = start;\n          while (/\\s/.test(line.charAt(start - 1)) && start > 0) { start--; }\n          if (!start) { start = wordStart; }\n        }\n      }\n      return { start: new Pos(cur.line, start), end: new Pos(cur.line, end) };\n    }\n\n    /**\n     * Depends on the following:\n     *\n     * - editor mode should be htmlmixedmode / xml\n     * - mode/xml/xml.js should be loaded\n     * - addon/fold/xml-fold.js should be loaded\n     *\n     * If any of the above requirements are not true, this function noops.\n     *\n     * This is _NOT_ a 100% accurate implementation of vim tag text objects.\n     * The following caveats apply (based off cursory testing, I'm sure there\n     * are other discrepancies):\n     *\n     * - Does not work inside comments:\n     *   ```\n     *   <!-- <div>broken</div> -->\n     *   ```\n     * - Does not work when tags have different cases:\n     *   ```\n     *   <div>broken</DIV>\n     *   ```\n     * - Does not work when cursor is inside a broken tag:\n     *   ```\n     *   <div><brok><en></div>\n     *   ```\n     */\n    function expandTagUnderCursor(cm, head, inclusive) {\n      var cur = head;\n      if (!CodeMirror.findMatchingTag || !CodeMirror.findEnclosingTag) {\n        return { start: cur, end: cur };\n      }\n\n      var tags = CodeMirror.findMatchingTag(cm, head) || CodeMirror.findEnclosingTag(cm, head);\n      if (!tags || !tags.open || !tags.close) {\n        return { start: cur, end: cur };\n      }\n\n      if (inclusive) {\n        return { start: tags.open.from, end: tags.close.to };\n      }\n      return { start: tags.open.to, end: tags.close.from };\n    }\n\n    function recordJumpPosition(cm, oldCur, newCur) {\n      if (!cursorEqual(oldCur, newCur)) {\n        vimGlobalState.jumpList.add(cm, oldCur, newCur);\n      }\n    }\n\n    function recordLastCharacterSearch(increment, args) {\n        vimGlobalState.lastCharacterSearch.increment = increment;\n        vimGlobalState.lastCharacterSearch.forward = args.forward;\n        vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n    }\n\n    var symbolToMode = {\n        '(': 'bracket', ')': 'bracket', '{': 'bracket', '}': 'bracket',\n        '[': 'section', ']': 'section',\n        '*': 'comment', '/': 'comment',\n        'm': 'method', 'M': 'method',\n        '#': 'preprocess'\n    };\n    var findSymbolModes = {\n      bracket: {\n        isComplete: function(state) {\n          if (state.nextCh === state.symb) {\n            state.depth++;\n            if (state.depth >= 1)return true;\n          } else if (state.nextCh === state.reverseSymb) {\n            state.depth--;\n          }\n          return false;\n        }\n      },\n      section: {\n        init: function(state) {\n          state.curMoveThrough = true;\n          state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n        },\n        isComplete: function(state) {\n          return state.index === 0 && state.nextCh === state.symb;\n        }\n      },\n      comment: {\n        isComplete: function(state) {\n          var found = state.lastCh === '*' && state.nextCh === '/';\n          state.lastCh = state.nextCh;\n          return found;\n        }\n      },\n      // TODO: The original Vim implementation only operates on level 1 and 2.\n      // The current implementation doesn't check for code block level and\n      // therefore it operates on any levels.\n      method: {\n        init: function(state) {\n          state.symb = (state.symb === 'm' ? '{' : '}');\n          state.reverseSymb = state.symb === '{' ? '}' : '{';\n        },\n        isComplete: function(state) {\n          if (state.nextCh === state.symb)return true;\n          return false;\n        }\n      },\n      preprocess: {\n        init: function(state) {\n          state.index = 0;\n        },\n        isComplete: function(state) {\n          if (state.nextCh === '#') {\n            var token = state.lineText.match(/^#(\\w+)/)[1];\n            if (token === 'endif') {\n              if (state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth++;\n            } else if (token === 'if') {\n              if (!state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth--;\n            }\n            if (token === 'else' && state.depth === 0)return true;\n          }\n          return false;\n        }\n      }\n    };\n    function findSymbol(cm, repeat, forward, symb) {\n      var cur = copyCursor(cm.getCursor());\n      var increment = forward ? 1 : -1;\n      var endLine = forward ? cm.lineCount() : -1;\n      var curCh = cur.ch;\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      var state = {\n        lineText: lineText,\n        nextCh: lineText.charAt(curCh),\n        lastCh: null,\n        index: curCh,\n        symb: symb,\n        reverseSymb: (forward ?  { ')': '(', '}': '{' } : { '(': ')', '{': '}' })[symb],\n        forward: forward,\n        depth: 0,\n        curMoveThrough: false\n      };\n      var mode = symbolToMode[symb];\n      if (!mode)return cur;\n      var init = findSymbolModes[mode].init;\n      var isComplete = findSymbolModes[mode].isComplete;\n      if (init) { init(state); }\n      while (line !== endLine && repeat) {\n        state.index += increment;\n        state.nextCh = state.lineText.charAt(state.index);\n        if (!state.nextCh) {\n          line += increment;\n          state.lineText = cm.getLine(line) || '';\n          if (increment > 0) {\n            state.index = 0;\n          } else {\n            var lineLen = state.lineText.length;\n            state.index = (lineLen > 0) ? (lineLen-1) : 0;\n          }\n          state.nextCh = state.lineText.charAt(state.index);\n        }\n        if (isComplete(state)) {\n          cur.line = line;\n          cur.ch = state.index;\n          repeat--;\n        }\n      }\n      if (state.nextCh || state.curMoveThrough) {\n        return new Pos(line, state.index);\n      }\n      return cur;\n    }\n\n    /*\n     * Returns the boundaries of the next word. If the cursor in the middle of\n     * the word, then returns the boundaries of the current word, starting at\n     * the cursor. If the cursor is at the start/end of a word, and we are going\n     * forward/backward, respectively, find the boundaries of the next word.\n     *\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Cursor} cur The cursor position.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only [a-zA-Z0-9] characters count as part of the word.\n     * @param {boolean} emptyLineIsWord True if empty lines should be treated\n     *     as words.\n     * @return {Object{from:number, to:number, line: number}} The boundaries of\n     *     the word, or null if there are no more words.\n     */\n    function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n      var lineNum = cur.line;\n      var pos = cur.ch;\n      var line = cm.getLine(lineNum);\n      var dir = forward ? 1 : -1;\n      var charTests = bigWord ? bigWordCharTest: wordCharTest;\n\n      if (emptyLineIsWord && line == '') {\n        lineNum += dir;\n        line = cm.getLine(lineNum);\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        pos = (forward) ? 0 : line.length;\n      }\n\n      while (true) {\n        if (emptyLineIsWord && line == '') {\n          return { from: 0, to: 0, line: lineNum };\n        }\n        var stop = (dir > 0) ? line.length : -1;\n        var wordStart = stop, wordEnd = stop;\n        // Find bounds of next word.\n        while (pos != stop) {\n          var foundWord = false;\n          for (var i = 0; i < charTests.length && !foundWord; ++i) {\n            if (charTests[i](line.charAt(pos))) {\n              wordStart = pos;\n              // Advance to end of word.\n              while (pos != stop && charTests[i](line.charAt(pos))) {\n                pos += dir;\n              }\n              wordEnd = pos;\n              foundWord = wordStart != wordEnd;\n              if (wordStart == cur.ch && lineNum == cur.line &&\n                  wordEnd == wordStart + dir) {\n                // We started at the end of a word. Find the next one.\n                continue;\n              } else {\n                return {\n                  from: Math.min(wordStart, wordEnd + 1),\n                  to: Math.max(wordStart, wordEnd),\n                  line: lineNum };\n              }\n            }\n          }\n          if (!foundWord) {\n            pos += dir;\n          }\n        }\n        // Advance to next/prev line.\n        lineNum += dir;\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        line = cm.getLine(lineNum);\n        pos = (dir > 0) ? 0 : line.length;\n      }\n    }\n\n    /**\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Pos} cur The position to start from.\n     * @param {int} repeat Number of words to move past.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} wordEnd True to move to end of word. False to move to\n     *     beginning of word.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only alphabet characters count as part of the word.\n     * @return {Cursor} The position the cursor should move to.\n     */\n    function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n      var curStart = copyCursor(cur);\n      var words = [];\n      if (forward && !wordEnd || !forward && wordEnd) {\n        repeat++;\n      }\n      // For 'e', empty lines are not considered words, go figure.\n      var emptyLineIsWord = !(forward && wordEnd);\n      for (var i = 0; i < repeat; i++) {\n        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n        if (!word) {\n          var eodCh = lineLength(cm, cm.lastLine());\n          words.push(forward\n              ? {line: cm.lastLine(), from: eodCh, to: eodCh}\n              : {line: 0, from: 0, to: 0});\n          break;\n        }\n        words.push(word);\n        cur = new Pos(word.line, forward ? (word.to - 1) : word.from);\n      }\n      var shortCircuit = words.length != repeat;\n      var firstWord = words[0];\n      var lastWord = words.pop();\n      if (forward && !wordEnd) {\n        // w\n        if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return new Pos(lastWord.line, lastWord.from);\n      } else if (forward && wordEnd) {\n        return new Pos(lastWord.line, lastWord.to - 1);\n      } else if (!forward && wordEnd) {\n        // ge\n        if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return new Pos(lastWord.line, lastWord.to);\n      } else {\n        // b\n        return new Pos(lastWord.line, lastWord.from);\n      }\n    }\n\n    function moveToEol(cm, head, motionArgs, vim, keepHPos) {\n      var cur = head;\n      var retval= new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      var end=cm.clipPos(retval);\n      end.ch--;\n      if (!keepHPos) {\n        vim.lastHPos = Infinity;\n        vim.lastHSPos = cm.charCoords(end,'div').left;\n      }\n      return retval;\n    }\n\n    function moveToCharacter(cm, repeat, forward, character) {\n      var cur = cm.getCursor();\n      var start = cur.ch;\n      var idx;\n      for (var i = 0; i < repeat; i ++) {\n        var line = cm.getLine(cur.line);\n        idx = charIdxInLine(start, line, character, forward, true);\n        if (idx == -1) {\n          return null;\n        }\n        start = idx;\n      }\n      return new Pos(cm.getCursor().line, idx);\n    }\n\n    function moveToColumn(cm, repeat) {\n      // repeat is always >= 1, so repeat - 1 always corresponds\n      // to the column we want to go to.\n      var line = cm.getCursor().line;\n      return clipCursorToContent(cm, new Pos(line, repeat - 1));\n    }\n\n    function updateMark(cm, vim, markName, pos) {\n      if (!inArray(markName, validMarks)) {\n        return;\n      }\n      if (vim.marks[markName]) {\n        vim.marks[markName].clear();\n      }\n      vim.marks[markName] = cm.setBookmark(pos);\n    }\n\n    function charIdxInLine(start, line, character, forward, includeChar) {\n      // Search for char in line.\n      // motion_options: {forward, includeChar}\n      // If includeChar = true, include it too.\n      // If forward = true, search forward, else search backwards.\n      // If char is not found on this line, do nothing\n      var idx;\n      if (forward) {\n        idx = line.indexOf(character, start + 1);\n        if (idx != -1 && !includeChar) {\n          idx -= 1;\n        }\n      } else {\n        idx = line.lastIndexOf(character, start - 1);\n        if (idx != -1 && !includeChar) {\n          idx += 1;\n        }\n      }\n      return idx;\n    }\n\n    function findParagraph(cm, head, repeat, dir, inclusive) {\n      var line = head.line;\n      var min = cm.firstLine();\n      var max = cm.lastLine();\n      var start, end, i = line;\n      function isEmpty(i) { return !cm.getLine(i); }\n      function isBoundary(i, dir, any) {\n        if (any) { return isEmpty(i) != isEmpty(i + dir); }\n        return !isEmpty(i) && isEmpty(i + dir);\n      }\n      if (dir) {\n        while (min <= i && i <= max && repeat > 0) {\n          if (isBoundary(i, dir)) { repeat--; }\n          i += dir;\n        }\n        return new Pos(i, 0);\n      }\n\n      var vim = cm.state.vim;\n      if (vim.visualLine && isBoundary(line, 1, true)) {\n        var anchor = vim.sel.anchor;\n        if (isBoundary(anchor.line, -1, true)) {\n          if (!inclusive || anchor.line != line) {\n            line += 1;\n          }\n        }\n      }\n      var startState = isEmpty(line);\n      for (i = line; i <= max && repeat; i++) {\n        if (isBoundary(i, 1, true)) {\n          if (!inclusive || isEmpty(i) != startState) {\n            repeat--;\n          }\n        }\n      }\n      end = new Pos(i, 0);\n      // select boundary before paragraph for the last one\n      if (i > max && !startState) { startState = true; }\n      else { inclusive = false; }\n      for (i = line; i > min; i--) {\n        if (!inclusive || isEmpty(i) == startState || i == line) {\n          if (isBoundary(i, -1, true)) { break; }\n        }\n      }\n      start = new Pos(i, 0);\n      return { start: start, end: end };\n    }\n  function getSentence(cm, cur, repeat, dir, inclusive /*includes whitespace*/) {\n    /*\n    Takes an index object\n    {\n    line: the line string,\n    ln: line number,\n    pos: index in line,\n    dir: direction of traversal (-1 or 1)\n    }\n    and modifies the pos member to represent the\n    next valid position or sets the line to null if there are\n    no more valid positions.\n   */\n    function nextChar(curr) {\n      if (curr.pos + curr.dir < 0 || curr.pos + curr.dir >= curr.line.length) {\n          curr.line = null;\n        }\n      else {\n        curr.pos += curr.dir;\n      }\n    }\n    /*\n    Performs one iteration of traversal in forward direction\n    Returns an index object of the new location\n   */\n    function forward(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir,\n      };\n\n      if (curr.line === \"\") {\n        return { ln: curr.ln, pos: curr.pos };\n      }\n\n      var lastSentencePos = curr.pos;\n\n      // Move one step to skip character we start on\n      nextChar(curr);\n\n      while (curr.line !== null) {\n        lastSentencePos = curr.pos;\n        if (isEndOfSentenceSymbol(curr.line[curr.pos])) {\n          if (!inclusive) {\n            return { ln: curr.ln, pos: curr.pos + 1 };\n          } else {\n            nextChar(curr);\n            while (curr.line !== null ) {\n              if (isWhiteSpaceString(curr.line[curr.pos])) {\n                lastSentencePos = curr.pos;\n                nextChar(curr);\n              } else {\n                break;\n              }\n            }\n            return { ln: curr.ln, pos: lastSentencePos + 1, };\n          }\n        }\n        nextChar(curr);\n      }\n      return { ln: curr.ln, pos: lastSentencePos + 1 };\n    }\n\n    /*\n    Performs one iteration of traversal in reverse direction\n    Returns an index object of the new location\n   */\n    function reverse(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir,\n      };\n\n      if (curr.line === \"\") {\n        return { ln: curr.ln, pos: curr.pos };\n      }\n\n      var lastSentencePos = curr.pos;\n\n      // Move one step to skip character we start on\n      nextChar(curr);\n\n      while (curr.line !== null) {\n        if (!isWhiteSpaceString(curr.line[curr.pos]) && !isEndOfSentenceSymbol(curr.line[curr.pos])) {\n          lastSentencePos = curr.pos;\n        }\n\n        else if (isEndOfSentenceSymbol(curr.line[curr.pos]) ) {\n          if (!inclusive) {\n            return { ln: curr.ln, pos: lastSentencePos };\n          } else {\n              if (isWhiteSpaceString(curr.line[curr.pos + 1])) {\n                return { ln: curr.ln, pos: curr.pos + 1, };\n              } else {\n                return {ln: curr.ln, pos: lastSentencePos};\n              }\n          }\n        }\n\n        nextChar(curr);\n      }\n      curr.line = line;\n      if (inclusive && isWhiteSpaceString(curr.line[curr.pos])) {\n        return { ln: curr.ln, pos: curr.pos };\n      } else {\n        return { ln: curr.ln, pos: lastSentencePos };\n      }\n\n    }\n\n    var curr_index = {\n      ln: cur.line,\n      pos: cur.ch,\n    };\n\n    while (repeat > 0) {\n      if (dir < 0) {\n        curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n      }\n      else {\n        curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n      }\n      repeat--;\n    }\n\n    return new Pos(curr_index.ln, curr_index.pos);\n  }\n\n  function findSentence(cm, cur, repeat, dir) {\n\n    /*\n    Takes an index object\n    {\n    line: the line string,\n    ln: line number,\n    pos: index in line,\n    dir: direction of traversal (-1 or 1)\n    }\n    and modifies the line, ln, and pos members to represent the\n    next valid position or sets them to null if there are\n    no more valid positions.\n   */\n      function nextChar(cm, idx) {\n        if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {\n          idx.ln += idx.dir;\n          if (!isLine(cm, idx.ln)) {\n            idx.line = null;\n            idx.ln = null;\n            idx.pos = null;\n            return;\n          }\n          idx.line = cm.getLine(idx.ln);\n          idx.pos = (idx.dir > 0) ? 0 : idx.line.length - 1;\n        }\n        else {\n          idx.pos += idx.dir;\n        }\n      }\n\n      /*\n        Performs one iteration of traversal in forward direction\n        Returns an index object of the new location\n       */\n      function forward(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var stop = (line === \"\");\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        };\n\n        var last_valid = {\n          ln: curr.ln,\n          pos: curr.pos,\n        };\n\n        var skip_empty_lines = (curr.line === \"\");\n\n        // Move one step to skip character we start on\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n          last_valid.ln = curr.ln;\n          last_valid.pos = curr.pos;\n\n          if (curr.line === \"\" && !skip_empty_lines) {\n            return { ln: curr.ln, pos: curr.pos, };\n          }\n          else if (stop && curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            return { ln: curr.ln, pos: curr.pos, };\n          }\n          else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n            && !stop\n            && (curr.pos === curr.line.length - 1\n              || isWhiteSpaceString(curr.line[curr.pos + 1]))) {\n            stop = true;\n          }\n\n          nextChar(cm, curr);\n        }\n\n        /*\n          Set the position to the last non whitespace character on the last\n          valid line in the case that we reach the end of the document.\n        */\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for(var i = line.length - 1; i >= 0; --i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n\n        return last_valid;\n\n      }\n\n      /*\n        Performs one iteration of traversal in reverse direction\n        Returns an index object of the new location\n       */\n      function reverse(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        };\n\n        var last_valid = {\n          ln: curr.ln,\n          pos: null,\n        };\n\n        var skip_empty_lines = (curr.line === \"\");\n\n        // Move one step to skip character we start on\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n\n          if (curr.line === \"\" && !skip_empty_lines) {\n            if (last_valid.pos !== null) {\n              return last_valid;\n            }\n            else {\n              return { ln: curr.ln, pos: curr.pos };\n            }\n          }\n          else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n              && last_valid.pos !== null\n              && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {\n            return last_valid;\n          }\n          else if (curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            skip_empty_lines = false;\n            last_valid = { ln: curr.ln, pos: curr.pos };\n          }\n\n          nextChar(cm, curr);\n        }\n\n        /*\n          Set the position to the first non whitespace character on the last\n          valid line in the case that we reach the beginning of the document.\n        */\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for(var i = 0; i < line.length; ++i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n        return last_valid;\n      }\n\n      var curr_index = {\n        ln: cur.line,\n        pos: cur.ch,\n      };\n\n      while (repeat > 0) {\n        if (dir < 0) {\n          curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        else {\n          curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        repeat--;\n      }\n\n      return new Pos(curr_index.ln, curr_index.pos);\n    }\n\n    // TODO: perhaps this finagling of start and end positions belongs\n    // in codemirror/replaceRange?\n    function selectCompanionObject(cm, head, symb, inclusive) {\n      var cur = head, start, end;\n\n      var bracketRegexp = ({\n        '(': /[()]/, ')': /[()]/,\n        '[': /[[\\]]/, ']': /[[\\]]/,\n        '{': /[{}]/, '}': /[{}]/,\n        '<': /[<>]/, '>': /[<>]/})[symb];\n      var openSym = ({\n        '(': '(', ')': '(',\n        '[': '[', ']': '[',\n        '{': '{', '}': '{',\n        '<': '<', '>': '<'})[symb];\n      var curChar = cm.getLine(cur.line).charAt(cur.ch);\n      // Due to the behavior of scanForBracket, we need to add an offset if the\n      // cursor is on a matching open bracket.\n      var offset = curChar === openSym ? 1 : 0;\n\n      start = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), -1, undefined, {'bracketRegex': bracketRegexp});\n      end = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), 1, undefined, {'bracketRegex': bracketRegexp});\n\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      start = start.pos;\n      end = end.pos;\n\n      if ((start.line == end.line && start.ch > end.ch)\n          || (start.line > end.line)) {\n        var tmp = start;\n        start = end;\n        end = tmp;\n      }\n\n      if (inclusive) {\n        end.ch += 1;\n      } else {\n        start.ch += 1;\n      }\n\n      return { start: start, end: end };\n    }\n\n    // Takes in a symbol and a cursor and tries to simulate text objects that\n    // have identical opening and closing symbols\n    // TODO support across multiple lines\n    function findBeginningAndEnd(cm, head, symb, inclusive) {\n      var cur = copyCursor(head);\n      var line = cm.getLine(cur.line);\n      var chars = line.split('');\n      var start, end, i, len;\n      var firstIndex = chars.indexOf(symb);\n\n      // the decision tree is to always look backwards for the beginning first,\n      // but if the cursor is in front of the first instance of the symb,\n      // then move the cursor forward\n      if (cur.ch < firstIndex) {\n        cur.ch = firstIndex;\n        // Why is this line even here???\n        // cm.setCursor(cur.line, firstIndex+1);\n      }\n      // otherwise if the cursor is currently on the closing symbol\n      else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n        end = cur.ch; // assign end to the current cursor\n        --cur.ch; // make sure to look backwards\n      }\n\n      // if we're currently on the symbol, we've got a start\n      if (chars[cur.ch] == symb && !end) {\n        start = cur.ch + 1; // assign start to ahead of the cursor\n      } else {\n        // go backwards to find the start\n        for (i = cur.ch; i > -1 && !start; i--) {\n          if (chars[i] == symb) {\n            start = i + 1;\n          }\n        }\n      }\n\n      // look forwards for the end symbol\n      if (start && !end) {\n        for (i = start, len = chars.length; i < len && !end; i++) {\n          if (chars[i] == symb) {\n            end = i;\n          }\n        }\n      }\n\n      // nothing found\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      // include the symbols\n      if (inclusive) {\n        --start; ++end;\n      }\n\n      return {\n        start: new Pos(cur.line, start),\n        end: new Pos(cur.line, end)\n      };\n    }\n\n    // Search functions\n    defineOption('pcre', true, 'boolean');\n    function SearchState() {}\n    SearchState.prototype = {\n      getQuery: function() {\n        return vimGlobalState.query;\n      },\n      setQuery: function(query) {\n        vimGlobalState.query = query;\n      },\n      getOverlay: function() {\n        return this.searchOverlay;\n      },\n      setOverlay: function(overlay) {\n        this.searchOverlay = overlay;\n      },\n      isReversed: function() {\n        return vimGlobalState.isReversed;\n      },\n      setReversed: function(reversed) {\n        vimGlobalState.isReversed = reversed;\n      },\n      getScrollbarAnnotate: function() {\n        return this.annotate;\n      },\n      setScrollbarAnnotate: function(annotate) {\n        this.annotate = annotate;\n      }\n    };\n    function getSearchState(cm) {\n      var vim = cm.state.vim;\n      return vim.searchState_ || (vim.searchState_ = new SearchState());\n    }\n    function splitBySlash(argString) {\n      return splitBySeparator(argString, '/');\n    }\n\n    function findUnescapedSlashes(argString) {\n      return findUnescapedSeparators(argString, '/');\n    }\n\n    function splitBySeparator(argString, separator) {\n      var slashes = findUnescapedSeparators(argString, separator) || [];\n      if (!slashes.length) return [];\n      var tokens = [];\n      // in case of strings like foo/bar\n      if (slashes[0] !== 0) return;\n      for (var i = 0; i < slashes.length; i++) {\n        if (typeof slashes[i] == 'number')\n          tokens.push(argString.substring(slashes[i] + 1, slashes[i+1]));\n      }\n      return tokens;\n    }\n\n    function findUnescapedSeparators(str, separator) {\n      if (!separator)\n        separator = '/';\n\n      var escapeNextChar = false;\n      var slashes = [];\n      for (var i = 0; i < str.length; i++) {\n        var c = str.charAt(i);\n        if (!escapeNextChar && c == separator) {\n          slashes.push(i);\n        }\n        escapeNextChar = !escapeNextChar && (c == '\\\\');\n      }\n      return slashes;\n    }\n\n    // Translates a search string from ex (vim) syntax into javascript form.\n    function translateRegex(str) {\n      // When these match, add a '\\' if unescaped or remove one if escaped.\n      var specials = '|(){';\n      // Remove, but never add, a '\\' for these.\n      var unescape = '}';\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        var specialComesNext = (n && specials.indexOf(n) != -1);\n        if (escapeNextChar) {\n          if (c !== '\\\\' || !specialComesNext) {\n            out.push(c);\n          }\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            // Treat the unescape list as special for removing, but not adding '\\'.\n            if (n && unescape.indexOf(n) != -1) {\n              specialComesNext = true;\n            }\n            // Not passing this test means removing a '\\'.\n            if (!specialComesNext || n === '\\\\') {\n              out.push(c);\n            }\n          } else {\n            out.push(c);\n            if (specialComesNext && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Translates the replace part of a search and replace from ex (vim) syntax into\n    // javascript form.  Similar to translateRegex, but additionally fixes back references\n    // (translates '\\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.\n    var charUnescapes = {'\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t'};\n    function translateRegexReplace(str) {\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        if (charUnescapes[c + n]) {\n          out.push(charUnescapes[c+n]);\n          i++;\n        } else if (escapeNextChar) {\n          // At any point in the loop, escapeNextChar is true if the previous\n          // character was a '\\' and was not escaped.\n          out.push(c);\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            if ((isNumber(n) || n === '$')) {\n              out.push('$');\n            } else if (n !== '/' && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          } else {\n            if (c === '$') {\n              out.push('$');\n            }\n            out.push(c);\n            if (n === '/') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Unescape \\ and / in the replace part, for PCRE mode.\n    var unescapes = {'\\\\/': '/', '\\\\\\\\': '\\\\', '\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t', '\\\\&':'&'};\n    function unescapeRegexReplace(str) {\n      var stream = new CodeMirror.StringStream(str);\n      var output = [];\n      while (!stream.eol()) {\n        // Search for \\.\n        while (stream.peek() && stream.peek() != '\\\\') {\n          output.push(stream.next());\n        }\n        var matched = false;\n        for (var matcher in unescapes) {\n          if (stream.match(matcher, true)) {\n            matched = true;\n            output.push(unescapes[matcher]);\n            break;\n          }\n        }\n        if (!matched) {\n          // Don't change anything\n          output.push(stream.next());\n        }\n      }\n      return output.join('');\n    }\n\n    /**\n     * Extract the regular expression from the query and return a Regexp object.\n     * Returns null if the query is blank.\n     * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.\n     * If smartCase is passed in, and the query contains upper case letters,\n     *   then ignoreCase is overridden, and the 'i' flag will not be set.\n     * If the query contains the /i in the flag part of the regular expression,\n     *   then both ignoreCase and smartCase are ignored, and 'i' will be passed\n     *   through to the Regex object.\n     */\n    function parseQuery(query, ignoreCase, smartCase) {\n      // First update the last search register\n      var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n      lastSearchRegister.setText(query);\n      // Check if the query is already a regex.\n      if (query instanceof RegExp) { return query; }\n      // First try to extract regex + flags from the input. If no flags found,\n      // extract just the regex. IE does not accept flags directly defined in\n      // the regex string in the form /regex/flags\n      var slashes = findUnescapedSlashes(query);\n      var regexPart;\n      var forceIgnoreCase;\n      if (!slashes.length) {\n        // Query looks like 'regexp'\n        regexPart = query;\n      } else {\n        // Query looks like 'regexp/...'\n        regexPart = query.substring(0, slashes[0]);\n        var flagsPart = query.substring(slashes[0]);\n        forceIgnoreCase = (flagsPart.indexOf('i') != -1);\n      }\n      if (!regexPart) {\n        return null;\n      }\n      if (!getOption('pcre')) {\n        regexPart = translateRegex(regexPart);\n      }\n      if (smartCase) {\n        ignoreCase = (/^[^A-Z]*$/).test(regexPart);\n      }\n      var regexp = new RegExp(regexPart,\n          (ignoreCase || forceIgnoreCase) ? 'im' : 'm');\n      return regexp;\n    }\n\n    /**\n     * dom - Document Object Manipulator\n     * Usage:\n     *   dom('<tag>'|<node>[, ...{<attributes>|<$styles>}|<child-node>|'<text>'])\n     * Examples:\n     *   dom('div', {id:'xyz'}, dom('p', 'CM rocks!', {$color:'red'}))\n     *   dom(document.head, dom('script', 'alert(\"hello!\")'))\n     * Not supported:\n     *   dom('p', ['arrays are objects'], Error('objects specify attributes'))\n     */\n    function dom(n) {\n      if (typeof n === 'string') n = document.createElement(n);\n      for (var a, i = 1; i < arguments.length; i++) {\n        if (!(a = arguments[i])) continue;\n        if (typeof a !== 'object') a = document.createTextNode(a);\n        if (a.nodeType) n.appendChild(a);\n        else for (var key in a) {\n          if (!Object.prototype.hasOwnProperty.call(a, key)) continue;\n          if (key[0] === '$') n.style[key.slice(1)] = a[key];\n          else n.setAttribute(key, a[key]);\n        }\n      }\n      return n;\n    }\n\n    function showConfirm(cm, template) {\n      var pre = dom('div', {$color: 'red', $whiteSpace: 'pre', class: 'cm-vim-message'}, template);\n      if (cm.openNotification) {\n        cm.openNotification(pre, {bottom: true, duration: 5000});\n      } else {\n        alert(pre.innerText);\n      }\n    }\n\n    function makePrompt(prefix, desc) {\n      return dom(document.createDocumentFragment(),\n               dom('span', {$fontFamily: 'monospace', $whiteSpace: 'pre'},\n                 prefix,\n                 dom('input', {type: 'text', autocorrect: 'off',\n                               autocapitalize: 'off', spellcheck: 'false'})),\n               desc && dom('span', {$color: '#888'}, desc));\n    }\n\n    function showPrompt(cm, options) {\n      var template = makePrompt(options.prefix, options.desc);\n      if (cm.openDialog) {\n        cm.openDialog(template, options.onClose, {\n          onKeyDown: options.onKeyDown, onKeyUp: options.onKeyUp,\n          bottom: true, selectValueOnOpen: false, value: options.value\n        });\n      }\n      else {\n        var shortText = '';\n        if (typeof options.prefix != \"string\" && options.prefix) shortText += options.prefix.textContent;\n        if (options.desc) shortText += \" \" + options.desc;\n        options.onClose(prompt(shortText, ''));\n      }\n    }\n\n    function regexEqual(r1, r2) {\n      if (r1 instanceof RegExp && r2 instanceof RegExp) {\n          var props = ['global', 'multiline', 'ignoreCase', 'source'];\n          for (var i = 0; i < props.length; i++) {\n              var prop = props[i];\n              if (r1[prop] !== r2[prop]) {\n                  return false;\n              }\n          }\n          return true;\n      }\n      return false;\n    }\n    // Returns true if the query is valid.\n    function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n      if (!rawQuery) {\n        return;\n      }\n      var state = getSearchState(cm);\n      var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n      if (!query) {\n        return;\n      }\n      highlightSearchMatches(cm, query);\n      if (regexEqual(query, state.getQuery())) {\n        return query;\n      }\n      state.setQuery(query);\n      return query;\n    }\n    function searchOverlay(query) {\n      if (query.source.charAt(0) == '^') {\n        var matchSol = true;\n      }\n      return {\n        token: function(stream) {\n          if (matchSol && !stream.sol()) {\n            stream.skipToEnd();\n            return;\n          }\n          var match = stream.match(query, false);\n          if (match) {\n            if (match[0].length == 0) {\n              // Matched empty string, skip to next.\n              stream.next();\n              return 'searching';\n            }\n            if (!stream.sol()) {\n              // Backtrack 1 to match \\b\n              stream.backUp(1);\n              if (!query.exec(stream.next() + match[0])) {\n                stream.next();\n                return null;\n              }\n            }\n            stream.match(query);\n            return 'searching';\n          }\n          while (!stream.eol()) {\n            stream.next();\n            if (stream.match(query, false)) break;\n          }\n        },\n        query: query\n      };\n    }\n    var highlightTimeout = 0;\n    function highlightSearchMatches(cm, query) {\n      clearTimeout(highlightTimeout);\n      highlightTimeout = setTimeout(function() {\n        if (!cm.state.vim) return;\n        var searchState = getSearchState(cm);\n        var overlay = searchState.getOverlay();\n        if (!overlay || query != overlay.query) {\n          if (overlay) {\n            cm.removeOverlay(overlay);\n          }\n          overlay = searchOverlay(query);\n          cm.addOverlay(overlay);\n          if (cm.showMatchesOnScrollbar) {\n            if (searchState.getScrollbarAnnotate()) {\n              searchState.getScrollbarAnnotate().clear();\n            }\n            searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n          }\n          searchState.setOverlay(overlay);\n        }\n      }, 50);\n    }\n    function findNext(cm, prev, query, repeat) {\n      if (repeat === undefined) { repeat = 1; }\n      return cm.operation(function() {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n        for (var i = 0; i < repeat; i++) {\n          var found = cursor.find(prev);\n          if (i == 0 && found && cursorEqual(cursor.from(), pos)) {\n            var lastEndPos = prev ? cursor.from() : cursor.to();\n            found = cursor.find(prev);\n            if (found && !found[0] && cursorEqual(cursor.from(), lastEndPos)) {\n              if (cm.getLine(lastEndPos.line).length == lastEndPos.ch)\n                found = cursor.find(prev);\n            }\n          }\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query,\n                (prev) ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0) );\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n        return cursor.from();\n      });\n    }\n    /**\n     * Pretty much the same as `findNext`, except for the following differences:\n     *\n     * 1. Before starting the search, move to the previous search. This way if our cursor is\n     * already inside a match, we should return the current match.\n     * 2. Rather than only returning the cursor's from, we return the cursor's from and to as a tuple.\n     */\n    function findNextFromAndToInclusive(cm, prev, query, repeat, vim) {\n      if (repeat === undefined) { repeat = 1; }\n      return cm.operation(function() {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n\n        // Go back one result to ensure that if the cursor is currently a match, we keep it.\n        var found = cursor.find(!prev);\n\n        // If we haven't moved, go back one more (similar to if i==0 logic in findNext).\n        if (!vim.visualMode && found && cursorEqual(cursor.from(), pos)) {\n          cursor.find(!prev);\n        }\n\n        for (var i = 0; i < repeat; i++) {\n          found = cursor.find(prev);\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query,\n                (prev) ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0) );\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n        return [cursor.from(), cursor.to()];\n      });\n    }\n    function clearSearchHighlight(cm) {\n      var state = getSearchState(cm);\n      cm.removeOverlay(getSearchState(cm).getOverlay());\n      state.setOverlay(null);\n      if (state.getScrollbarAnnotate()) {\n        state.getScrollbarAnnotate().clear();\n        state.setScrollbarAnnotate(null);\n      }\n    }\n    /**\n     * Check if pos is in the specified range, INCLUSIVE.\n     * Range can be specified with 1 or 2 arguments.\n     * If the first range argument is an array, treat it as an array of line\n     * numbers. Match pos against any of the lines.\n     * If the first range argument is a number,\n     *   if there is only 1 range argument, check if pos has the same line\n     *       number\n     *   if there are 2 range arguments, then check if pos is in between the two\n     *       range arguments.\n     */\n    function isInRange(pos, start, end) {\n      if (typeof pos != 'number') {\n        // Assume it is a cursor position. Get the line number.\n        pos = pos.line;\n      }\n      if (start instanceof Array) {\n        return inArray(pos, start);\n      } else {\n        if (typeof end == 'number') {\n          return (pos >= start && pos <= end);\n        } else {\n          return pos == start;\n        }\n      }\n    }\n    function getUserVisibleLines(cm) {\n      var scrollInfo = cm.getScrollInfo();\n      var occludeToleranceTop = 6;\n      var occludeToleranceBottom = 10;\n      var from = cm.coordsChar({left:0, top: occludeToleranceTop + scrollInfo.top}, 'local');\n      var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;\n      var to = cm.coordsChar({left:0, top: bottomY}, 'local');\n      return {top: from.line, bottom: to.line};\n    }\n\n    function getMarkPos(cm, vim, markName) {\n      if (markName == '\\'' || markName == '`') {\n        return vimGlobalState.jumpList.find(cm, -1) || new Pos(0, 0);\n      } else if (markName == '.') {\n        return getLastEditPos(cm);\n      }\n\n      var mark = vim.marks[markName];\n      return mark && mark.find();\n    }\n\n    function getLastEditPos(cm) {\n      var done = cm.doc.history.done;\n      for (var i = done.length; i--;) {\n        if (done[i].changes) {\n          return copyCursor(done[i].changes[0].to);\n        }\n      }\n    }\n\n    var ExCommandDispatcher = function() {\n      this.buildCommandMap_();\n    };\n    ExCommandDispatcher.prototype = {\n      processCommand: function(cm, input, opt_params) {\n        var that = this;\n        cm.operation(function () {\n          cm.curOp.isVimOp = true;\n          that._processCommand(cm, input, opt_params);\n        });\n      },\n      _processCommand: function(cm, input, opt_params) {\n        var vim = cm.state.vim;\n        var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n        var previousCommand = commandHistoryRegister.toString();\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        var inputStream = new CodeMirror.StringStream(input);\n        // update \": with the latest command whether valid or invalid\n        commandHistoryRegister.setText(input);\n        var params = opt_params || {};\n        params.input = input;\n        try {\n          this.parseInput_(cm, inputStream, params);\n        } catch(e) {\n          showConfirm(cm, e.toString());\n          throw e;\n        }\n        var command;\n        var commandName;\n        if (!params.commandName) {\n          // If only a line range is defined, move to the line.\n          if (params.line !== undefined) {\n            commandName = 'move';\n          }\n        } else {\n          command = this.matchCommand_(params.commandName);\n          if (command) {\n            commandName = command.name;\n            if (command.excludeFromCommandHistory) {\n              commandHistoryRegister.setText(previousCommand);\n            }\n            this.parseCommandArgs_(inputStream, params, command);\n            if (command.type == 'exToKey') {\n              // Handle Ex to Key mapping.\n              for (var i = 0; i < command.toKeys.length; i++) {\n                vimApi.handleKey(cm, command.toKeys[i], 'mapping');\n              }\n              return;\n            } else if (command.type == 'exToEx') {\n              // Handle Ex to Ex mapping.\n              this.processCommand(cm, command.toInput);\n              return;\n            }\n          }\n        }\n        if (!commandName) {\n          showConfirm(cm, 'Not an editor command \":' + input + '\"');\n          return;\n        }\n        try {\n          exCommands[commandName](cm, params);\n          // Possibly asynchronous commands (e.g. substitute, which might have a\n          // user confirmation), are responsible for calling the callback when\n          // done. All others have it taken care of for them here.\n          if ((!command || !command.possiblyAsync) && params.callback) {\n            params.callback();\n          }\n        } catch(e) {\n          showConfirm(cm, e.toString());\n          throw e;\n        }\n      },\n      parseInput_: function(cm, inputStream, result) {\n        inputStream.eatWhile(':');\n        // Parse range.\n        if (inputStream.eat('%')) {\n          result.line = cm.firstLine();\n          result.lineEnd = cm.lastLine();\n        } else {\n          result.line = this.parseLineSpec_(cm, inputStream);\n          if (result.line !== undefined && inputStream.eat(',')) {\n            result.lineEnd = this.parseLineSpec_(cm, inputStream);\n          }\n        }\n\n        // Parse command name.\n        var commandMatch = inputStream.match(/^(\\w+|!!|@@|[!#&*<=>@~])/);\n        if (commandMatch) {\n          result.commandName = commandMatch[1];\n        } else {\n          result.commandName = inputStream.match(/.*/)[0];\n        }\n\n        return result;\n      },\n      parseLineSpec_: function(cm, inputStream) {\n        var numberMatch = inputStream.match(/^(\\d+)/);\n        if (numberMatch) {\n          // Absolute line number plus offset (N+M or N-M) is probably a typo,\n          // not something the user actually wanted. (NB: vim does allow this.)\n          return parseInt(numberMatch[1], 10) - 1;\n        }\n        switch (inputStream.next()) {\n          case '.':\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          case '$':\n            return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n          case '\\'':\n            var markName = inputStream.next();\n            var markPos = getMarkPos(cm, cm.state.vim, markName);\n            if (!markPos) throw new Error('Mark not set');\n            return this.parseLineSpecOffset_(inputStream, markPos.line);\n          case '-':\n          case '+':\n            inputStream.backUp(1);\n            // Offset is relative to current line if not otherwise specified.\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          default:\n            inputStream.backUp(1);\n            return undefined;\n        }\n      },\n      parseLineSpecOffset_: function(inputStream, line) {\n        var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n        if (offsetMatch) {\n          var offset = parseInt(offsetMatch[2], 10);\n          if (offsetMatch[1] == \"-\") {\n            line -= offset;\n          } else {\n            line += offset;\n          }\n        }\n        return line;\n      },\n      parseCommandArgs_: function(inputStream, params, command) {\n        if (inputStream.eol()) {\n          return;\n        }\n        params.argString = inputStream.match(/.*/)[0];\n        // Parse command-line arguments\n        var delim = command.argDelimiter || /\\s+/;\n        var args = trim(params.argString).split(delim);\n        if (args.length && args[0]) {\n          params.args = args;\n        }\n      },\n      matchCommand_: function(commandName) {\n        // Return the command in the command map that matches the shortest\n        // prefix of the passed in command name. The match is guaranteed to be\n        // unambiguous if the defaultExCommandMap's shortNames are set up\n        // correctly. (see @code{defaultExCommandMap}).\n        for (var i = commandName.length; i > 0; i--) {\n          var prefix = commandName.substring(0, i);\n          if (this.commandMap_[prefix]) {\n            var command = this.commandMap_[prefix];\n            if (command.name.indexOf(commandName) === 0) {\n              return command;\n            }\n          }\n        }\n        return null;\n      },\n      buildCommandMap_: function() {\n        this.commandMap_ = {};\n        for (var i = 0; i < defaultExCommandMap.length; i++) {\n          var command = defaultExCommandMap[i];\n          var key = command.shortName || command.name;\n          this.commandMap_[key] = command;\n        }\n      },\n      map: function(lhs, rhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Ex to Ex mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToEx',\n              toInput: rhs.substring(1),\n              user: true\n            };\n          } else {\n            // Ex to key mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToKey',\n              toKeys: rhs,\n              user: true\n            };\n          }\n        } else {\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Key to Ex mapping.\n            var mapping = {\n              keys: lhs,\n              type: 'keyToEx',\n              exArgs: { input: rhs.substring(1) }\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          } else {\n            // Key to key mapping\n            var mapping = {\n              keys: lhs,\n              type: 'keyToKey',\n              toKeys: rhs\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          }\n        }\n      },\n      unmap: function(lhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          // Ex to Ex or Ex to key mapping\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n            delete this.commandMap_[commandName];\n            return true;\n          }\n        } else {\n          // Key to Ex or key to key mapping\n          var keys = lhs;\n          for (var i = 0; i < defaultKeymap.length; i++) {\n            if (keys == defaultKeymap[i].keys\n                && defaultKeymap[i].context === ctx) {\n              defaultKeymap.splice(i, 1);\n              return true;\n            }\n          }\n        }\n      }\n    };\n\n    var exCommands = {\n      colorscheme: function(cm, params) {\n        if (!params.args || params.args.length < 1) {\n          showConfirm(cm, cm.getOption('theme'));\n          return;\n        }\n        cm.setOption('theme', params.args[0]);\n      },\n      map: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 2) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);\n      },\n      imap: function(cm, params) { this.map(cm, params, 'insert'); },\n      nmap: function(cm, params) { this.map(cm, params, 'normal'); },\n      vmap: function(cm, params) { this.map(cm, params, 'visual'); },\n      unmap: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 1 || !exCommandDispatcher.unmap(mapArgs[0], ctx)) {\n          if (cm) {\n            showConfirm(cm, 'No such mapping: ' + params.input);\n          }\n        }\n      },\n      move: function(cm, params) {\n        commandDispatcher.processCommand(cm, cm.state.vim, {\n            type: 'motion',\n            motion: 'moveToLineOrEdgeOfDocument',\n            motionArgs: { forward: false, explicitRepeat: true,\n              linewise: true },\n            repeatOverride: params.line+1});\n      },\n      set: function(cm, params) {\n        var setArgs = params.args;\n        // Options passed through to the setOption/getOption calls. May be passed in by the\n        // local/global versions of the set command\n        var setCfg = params.setCfg || {};\n        if (!setArgs || setArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        var expr = setArgs[0].split('=');\n        var optionName = expr[0];\n        var value = expr[1];\n        var forceGet = false;\n\n        if (optionName.charAt(optionName.length - 1) == '?') {\n          // If post-fixed with ?, then the set is actually a get.\n          if (value) { throw Error('Trailing characters: ' + params.argString); }\n          optionName = optionName.substring(0, optionName.length - 1);\n          forceGet = true;\n        }\n        if (value === undefined && optionName.substring(0, 2) == 'no') {\n          // To set boolean options to false, the option name is prefixed with\n          // 'no'.\n          optionName = optionName.substring(2);\n          value = false;\n        }\n\n        var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n        if (optionIsBoolean && value == undefined) {\n          // Calling set with a boolean option sets it to true.\n          value = true;\n        }\n        // If no value is provided, then we assume this is a get.\n        if (!optionIsBoolean && value === undefined || forceGet) {\n          var oldValue = getOption(optionName, cm, setCfg);\n          if (oldValue instanceof Error) {\n            showConfirm(cm, oldValue.message);\n          } else if (oldValue === true || oldValue === false) {\n            showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n          } else {\n            showConfirm(cm, '  ' + optionName + '=' + oldValue);\n          }\n        } else {\n          var setOptionReturn = setOption(optionName, value, cm, setCfg);\n          if (setOptionReturn instanceof Error) {\n            showConfirm(cm, setOptionReturn.message);\n          }\n        }\n      },\n      setlocal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'local'};\n        this.set(cm, params);\n      },\n      setglobal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'global'};\n        this.set(cm, params);\n      },\n      registers: function(cm, params) {\n        var regArgs = params.args;\n        var registers = vimGlobalState.registerController.registers;\n        var regInfo = '----------Registers----------\\n\\n';\n        if (!regArgs) {\n          for (var registerName in registers) {\n            var text = registers[registerName].toString();\n            if (text.length) {\n              regInfo += '\"' + registerName + '    ' + text + '\\n';\n            }\n          }\n        } else {\n          var registerName;\n          regArgs = regArgs.join('');\n          for (var i = 0; i < regArgs.length; i++) {\n            registerName = regArgs.charAt(i);\n            if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n              continue;\n            }\n            var register = registers[registerName] || new Register();\n            regInfo += '\"' + registerName + '    ' + register.toString() + '\\n';\n          }\n        }\n        showConfirm(cm, regInfo);\n      },\n      sort: function(cm, params) {\n        var reverse, ignoreCase, unique, number, pattern;\n        function parseArgs() {\n          if (params.argString) {\n            var args = new CodeMirror.StringStream(params.argString);\n            if (args.eat('!')) { reverse = true; }\n            if (args.eol()) { return; }\n            if (!args.eatSpace()) { return 'Invalid arguments'; }\n            var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n            if (!opts && !args.eol()) { return 'Invalid arguments'; }\n            if (opts[1]) {\n              ignoreCase = opts[1].indexOf('i') != -1;\n              unique = opts[1].indexOf('u') != -1;\n              var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\n              var hex = opts[1].indexOf('x') != -1 && 1;\n              var octal = opts[1].indexOf('o') != -1 && 1;\n              if (decimal + hex + octal > 1) { return 'Invalid arguments'; }\n              number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n            }\n            if (opts[2]) {\n              pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n            }\n          }\n        }\n        var err = parseArgs();\n        if (err) {\n          showConfirm(cm, err + ': ' + params.argString);\n          return;\n        }\n        var lineStart = params.line || cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        if (lineStart == lineEnd) { return; }\n        var curStart = new Pos(lineStart, 0);\n        var curEnd = new Pos(lineEnd, lineLength(cm, lineEnd));\n        var text = cm.getRange(curStart, curEnd).split('\\n');\n        var numberRegex = pattern ? pattern :\n           (number == 'decimal') ? /(-?)([\\d]+)/ :\n           (number == 'hex') ? /(-?)(?:0x)?([0-9a-f]+)/i :\n           (number == 'octal') ? /([0-7]+)/ : null;\n        var radix = (number == 'decimal') ? 10 : (number == 'hex') ? 16 : (number == 'octal') ? 8 : null;\n        var numPart = [], textPart = [];\n        if (number || pattern) {\n          for (var i = 0; i < text.length; i++) {\n            var matchPart = pattern ? text[i].match(pattern) : null;\n            if (matchPart && matchPart[0] != '') {\n              numPart.push(matchPart);\n            } else if (!pattern && numberRegex.exec(text[i])) {\n              numPart.push(text[i]);\n            } else {\n              textPart.push(text[i]);\n            }\n          }\n        } else {\n          textPart = text;\n        }\n        function compareFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a = a.toLowerCase(); b = b.toLowerCase(); }\n          var anum = number && numberRegex.exec(a);\n          var bnum = number && numberRegex.exec(b);\n          if (!anum) { return a < b ? -1 : 1; }\n          anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n          bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n          return anum - bnum;\n        }\n        function comparePatternFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a[0] = a[0].toLowerCase(); b[0] = b[0].toLowerCase(); }\n          return (a[0] < b[0]) ? -1 : 1;\n        }\n        numPart.sort(pattern ? comparePatternFn : compareFn);\n        if (pattern) {\n          for (var i = 0; i < numPart.length; i++) {\n            numPart[i] = numPart[i].input;\n          }\n        } else if (!number) { textPart.sort(compareFn); }\n        text = (!reverse) ? textPart.concat(numPart) : numPart.concat(textPart);\n        if (unique) { // Remove duplicate lines\n          var textOld = text;\n          var lastLine;\n          text = [];\n          for (var i = 0; i < textOld.length; i++) {\n            if (textOld[i] != lastLine) {\n              text.push(textOld[i]);\n            }\n            lastLine = textOld[i];\n          }\n        }\n        cm.replaceRange(text.join('\\n'), curStart, curEnd);\n      },\n      vglobal: function(cm, params) {\n        // global inspects params.commandName\n        this.global(cm, params);\n      },\n      global: function(cm, params) {\n        // a global command is of the form\n        // :[range]g/pattern/[cmd]\n        // argString holds the string /pattern/[cmd]\n        var argString = params.argString;\n        if (!argString) {\n          showConfirm(cm, 'Regular Expression missing from global');\n          return;\n        }\n        var inverted = params.commandName[0] === 'v';\n        // range is specified here\n        var lineStart = (params.line !== undefined) ? params.line : cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        // get the tokens from argString\n        var tokens = splitBySlash(argString);\n        var regexPart = argString, cmd;\n        if (tokens.length) {\n          regexPart = tokens[0];\n          cmd = tokens.slice(1, tokens.length).join('/');\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise\n          // use the regex part as the new query.\n          try {\n           updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n             true /** smartCase */);\n          } catch (e) {\n           showConfirm(cm, 'Invalid regex: ' + regexPart);\n           return;\n          }\n        }\n        // now that we have the regexPart, search for regex matches in the\n        // specified range of lines\n        var query = getSearchState(cm).getQuery();\n        var matchedLines = [];\n        for (var i = lineStart; i <= lineEnd; i++) {\n          var line = cm.getLineHandle(i);\n          var matched = query.test(line.text);\n          if (matched !== inverted) {\n            matchedLines.push(cmd ? line : line.text);\n          }\n        }\n        // if there is no [cmd], just display the list of matched lines\n        if (!cmd) {\n          showConfirm(cm, matchedLines.join('\\n'));\n          return;\n        }\n        var index = 0;\n        var nextCommand = function() {\n          if (index < matchedLines.length) {\n            var line = matchedLines[index++];\n            var lineNum = cm.getLineNumber(line);\n            if (lineNum == null) {\n              nextCommand();\n              return;\n            }\n            var command = (lineNum + 1) + cmd;\n            exCommandDispatcher.processCommand(cm, command, {\n              callback: nextCommand\n            });\n          }\n        };\n        nextCommand();\n      },\n      substitute: function(cm, params) {\n        if (!cm.getSearchCursor) {\n          throw new Error('Search feature not available. Requires searchcursor.js or ' +\n              'any other getSearchCursor implementation.');\n        }\n        var argString = params.argString;\n        var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\n        var regexPart, replacePart = '', trailing, flagsPart, count;\n        var confirm = false; // Whether to confirm each replace.\n        var global = false; // True to replace all instances on a line, false to replace only 1.\n        if (tokens.length) {\n          regexPart = tokens[0];\n          if (getOption('pcre') && regexPart !== '') {\n              regexPart = new RegExp(regexPart).source; //normalize not escaped characters\n          }\n          replacePart = tokens[1];\n          if (replacePart !== undefined) {\n            if (getOption('pcre')) {\n              replacePart = unescapeRegexReplace(replacePart.replace(/([^\\\\])&/g,\"$1$$&\"));\n            } else {\n              replacePart = translateRegexReplace(replacePart);\n            }\n            vimGlobalState.lastSubstituteReplacePart = replacePart;\n          }\n          trailing = tokens[2] ? tokens[2].split(' ') : [];\n        } else {\n          // either the argString is empty or its of the form ' hello/world'\n          // actually splitBySlash returns a list of tokens\n          // only if the string starts with a '/'\n          if (argString && argString.length) {\n            showConfirm(cm, 'Substitutions should be of the form ' +\n                ':s/pattern/replace/');\n            return;\n          }\n        }\n        // After the 3rd slash, we can have flags followed by a space followed\n        // by count.\n        if (trailing) {\n          flagsPart = trailing[0];\n          count = parseInt(trailing[1]);\n          if (flagsPart) {\n            if (flagsPart.indexOf('c') != -1) {\n              confirm = true;\n            }\n            if (flagsPart.indexOf('g') != -1) {\n              global = true;\n            }\n            if (getOption('pcre')) {\n               regexPart = regexPart + '/' + flagsPart;\n            } else {\n               regexPart = regexPart.replace(/\\//g, \"\\\\/\") + '/' + flagsPart;\n            }\n          }\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise use\n          // the regex part as the new query.\n          try {\n            updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n              true /** smartCase */);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + regexPart);\n            return;\n          }\n        }\n        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n        if (replacePart === undefined) {\n          showConfirm(cm, 'No previous substitute regular expression');\n          return;\n        }\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        var lineStart = (params.line !== undefined) ? params.line : cm.getCursor().line;\n        var lineEnd = params.lineEnd || lineStart;\n        if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n          lineEnd = Infinity;\n        }\n        if (count) {\n          lineStart = lineEnd;\n          lineEnd = lineStart + count - 1;\n        }\n        var startPos = clipCursorToContent(cm, new Pos(lineStart, 0));\n        var cursor = cm.getSearchCursor(query, startPos);\n        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n      },\n      redo: CodeMirror.commands.redo,\n      undo: CodeMirror.commands.undo,\n      write: function(cm) {\n        if (CodeMirror.commands.save) {\n          // If a save command is defined, call it.\n          CodeMirror.commands.save(cm);\n        } else if (cm.save) {\n          // Saves to text area if no save command is defined and cm.save() is available.\n          cm.save();\n        }\n      },\n      nohlsearch: function(cm) {\n        clearSearchHighlight(cm);\n      },\n      yank: function (cm) {\n        var cur = copyCursor(cm.getCursor());\n        var line = cur.line;\n        var lineText = cm.getLine(line);\n        vimGlobalState.registerController.pushText(\n          '0', 'yank', lineText, true, true);\n      },\n      delmarks: function(cm, params) {\n        if (!params.argString || !trim(params.argString)) {\n          showConfirm(cm, 'Argument required');\n          return;\n        }\n\n        var state = cm.state.vim;\n        var stream = new CodeMirror.StringStream(trim(params.argString));\n        while (!stream.eol()) {\n          stream.eatSpace();\n\n          // Record the streams position at the beginning of the loop for use\n          // in error messages.\n          var count = stream.pos;\n\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n            return;\n          }\n\n          var sym = stream.next();\n          // Check if this symbol is part of a range\n          if (stream.match('-', true)) {\n            // This symbol is part of a range.\n\n            // The range must terminate at an alphabetic character.\n            if (!stream.match(/[a-zA-Z]/, false)) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n              return;\n            }\n\n            var startMark = sym;\n            var finishMark = stream.next();\n            // The range must terminate at an alphabetic character which\n            // shares the same case as the start of the range.\n            if (isLowerCase(startMark) && isLowerCase(finishMark) ||\n                isUpperCase(startMark) && isUpperCase(finishMark)) {\n              var start = startMark.charCodeAt(0);\n              var finish = finishMark.charCodeAt(0);\n              if (start >= finish) {\n                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                return;\n              }\n\n              // Because marks are always ASCII values, and we have\n              // determined that they are the same case, we can use\n              // their char codes to iterate through the defined range.\n              for (var j = 0; j <= finish - start; j++) {\n                var mark = String.fromCharCode(start + j);\n                delete state.marks[mark];\n              }\n            } else {\n              showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n              return;\n            }\n          } else {\n            // This symbol is a valid mark, and is not part of a range.\n            delete state.marks[sym];\n          }\n        }\n      }\n    };\n\n    var exCommandDispatcher = new ExCommandDispatcher();\n\n    /**\n    * @param {CodeMirror} cm CodeMirror instance we are in.\n    * @param {boolean} confirm Whether to confirm each replace.\n    * @param {Cursor} lineStart Line to start replacing from.\n    * @param {Cursor} lineEnd Line to stop replacing at.\n    * @param {RegExp} query Query for performing matches with.\n    * @param {string} replaceWith Text to replace matches with. May contain $1,\n    *     $2, etc for replacing captured groups using JavaScript replace.\n    * @param {function()} callback A callback for when the replace is done.\n    */\n    function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query,\n        replaceWith, callback) {\n      // Set up all the functions.\n      cm.state.vim.exMode = true;\n      var done = false;\n      var lastPos, modifiedLineNumber, joined;\n      function replaceAll() {\n        cm.operation(function() {\n          while (!done) {\n            replace();\n            next();\n          }\n          stop();\n        });\n      }\n      function replace() {\n        var text = cm.getRange(searchCursor.from(), searchCursor.to());\n        var newText = text.replace(query, replaceWith);\n        var unmodifiedLineNumber = searchCursor.to().line;\n        searchCursor.replace(newText);\n        modifiedLineNumber = searchCursor.to().line;\n        lineEnd += modifiedLineNumber - unmodifiedLineNumber;\n        joined = modifiedLineNumber < unmodifiedLineNumber;\n      }\n      function findNextValidMatch() {\n        var lastMatchTo = lastPos && copyCursor(searchCursor.to());\n        var match = searchCursor.findNext();\n        if (match && !match[0] && lastMatchTo && cursorEqual(searchCursor.from(), lastMatchTo)) {\n          match = searchCursor.findNext();\n        }\n        return match;\n      }\n      function next() {\n        // The below only loops to skip over multiple occurrences on the same\n        // line when 'global' is not true.\n        while(findNextValidMatch() &&\n              isInRange(searchCursor.from(), lineStart, lineEnd)) {\n          if (!global && searchCursor.from().line == modifiedLineNumber && !joined) {\n            continue;\n          }\n          cm.scrollIntoView(searchCursor.from(), 30);\n          cm.setSelection(searchCursor.from(), searchCursor.to());\n          lastPos = searchCursor.from();\n          done = false;\n          return;\n        }\n        done = true;\n      }\n      function stop(close) {\n        if (close) { close(); }\n        cm.focus();\n        if (lastPos) {\n          cm.setCursor(lastPos);\n          var vim = cm.state.vim;\n          vim.exMode = false;\n          vim.lastHPos = vim.lastHSPos = lastPos.ch;\n        }\n        if (callback) { callback(); }\n      }\n      function onPromptKeyDown(e, _value, close) {\n        // Swallow all keys.\n        CodeMirror.e_stop(e);\n        var keyName = CodeMirror.keyName(e);\n        switch (keyName) {\n          case 'Y':\n            replace(); next(); break;\n          case 'N':\n            next(); break;\n          case 'A':\n            // replaceAll contains a call to close of its own. We don't want it\n            // to fire too early or multiple times.\n            var savedCallback = callback;\n            callback = undefined;\n            cm.operation(replaceAll);\n            callback = savedCallback;\n            break;\n          case 'L':\n            replace();\n            // fall through and exit.\n          case 'Q':\n          case 'Esc':\n          case 'Ctrl-C':\n          case 'Ctrl-[':\n            stop(close);\n            break;\n        }\n        if (done) { stop(close); }\n        return true;\n      }\n\n      // Actually do replace.\n      next();\n      if (done) {\n        showConfirm(cm, 'No matches for ' + query.source);\n        return;\n      }\n      if (!confirm) {\n        replaceAll();\n        if (callback) { callback(); }\n        return;\n      }\n      showPrompt(cm, {\n        prefix: dom('span', 'replace with ', dom('strong', replaceWith), ' (y/n/a/q/l)'),\n        onKeyDown: onPromptKeyDown\n      });\n    }\n\n    CodeMirror.keyMap.vim = {\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function exitInsertMode(cm) {\n      var vim = cm.state.vim;\n      var macroModeState = vimGlobalState.macroModeState;\n      var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n      var isPlaying = macroModeState.isPlaying;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!isPlaying) {\n        cm.off('change', onChange);\n        CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n      }\n      if (!isPlaying && vim.insertModeRepeat > 1) {\n        // Perform insert mode repeat for commands like 3,a and 3,o.\n        repeatLastEdit(cm, vim, vim.insertModeRepeat - 1,\n            true /** repeatForInsert */);\n        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n      }\n      delete vim.insertModeRepeat;\n      vim.insertMode = false;\n      cm.setCursor(cm.getCursor().line, cm.getCursor().ch-1);\n      cm.setOption('keyMap', 'vim');\n      cm.setOption('disableInput', true);\n      cm.toggleOverwrite(false); // exit replace mode if we were in it.\n      // update the \". register before exiting insert mode\n      insertModeChangeRegister.setText(lastChange.changes.join(''));\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      if (macroModeState.isRecording) {\n        logInsertModeChange(macroModeState);\n      }\n    }\n\n    function _mapCommand(command) {\n      defaultKeymap.unshift(command);\n    }\n\n    function mapCommand(keys, type, name, args, extra) {\n      var command = {keys: keys, type: type};\n      command[type] = name;\n      command[type + \"Args\"] = args;\n      for (var key in extra)\n        command[key] = extra[key];\n      _mapCommand(command);\n    }\n\n    // The timeout in milliseconds for the two-character ESC keymap should be\n    // adjusted according to your typing speed to prevent false positives.\n    defineOption('insertModeEscKeysTimeout', 200, 'number');\n\n    CodeMirror.keyMap['vim-insert'] = {\n      // TODO: override navigation keys so that Esc will cancel automatic\n      // indentation from o, O, i_<CR>\n      fallthrough: ['default'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    CodeMirror.keyMap['vim-replace'] = {\n      'Backspace': 'goCharLeft',\n      fallthrough: ['vim-insert'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function executeMacroRegister(cm, vim, macroModeState, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (registerName == ':') {\n        // Read-only register containing last Ex command.\n        if (register.keyBuffer[0]) {\n          exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n        }\n        macroModeState.isPlaying = false;\n        return;\n      }\n      var keyBuffer = register.keyBuffer;\n      var imc = 0;\n      macroModeState.isPlaying = true;\n      macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n      for (var i = 0; i < keyBuffer.length; i++) {\n        var text = keyBuffer[i];\n        var match, key;\n        while (text) {\n          // Pull off one command key, which is either a single character\n          // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n          match = (/<\\w+-.+?>|<\\w+>|./).exec(text);\n          key = match[0];\n          text = text.substring(match.index + key.length);\n          vimApi.handleKey(cm, key, 'macro');\n          if (vim.insertMode) {\n            var changes = register.insertModeChanges[imc++].changes;\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes =\n                changes;\n            repeatInsertModeChanges(cm, changes, 1);\n            exitInsertMode(cm);\n          }\n        }\n      }\n      macroModeState.isPlaying = false;\n    }\n\n    function logKey(macroModeState, key) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register) {\n        register.pushText(key);\n      }\n    }\n\n    function logInsertModeChange(macroModeState) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushInsertModeChanges) {\n        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n      }\n    }\n\n    function logSearchQuery(macroModeState, query) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushSearchQuery) {\n        register.pushSearchQuery(query);\n      }\n    }\n\n    /**\n     * Listens for changes made in insert mode.\n     * Should only be active in insert mode.\n     */\n    function onChange(cm, changeObj) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!macroModeState.isPlaying) {\n        while(changeObj) {\n          lastChange.expectCursorActivityForChange = true;\n          if (lastChange.ignoreCount > 1) {\n            lastChange.ignoreCount--;\n          } else if (changeObj.origin == '+input' || changeObj.origin == 'paste'\n              || changeObj.origin === undefined /* only in testing */) {\n            var selectionCount = cm.listSelections().length;\n            if (selectionCount > 1)\n              lastChange.ignoreCount = selectionCount;\n            var text = changeObj.text.join('\\n');\n            if (lastChange.maybeReset) {\n              lastChange.changes = [];\n              lastChange.maybeReset = false;\n            }\n            if (text) {\n              if (cm.state.overwrite && !/\\n/.test(text)) {\n                lastChange.changes.push([text]);\n              } else {\n                lastChange.changes.push(text);\n              }\n            }\n          }\n          // Change objects may be chained with next.\n          changeObj = changeObj.next;\n        }\n      }\n    }\n\n    /**\n    * Listens for any kind of cursor activity on CodeMirror.\n    */\n    function onCursorActivity(cm) {\n      var vim = cm.state.vim;\n      if (vim.insertMode) {\n        // Tracking cursor activity in insert mode (for macro support).\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        var lastChange = macroModeState.lastInsertModeChanges;\n        if (lastChange.expectCursorActivityForChange) {\n          lastChange.expectCursorActivityForChange = false;\n        } else {\n          // Cursor moved outside the context of an edit. Reset the change.\n          lastChange.maybeReset = true;\n        }\n      } else if (!cm.curOp.isVimOp) {\n        handleExternalSelection(cm, vim);\n      }\n    }\n    function handleExternalSelection(cm, vim) {\n      var anchor = cm.getCursor('anchor');\n      var head = cm.getCursor('head');\n      // Enter or exit visual mode to match mouse selection.\n      if (vim.visualMode && !cm.somethingSelected()) {\n        exitVisualMode(cm, false);\n      } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n        vim.visualMode = true;\n        vim.visualLine = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\"});\n      }\n      if (vim.visualMode) {\n        // Bind CodeMirror selection model to vim selection model.\n        // Mouse selections are considered visual characterwise.\n        var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n        var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n        head = offsetCursor(head, 0, headOffset);\n        anchor = offsetCursor(anchor, 0, anchorOffset);\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        updateMark(cm, vim, '<', cursorMin(head, anchor));\n        updateMark(cm, vim, '>', cursorMax(head, anchor));\n      } else if (!vim.insertMode) {\n        // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.\n        vim.lastHPos = cm.getCursor().ch;\n      }\n    }\n\n    /** Wrapper for special keys pressed in insert mode */\n    function InsertModeKey(keyName) {\n      this.keyName = keyName;\n    }\n\n    /**\n    * Handles raw key down events from the text area.\n    * - Should only be active in insert mode.\n    * - For recording deletes in insert mode.\n    */\n    function onKeyEventTargetKeyDown(e) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      var keyName = CodeMirror.keyName(e);\n      if (!keyName) { return; }\n      function onKeyFound() {\n        if (lastChange.maybeReset) {\n          lastChange.changes = [];\n          lastChange.maybeReset = false;\n        }\n        lastChange.changes.push(new InsertModeKey(keyName));\n        return true;\n      }\n      if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n        CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound);\n      }\n    }\n\n    /**\n     * Repeats the last edit, which includes exactly 1 command and at most 1\n     * insert. Operator and motion commands are read from lastEditInputState,\n     * while action commands are read from lastEditActionCommand.\n     *\n     * If repeatForInsert is true, then the function was called by\n     * exitInsertMode to repeat the insert mode changes the user just made. The\n     * corresponding enterInsertMode call was made with a count.\n     */\n    function repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n      var macroModeState = vimGlobalState.macroModeState;\n      macroModeState.isPlaying = true;\n      var isAction = !!vim.lastEditActionCommand;\n      var cachedInputState = vim.inputState;\n      function repeatCommand() {\n        if (isAction) {\n          commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n        } else {\n          commandDispatcher.evalInput(cm, vim);\n        }\n      }\n      function repeatInsert(repeat) {\n        if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n          // For some reason, repeat cw in desktop VIM does not repeat\n          // insert mode changes. Will conform to that behavior.\n          repeat = !vim.lastEditActionCommand ? 1 : repeat;\n          var changeObject = macroModeState.lastInsertModeChanges;\n          repeatInsertModeChanges(cm, changeObject.changes, repeat);\n        }\n      }\n      vim.inputState = vim.lastEditInputState;\n      if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n        // o and O repeat have to be interlaced with insert repeats so that the\n        // insertions appear on separate lines instead of the last line.\n        for (var i = 0; i < repeat; i++) {\n          repeatCommand();\n          repeatInsert(1);\n        }\n      } else {\n        if (!repeatForInsert) {\n          // Hack to get the cursor to end up at the right place. If I is\n          // repeated in insert mode repeat, cursor will be 1 insert\n          // change set left of where it should be.\n          repeatCommand();\n        }\n        repeatInsert(repeat);\n      }\n      vim.inputState = cachedInputState;\n      if (vim.insertMode && !repeatForInsert) {\n        // Don't exit insert mode twice. If repeatForInsert is set, then we\n        // were called by an exitInsertMode call lower on the stack.\n        exitInsertMode(cm);\n      }\n      macroModeState.isPlaying = false;\n    }\n\n    function repeatInsertModeChanges(cm, changes, repeat) {\n      function keyHandler(binding) {\n        if (typeof binding == 'string') {\n          CodeMirror.commands[binding](cm);\n        } else {\n          binding(cm);\n        }\n        return true;\n      }\n      var head = cm.getCursor('head');\n      var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;\n      if (visualBlock) {\n        // Set up block selection again for repeating the changes.\n        selectForInsert(cm, head, visualBlock + 1);\n        repeat = cm.listSelections().length;\n        cm.setCursor(head);\n      }\n      for (var i = 0; i < repeat; i++) {\n        if (visualBlock) {\n          cm.setCursor(offsetCursor(head, i, 0));\n        }\n        for (var j = 0; j < changes.length; j++) {\n          var change = changes[j];\n          if (change instanceof InsertModeKey) {\n            CodeMirror.lookupKey(change.keyName, 'vim-insert', keyHandler);\n          } else if (typeof change == \"string\") {\n            cm.replaceSelection(change);\n          } else {\n            var start = cm.getCursor();\n            var end = offsetCursor(start, 0, change[0].length);\n            cm.replaceRange(change[0], start, end);\n            cm.setCursor(end);\n          }\n        }\n      }\n      if (visualBlock) {\n        cm.setCursor(offsetCursor(head, 0, 1));\n      }\n    }\n\n    // multiselect support\n    function cloneVimState(state) {\n      var n = new state.constructor();\n      Object.keys(state).forEach(function(key) {\n        var o = state[key];\n        if (Array.isArray(o))\n          o = o.slice();\n        else if (o && typeof o == \"object\" && o.constructor != Object)\n          o = cloneVimState(o);\n        n[key] = o;\n      });\n      if (state.sel) {\n        n.sel = {\n          head: state.sel.head && copyCursor(state.sel.head),\n          anchor: state.sel.anchor && copyCursor(state.sel.anchor)\n        };\n      }\n      return n;\n    }\n    function multiSelectHandleKey(cm, key, origin) {\n      var isHandled = false;\n      var vim = vimApi.maybeInitVimState_(cm);\n      var visualBlock = vim.visualBlock || vim.wasInVisualBlock;\n\n      var wasMultiselect = cm.isInMultiSelectMode();\n      if (vim.wasInVisualBlock && !wasMultiselect) {\n        vim.wasInVisualBlock = false;\n      } else if (wasMultiselect && vim.visualBlock) {\n         vim.wasInVisualBlock = true;\n      }\n\n      if (key == '<Esc>' && !vim.insertMode && !vim.visualMode && wasMultiselect && vim.status == \"<Esc>\") {\n        // allow editor to exit multiselect\n        clearInputState(cm);\n      } else if (visualBlock || !wasMultiselect || cm.inVirtualSelectionMode) {\n        isHandled = vimApi.handleKey(cm, key, origin);\n      } else {\n        var old = cloneVimState(vim);\n\n        cm.operation(function() {\n          cm.curOp.isVimOp = true;\n          cm.forEachSelection(function() {\n            var head = cm.getCursor(\"head\");\n            var anchor = cm.getCursor(\"anchor\");\n            var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n            var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n            head = offsetCursor(head, 0, headOffset);\n            anchor = offsetCursor(anchor, 0, anchorOffset);\n            cm.state.vim.sel.head = head;\n            cm.state.vim.sel.anchor = anchor;\n\n            isHandled = vimApi.handleKey(cm, key, origin);\n            if (cm.virtualSelection) {\n              cm.state.vim = cloneVimState(old);\n            }\n          });\n          if (cm.curOp.cursorActivity && !isHandled)\n            cm.curOp.cursorActivity = false;\n          cm.state.vim = vim;\n        }, true);\n      }\n      // some commands may bring visualMode and selection out of sync\n      if (isHandled && !vim.visualMode && !vim.insert && vim.visualMode != cm.somethingSelected()) {\n        handleExternalSelection(cm, vim);\n      }\n      return isHandled;\n    }\n    resetVimGlobalState();\n\n  return vimApi;\n}\n\nfunction initVim(CodeMirror5) {\r\n  CodeMirror5.Vim = initVim$1(CodeMirror5);\r\n  return CodeMirror5.Vim;\r\n}\n\n\n\n    CodeMirror.Vim = initVim(CodeMirror);\n  });\n  ","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var statementIndent = parserConfig.statementIndent;\n  var jsonldMode = parserConfig.jsonld;\n  var jsonMode = parserConfig.json || jsonldMode;\n  var trackScope = parserConfig.trackScope !== false\n  var isTS = parserConfig.typescript;\n  var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n\n  // Tokenizer\n\n  var keywords = function(){\n    function kw(type) {return {type: type, style: \"keyword\"};}\n    var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\"), D = kw(\"keyword d\");\n    var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"};\n\n    return {\n      \"if\": kw(\"if\"), \"while\": A, \"with\": A, \"else\": B, \"do\": B, \"try\": B, \"finally\": B,\n      \"return\": D, \"break\": D, \"continue\": D, \"new\": kw(\"new\"), \"delete\": C, \"void\": C, \"throw\": C,\n      \"debugger\": kw(\"debugger\"), \"var\": kw(\"var\"), \"const\": kw(\"var\"), \"let\": kw(\"var\"),\n      \"function\": kw(\"function\"), \"catch\": kw(\"catch\"),\n      \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n      \"in\": operator, \"typeof\": operator, \"instanceof\": operator,\n      \"true\": atom, \"false\": atom, \"null\": atom, \"undefined\": atom, \"NaN\": atom, \"Infinity\": atom,\n      \"this\": kw(\"this\"), \"class\": kw(\"class\"), \"super\": kw(\"atom\"),\n      \"yield\": C, \"export\": kw(\"export\"), \"import\": kw(\"import\"), \"extends\": C,\n      \"await\": C\n    };\n  }();\n\n  var isOperatorChar = /[+\\-*&%=<>!?|~^@]/;\n  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n\n  function readRegexp(stream) {\n    var escaped = false, next, inSet = false;\n    while ((next = stream.next()) != null) {\n      if (!escaped) {\n        if (next == \"/\" && !inSet) return;\n        if (next == \"[\") inSet = true;\n        else if (inSet && next == \"]\") inSet = false;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == \".\" && stream.match(/^\\d[\\d_]*(?:[eE][+\\-]?[\\d_]+)?/)) {\n      return ret(\"number\", \"number\");\n    } else if (ch == \".\" && stream.match(\"..\")) {\n      return ret(\"spread\", \"meta\");\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      return ret(ch);\n    } else if (ch == \"=\" && stream.eat(\">\")) {\n      return ret(\"=>\", \"operator\");\n    } else if (ch == \"0\" && stream.match(/^(?:x[\\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {\n      return ret(\"number\", \"number\");\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^[\\d_]*(?:n|(?:\\.[\\d_]*)?(?:[eE][+\\-]?[\\d_]+)?)?/);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      } else if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return ret(\"comment\", \"comment\");\n      } else if (expressionAllowed(stream, state, 1)) {\n        readRegexp(stream);\n        stream.match(/^\\b(([gimyus])(?![gimyus]*\\2))+\\b/);\n        return ret(\"regexp\", \"string-2\");\n      } else {\n        stream.eat(\"=\");\n        return ret(\"operator\", \"operator\", stream.current());\n      }\n    } else if (ch == \"`\") {\n      state.tokenize = tokenQuasi;\n      return tokenQuasi(stream, state);\n    } else if (ch == \"#\" && stream.peek() == \"!\") {\n      stream.skipToEnd();\n      return ret(\"meta\", \"meta\");\n    } else if (ch == \"#\" && stream.eatWhile(wordRE)) {\n      return ret(\"variable\", \"property\")\n    } else if (ch == \"<\" && stream.match(\"!--\") ||\n               (ch == \"-\" && stream.match(\"->\") && !/\\S/.test(stream.string.slice(0, stream.start)))) {\n      stream.skipToEnd()\n      return ret(\"comment\", \"comment\")\n    } else if (isOperatorChar.test(ch)) {\n      if (ch != \">\" || !state.lexical || state.lexical.type != \">\") {\n        if (stream.eat(\"=\")) {\n          if (ch == \"!\" || ch == \"=\") stream.eat(\"=\")\n        } else if (/[<>*+\\-|&?]/.test(ch)) {\n          stream.eat(ch)\n          if (ch == \">\") stream.eat(ch)\n        }\n      }\n      if (ch == \"?\" && stream.eat(\".\")) return ret(\".\")\n      return ret(\"operator\", \"operator\", stream.current());\n    } else if (wordRE.test(ch)) {\n      stream.eatWhile(wordRE);\n      var word = stream.current()\n      if (state.lastType != \".\") {\n        if (keywords.propertyIsEnumerable(word)) {\n          var kw = keywords[word]\n          return ret(kw.type, kw.style, word)\n        }\n        if (word == \"async\" && stream.match(/^(\\s|\\/\\*([^*]|\\*(?!\\/))*?\\*\\/)*[\\[\\(\\w]/, false))\n          return ret(\"async\", \"keyword\", word)\n      }\n      return ret(\"variable\", \"variable\", word)\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next;\n      if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)){\n        state.tokenize = tokenBase;\n        return ret(\"jsonld-keyword\", \"meta\");\n      }\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) break;\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (!escaped) state.tokenize = tokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  function tokenQuasi(stream, state) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    return ret(\"quasi\", \"string-2\", stream.current());\n  }\n\n  var brackets = \"([{}])\";\n  // This is a crude lookahead trick to try and notice that we're\n  // parsing the argument patterns for a fat-arrow function before we\n  // actually hit the arrow token. It only works if the arrow is on\n  // the same line as the arguments and there's no strange noise\n  // (comments) in between. Fallback is to only notice when we hit the\n  // arrow, and not declare the arguments as locals for the arrow\n  // body.\n  function findFatArrow(stream, state) {\n    if (state.fatArrowAt) state.fatArrowAt = null;\n    var arrow = stream.string.indexOf(\"=>\", stream.start);\n    if (arrow < 0) return;\n\n    if (isTS) { // Try to skip TypeScript return type declarations after the arguments\n      var m = /:\\s*(?:\\w+(?:<[^>]*>|\\[\\])?|\\{[^}]*\\})\\s*$/.exec(stream.string.slice(stream.start, arrow))\n      if (m) arrow = m.index\n    }\n\n    var depth = 0, sawSomething = false;\n    for (var pos = arrow - 1; pos >= 0; --pos) {\n      var ch = stream.string.charAt(pos);\n      var bracket = brackets.indexOf(ch);\n      if (bracket >= 0 && bracket < 3) {\n        if (!depth) { ++pos; break; }\n        if (--depth == 0) { if (ch == \"(\") sawSomething = true; break; }\n      } else if (bracket >= 3 && bracket < 6) {\n        ++depth;\n      } else if (wordRE.test(ch)) {\n        sawSomething = true;\n      } else if (/[\"'\\/`]/.test(ch)) {\n        for (;; --pos) {\n          if (pos == 0) return\n          var next = stream.string.charAt(pos - 1)\n          if (next == ch && stream.string.charAt(pos - 2) != \"\\\\\") { pos--; break }\n        }\n      } else if (sawSomething && !depth) {\n        ++pos;\n        break;\n      }\n    }\n    if (sawSomething && !depth) state.fatArrowAt = pos;\n  }\n\n  // Parser\n\n  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true,\n                     \"regexp\": true, \"this\": true, \"import\": true, \"jsonld-keyword\": true};\n\n  function JSLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    if (!trackScope) return false\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n    for (var cx = state.context; cx; cx = cx.prev) {\n      for (var v = cx.vars; v; v = v.next)\n        if (v.name == varname) return true;\n    }\n  }\n\n  function parseJS(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;\n\n    if (!state.lexical.hasOwnProperty(\"align\"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n        return style;\n      }\n    }\n  }\n\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function inList(name, list) {\n    for (var v = list; v; v = v.next) if (v.name == name) return true\n    return false;\n  }\n  function register(varname) {\n    var state = cx.state;\n    cx.marked = \"def\";\n    if (!trackScope) return\n    if (state.context) {\n      if (state.lexical.info == \"var\" && state.context && state.context.block) {\n        // FIXME function decls are also not block scoped\n        var newContext = registerVarScoped(varname, state.context)\n        if (newContext != null) {\n          state.context = newContext\n          return\n        }\n      } else if (!inList(varname, state.localVars)) {\n        state.localVars = new Var(varname, state.localVars)\n        return\n      }\n    }\n    // Fall through means this is global\n    if (parserConfig.globalVars && !inList(varname, state.globalVars))\n      state.globalVars = new Var(varname, state.globalVars)\n  }\n  function registerVarScoped(varname, context) {\n    if (!context) {\n      return null\n    } else if (context.block) {\n      var inner = registerVarScoped(varname, context.prev)\n      if (!inner) return null\n      if (inner == context.prev) return context\n      return new Context(inner, context.vars, true)\n    } else if (inList(varname, context.vars)) {\n      return context\n    } else {\n      return new Context(context.prev, new Var(varname, context.vars), false)\n    }\n  }\n\n  function isModifier(name) {\n    return name == \"public\" || name == \"private\" || name == \"protected\" || name == \"abstract\" || name == \"readonly\"\n  }\n\n  // Combinators\n\n  function Context(prev, vars, block) { this.prev = prev; this.vars = vars; this.block = block }\n  function Var(name, next) { this.name = name; this.next = next }\n\n  var defaultVars = new Var(\"this\", new Var(\"arguments\", null))\n  function pushcontext() {\n    cx.state.context = new Context(cx.state.context, cx.state.localVars, false)\n    cx.state.localVars = defaultVars\n  }\n  function pushblockcontext() {\n    cx.state.context = new Context(cx.state.context, cx.state.localVars, true)\n    cx.state.localVars = null\n  }\n  pushcontext.lex = pushblockcontext.lex = true\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars\n    cx.state.context = cx.state.context.prev\n  }\n  popcontext.lex = true\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state, indent = state.indented;\n      if (state.lexical.type == \"stat\") indent = state.lexical.indented;\n      else for (var outer = state.lexical; outer && outer.type == \")\" && outer.align; outer = outer.prev)\n        indent = outer.indented;\n      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == \")\")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    function exp(type) {\n      if (type == wanted) return cont();\n      else if (wanted == \";\" || type == \"}\" || type == \")\" || type == \"]\") return pass();\n      else return cont(exp);\n    };\n    return exp;\n  }\n\n  function statement(type, value) {\n    if (type == \"var\") return cont(pushlex(\"vardef\", value), vardef, expect(\";\"), poplex);\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), parenExpr, statement, poplex);\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n    if (type == \"keyword d\") return cx.stream.match(/^\\s*$/, false) ? cont() : cont(pushlex(\"stat\"), maybeexpression, expect(\";\"), poplex);\n    if (type == \"debugger\") return cont(expect(\";\"));\n    if (type == \"{\") return cont(pushlex(\"}\"), pushblockcontext, block, poplex, popcontext);\n    if (type == \";\") return cont();\n    if (type == \"if\") {\n      if (cx.state.lexical.info == \"else\" && cx.state.cc[cx.state.cc.length - 1] == poplex)\n        cx.state.cc.pop()();\n      return cont(pushlex(\"form\"), parenExpr, statement, poplex, maybeelse);\n    }\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"for\") return cont(pushlex(\"form\"), pushblockcontext, forspec, statement, popcontext, poplex);\n    if (type == \"class\" || (isTS && value == \"interface\")) {\n      cx.marked = \"keyword\"\n      return cont(pushlex(\"form\", type == \"class\" ? type : value), className, poplex)\n    }\n    if (type == \"variable\") {\n      if (isTS && value == \"declare\") {\n        cx.marked = \"keyword\"\n        return cont(statement)\n      } else if (isTS && (value == \"module\" || value == \"enum\" || value == \"type\") && cx.stream.match(/^\\s*\\w/, false)) {\n        cx.marked = \"keyword\"\n        if (value == \"enum\") return cont(enumdef);\n        else if (value == \"type\") return cont(typename, expect(\"operator\"), typeexpr, expect(\";\"));\n        else return cont(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), block, poplex, poplex)\n      } else if (isTS && value == \"namespace\") {\n        cx.marked = \"keyword\"\n        return cont(pushlex(\"form\"), expression, statement, poplex)\n      } else if (isTS && value == \"abstract\") {\n        cx.marked = \"keyword\"\n        return cont(statement)\n      } else {\n        return cont(pushlex(\"stat\"), maybelabel);\n      }\n    }\n    if (type == \"switch\") return cont(pushlex(\"form\"), parenExpr, expect(\"{\"), pushlex(\"}\", \"switch\"), pushblockcontext,\n                                      block, poplex, poplex, popcontext);\n    if (type == \"case\") return cont(expression, expect(\":\"));\n    if (type == \"default\") return cont(expect(\":\"));\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);\n    if (type == \"export\") return cont(pushlex(\"stat\"), afterExport, poplex);\n    if (type == \"import\") return cont(pushlex(\"stat\"), afterImport, poplex);\n    if (type == \"async\") return cont(statement)\n    if (value == \"@\") return cont(expression, statement)\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n  }\n  function maybeCatchBinding(type) {\n    if (type == \"(\") return cont(funarg, expect(\")\"))\n  }\n  function expression(type, value) {\n    return expressionInner(type, value, false);\n  }\n  function expressionNoComma(type, value) {\n    return expressionInner(type, value, true);\n  }\n  function parenExpr(type) {\n    if (type != \"(\") return pass()\n    return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex)\n  }\n  function expressionInner(type, value, noComma) {\n    if (cx.state.fatArrowAt == cx.stream.start) {\n      var body = noComma ? arrowBodyNoComma : arrowBody;\n      if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, expect(\"=>\"), body, popcontext);\n      else if (type == \"variable\") return pass(pushcontext, pattern, expect(\"=>\"), body, popcontext);\n    }\n\n    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n    if (type == \"function\") return cont(functiondef, maybeop);\n    if (type == \"class\" || (isTS && value == \"interface\")) { cx.marked = \"keyword\"; return cont(pushlex(\"form\"), classExpression, poplex); }\n    if (type == \"keyword c\" || type == \"async\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeop);\n    if (type == \"operator\" || type == \"spread\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"[\") return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\n    if (type == \"{\") return contCommasep(objprop, \"}\", null, maybeop);\n    if (type == \"quasi\") return pass(quasi, maybeop);\n    if (type == \"new\") return cont(maybeTarget(noComma));\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n\n  function maybeoperatorComma(type, value) {\n    if (type == \",\") return cont(maybeexpression);\n    return maybeoperatorNoComma(type, value, false);\n  }\n  function maybeoperatorNoComma(type, value, noComma) {\n    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n    var expr = noComma == false ? expression : expressionNoComma;\n    if (type == \"=>\") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n    if (type == \"operator\") {\n      if (/\\+\\+|--/.test(value) || isTS && value == \"!\") return cont(me);\n      if (isTS && value == \"<\" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\\s*\\(/, false))\n        return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, me);\n      if (value == \"?\") return cont(expression, expect(\":\"), expr);\n      return cont(expr);\n    }\n    if (type == \"quasi\") { return pass(quasi, me); }\n    if (type == \";\") return;\n    if (type == \"(\") return contCommasep(expressionNoComma, \")\", \"call\", me);\n    if (type == \".\") return cont(property, me);\n    if (type == \"[\") return cont(pushlex(\"]\"), maybeexpression, expect(\"]\"), poplex, me);\n    if (isTS && value == \"as\") { cx.marked = \"keyword\"; return cont(typeexpr, me) }\n    if (type == \"regexp\") {\n      cx.state.lastType = cx.marked = \"operator\"\n      cx.stream.backUp(cx.stream.pos - cx.stream.start - 1)\n      return cont(expr)\n    }\n  }\n  function quasi(type, value) {\n    if (type != \"quasi\") return pass();\n    if (value.slice(value.length - 2) != \"${\") return cont(quasi);\n    return cont(maybeexpression, continueQuasi);\n  }\n  function continueQuasi(type) {\n    if (type == \"}\") {\n      cx.marked = \"string-2\";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasi);\n    }\n  }\n  function arrowBody(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expression);\n  }\n  function arrowBodyNoComma(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expressionNoComma);\n  }\n  function maybeTarget(noComma) {\n    return function(type) {\n      if (type == \".\") return cont(noComma ? targetNoComma : target);\n      else if (type == \"variable\" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)\n      else return pass(noComma ? expressionNoComma : expression);\n    };\n  }\n  function target(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorComma); }\n  }\n  function targetNoComma(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorNoComma); }\n  }\n  function maybelabel(type) {\n    if (type == \":\") return cont(poplex, statement);\n    return pass(maybeoperatorComma, expect(\";\"), poplex);\n  }\n  function property(type) {\n    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n  }\n  function objprop(type, value) {\n    if (type == \"async\") {\n      cx.marked = \"property\";\n      return cont(objprop);\n    } else if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      if (value == \"get\" || value == \"set\") return cont(getterSetter);\n      var m // Work around fat-arrow-detection complication for detecting typescript typed arrow params\n      if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\\s*:\\s*/, false)))\n        cx.state.fatArrowAt = cx.stream.pos + m[0].length\n      return cont(afterprop);\n    } else if (type == \"number\" || type == \"string\") {\n      cx.marked = jsonldMode ? \"property\" : (cx.style + \" property\");\n      return cont(afterprop);\n    } else if (type == \"jsonld-keyword\") {\n      return cont(afterprop);\n    } else if (isTS && isModifier(value)) {\n      cx.marked = \"keyword\"\n      return cont(objprop)\n    } else if (type == \"[\") {\n      return cont(expression, maybetype, expect(\"]\"), afterprop);\n    } else if (type == \"spread\") {\n      return cont(expressionNoComma, afterprop);\n    } else if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(objprop);\n    } else if (type == \":\") {\n      return pass(afterprop)\n    }\n  }\n  function getterSetter(type) {\n    if (type != \"variable\") return pass(afterprop);\n    cx.marked = \"property\";\n    return cont(functiondef);\n  }\n  function afterprop(type) {\n    if (type == \":\") return cont(expressionNoComma);\n    if (type == \"(\") return pass(functiondef);\n  }\n  function commasep(what, end, sep) {\n    function proceed(type, value) {\n      if (sep ? sep.indexOf(type) > -1 : type == \",\") {\n        var lex = cx.state.lexical;\n        if (lex.info == \"call\") lex.pos = (lex.pos || 0) + 1;\n        return cont(function(type, value) {\n          if (type == end || value == end) return pass()\n          return pass(what)\n        }, proceed);\n      }\n      if (type == end || value == end) return cont();\n      if (sep && sep.indexOf(\";\") > -1) return pass(what)\n      return cont(expect(end));\n    }\n    return function(type, value) {\n      if (type == end || value == end) return cont();\n      return pass(what, proceed);\n    };\n  }\n  function contCommasep(what, end, info) {\n    for (var i = 3; i < arguments.length; i++)\n      cx.cc.push(arguments[i]);\n    return cont(pushlex(end, info), commasep(what, end), poplex);\n  }\n  function block(type) {\n    if (type == \"}\") return cont();\n    return pass(statement, block);\n  }\n  function maybetype(type, value) {\n    if (isTS) {\n      if (type == \":\") return cont(typeexpr);\n      if (value == \"?\") return cont(maybetype);\n    }\n  }\n  function maybetypeOrIn(type, value) {\n    if (isTS && (type == \":\" || value == \"in\")) return cont(typeexpr)\n  }\n  function mayberettype(type) {\n    if (isTS && type == \":\") {\n      if (cx.stream.match(/^\\s*\\w+\\s+is\\b/, false)) return cont(expression, isKW, typeexpr)\n      else return cont(typeexpr)\n    }\n  }\n  function isKW(_, value) {\n    if (value == \"is\") {\n      cx.marked = \"keyword\"\n      return cont()\n    }\n  }\n  function typeexpr(type, value) {\n    if (value == \"keyof\" || value == \"typeof\" || value == \"infer\" || value == \"readonly\") {\n      cx.marked = \"keyword\"\n      return cont(value == \"typeof\" ? expressionNoComma : typeexpr)\n    }\n    if (type == \"variable\" || value == \"void\") {\n      cx.marked = \"type\"\n      return cont(afterType)\n    }\n    if (value == \"|\" || value == \"&\") return cont(typeexpr)\n    if (type == \"string\" || type == \"number\" || type == \"atom\") return cont(afterType);\n    if (type == \"[\") return cont(pushlex(\"]\"), commasep(typeexpr, \"]\", \",\"), poplex, afterType)\n    if (type == \"{\") return cont(pushlex(\"}\"), typeprops, poplex, afterType)\n    if (type == \"(\") return cont(commasep(typearg, \")\"), maybeReturnType, afterType)\n    if (type == \"<\") return cont(commasep(typeexpr, \">\"), typeexpr)\n    if (type == \"quasi\") { return pass(quasiType, afterType); }\n  }\n  function maybeReturnType(type) {\n    if (type == \"=>\") return cont(typeexpr)\n  }\n  function typeprops(type) {\n    if (type.match(/[\\}\\)\\]]/)) return cont()\n    if (type == \",\" || type == \";\") return cont(typeprops)\n    return pass(typeprop, typeprops)\n  }\n  function typeprop(type, value) {\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\"\n      return cont(typeprop)\n    } else if (value == \"?\" || type == \"number\" || type == \"string\") {\n      return cont(typeprop)\n    } else if (type == \":\") {\n      return cont(typeexpr)\n    } else if (type == \"[\") {\n      return cont(expect(\"variable\"), maybetypeOrIn, expect(\"]\"), typeprop)\n    } else if (type == \"(\") {\n      return pass(functiondecl, typeprop)\n    } else if (!type.match(/[;\\}\\)\\],]/)) {\n      return cont()\n    }\n  }\n  function quasiType(type, value) {\n    if (type != \"quasi\") return pass();\n    if (value.slice(value.length - 2) != \"${\") return cont(quasiType);\n    return cont(typeexpr, continueQuasiType);\n  }\n  function continueQuasiType(type) {\n    if (type == \"}\") {\n      cx.marked = \"string-2\";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasiType);\n    }\n  }\n  function typearg(type, value) {\n    if (type == \"variable\" && cx.stream.match(/^\\s*[?:]/, false) || value == \"?\") return cont(typearg)\n    if (type == \":\") return cont(typeexpr)\n    if (type == \"spread\") return cont(typearg)\n    return pass(typeexpr)\n  }\n  function afterType(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n    if (value == \"|\" || type == \".\" || value == \"&\") return cont(typeexpr)\n    if (type == \"[\") return cont(typeexpr, expect(\"]\"), afterType)\n    if (value == \"extends\" || value == \"implements\") { cx.marked = \"keyword\"; return cont(typeexpr) }\n    if (value == \"?\") return cont(typeexpr, expect(\":\"), typeexpr)\n  }\n  function maybeTypeArgs(_, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n  }\n  function typeparam() {\n    return pass(typeexpr, maybeTypeDefault)\n  }\n  function maybeTypeDefault(_, value) {\n    if (value == \"=\") return cont(typeexpr)\n  }\n  function vardef(_, value) {\n    if (value == \"enum\") {cx.marked = \"keyword\"; return cont(enumdef)}\n    return pass(pattern, maybetype, maybeAssign, vardefCont);\n  }\n  function pattern(type, value) {\n    if (isTS && isModifier(value)) { cx.marked = \"keyword\"; return cont(pattern) }\n    if (type == \"variable\") { register(value); return cont(); }\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"[\") return contCommasep(eltpattern, \"]\");\n    if (type == \"{\") return contCommasep(proppattern, \"}\");\n  }\n  function proppattern(type, value) {\n    if (type == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\n      register(value);\n      return cont(maybeAssign);\n    }\n    if (type == \"variable\") cx.marked = \"property\";\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"}\") return pass();\n    if (type == \"[\") return cont(expression, expect(']'), expect(':'), proppattern);\n    return cont(expect(\":\"), pattern, maybeAssign);\n  }\n  function eltpattern() {\n    return pass(pattern, maybeAssign)\n  }\n  function maybeAssign(_type, value) {\n    if (value == \"=\") return cont(expressionNoComma);\n  }\n  function vardefCont(type) {\n    if (type == \",\") return cont(vardef);\n  }\n  function maybeelse(type, value) {\n    if (type == \"keyword b\" && value == \"else\") return cont(pushlex(\"form\", \"else\"), statement, poplex);\n  }\n  function forspec(type, value) {\n    if (value == \"await\") return cont(forspec);\n    if (type == \"(\") return cont(pushlex(\")\"), forspec1, poplex);\n  }\n  function forspec1(type) {\n    if (type == \"var\") return cont(vardef, forspec2);\n    if (type == \"variable\") return cont(forspec2);\n    return pass(forspec2)\n  }\n  function forspec2(type, value) {\n    if (type == \")\") return cont()\n    if (type == \";\") return cont(forspec2)\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression, forspec2) }\n    return pass(expression, forspec2)\n  }\n  function functiondef(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondef);}\n    if (type == \"variable\") {register(value); return cont(functiondef);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, statement, popcontext);\n    if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondef)\n  }\n  function functiondecl(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondecl);}\n    if (type == \"variable\") {register(value); return cont(functiondecl);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, popcontext);\n    if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondecl)\n  }\n  function typename(type, value) {\n    if (type == \"keyword\" || type == \"variable\") {\n      cx.marked = \"type\"\n      return cont(typename)\n    } else if (value == \"<\") {\n      return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex)\n    }\n  }\n  function funarg(type, value) {\n    if (value == \"@\") cont(expression, funarg)\n    if (type == \"spread\") return cont(funarg);\n    if (isTS && isModifier(value)) { cx.marked = \"keyword\"; return cont(funarg); }\n    if (isTS && type == \"this\") return cont(maybetype, maybeAssign)\n    return pass(pattern, maybetype, maybeAssign);\n  }\n  function classExpression(type, value) {\n    // Class expressions may have an optional name.\n    if (type == \"variable\") return className(type, value);\n    return classNameAfter(type, value);\n  }\n  function className(type, value) {\n    if (type == \"variable\") {register(value); return cont(classNameAfter);}\n  }\n  function classNameAfter(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, classNameAfter)\n    if (value == \"extends\" || value == \"implements\" || (isTS && type == \",\")) {\n      if (value == \"implements\") cx.marked = \"keyword\";\n      return cont(isTS ? typeexpr : expression, classNameAfter);\n    }\n    if (type == \"{\") return cont(pushlex(\"}\"), classBody, poplex);\n  }\n  function classBody(type, value) {\n    if (type == \"async\" ||\n        (type == \"variable\" &&\n         (value == \"static\" || value == \"get\" || value == \"set\" || (isTS && isModifier(value))) &&\n         cx.stream.match(/^\\s+#?[\\w$\\xa1-\\uffff]/, false))) {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      return cont(classfield, classBody);\n    }\n    if (type == \"number\" || type == \"string\") return cont(classfield, classBody);\n    if (type == \"[\")\n      return cont(expression, maybetype, expect(\"]\"), classfield, classBody)\n    if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (isTS && type == \"(\") return pass(functiondecl, classBody)\n    if (type == \";\" || type == \",\") return cont(classBody);\n    if (type == \"}\") return cont();\n    if (value == \"@\") return cont(expression, classBody)\n  }\n  function classfield(type, value) {\n    if (value == \"!\") return cont(classfield)\n    if (value == \"?\") return cont(classfield)\n    if (type == \":\") return cont(typeexpr, maybeAssign)\n    if (value == \"=\") return cont(expressionNoComma)\n    var context = cx.state.lexical.prev, isInterface = context && context.info == \"interface\"\n    return pass(isInterface ? functiondecl : functiondef)\n  }\n  function afterExport(type, value) {\n    if (value == \"*\") { cx.marked = \"keyword\"; return cont(maybeFrom, expect(\";\")); }\n    if (value == \"default\") { cx.marked = \"keyword\"; return cont(expression, expect(\";\")); }\n    if (type == \"{\") return cont(commasep(exportField, \"}\"), maybeFrom, expect(\";\"));\n    return pass(statement);\n  }\n  function exportField(type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(expect(\"variable\")); }\n    if (type == \"variable\") return pass(expressionNoComma, exportField);\n  }\n  function afterImport(type) {\n    if (type == \"string\") return cont();\n    if (type == \"(\") return pass(expression);\n    if (type == \".\") return pass(maybeoperatorComma);\n    return pass(importSpec, maybeMoreImports, maybeFrom);\n  }\n  function importSpec(type, value) {\n    if (type == \"{\") return contCommasep(importSpec, \"}\");\n    if (type == \"variable\") register(value);\n    if (value == \"*\") cx.marked = \"keyword\";\n    return cont(maybeAs);\n  }\n  function maybeMoreImports(type) {\n    if (type == \",\") return cont(importSpec, maybeMoreImports)\n  }\n  function maybeAs(_type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(importSpec); }\n  }\n  function maybeFrom(_type, value) {\n    if (value == \"from\") { cx.marked = \"keyword\"; return cont(expression); }\n  }\n  function arrayLiteral(type) {\n    if (type == \"]\") return cont();\n    return pass(commasep(expressionNoComma, \"]\"));\n  }\n  function enumdef() {\n    return pass(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), commasep(enummember, \"}\"), poplex, poplex)\n  }\n  function enummember() {\n    return pass(pattern, maybeAssign);\n  }\n\n  function isContinuedStatement(state, textAfter) {\n    return state.lastType == \"operator\" || state.lastType == \",\" ||\n      isOperatorChar.test(textAfter.charAt(0)) ||\n      /[,.]/.test(textAfter.charAt(0));\n  }\n\n  function expressionAllowed(stream, state, backUp) {\n    return state.tokenize == tokenBase &&\n      /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\\[{}\\(,;:]|=>)$/.test(state.lastType) ||\n      (state.lastType == \"quasi\" && /\\{\\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      var state = {\n        tokenize: tokenBase,\n        lastType: \"sof\",\n        cc: [],\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n        localVars: parserConfig.localVars,\n        context: parserConfig.localVars && new Context(null, null, false),\n        indented: basecolumn || 0\n      };\n      if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\n        state.globalVars = parserConfig.globalVars;\n      return state;\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty(\"align\"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n        findFatArrow(stream, state);\n      }\n      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == \"comment\") return style;\n      state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\n      return parseJS(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize == tokenComment || state.tokenize == tokenQuasi) return CodeMirror.Pass;\n      if (state.tokenize != tokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top\n      // Kludge to prevent 'maybelse' from blocking lexical scope pops\n      if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {\n        var c = state.cc[i];\n        if (c == poplex) lexical = lexical.prev;\n        else if (c != maybeelse && c != popcontext) break;\n      }\n      while ((lexical.type == \"stat\" || lexical.type == \"form\") &&\n             (firstChar == \"}\" || ((top = state.cc[state.cc.length - 1]) &&\n                                   (top == maybeoperatorComma || top == maybeoperatorNoComma) &&\n                                   !/^[,\\.=+\\-*:?[\\(]/.test(textAfter))))\n        lexical = lexical.prev;\n      if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\")\n        lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n\n      if (type == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info.length + 1 : 0);\n      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n      else if (type == \"form\") return lexical.indented + indentUnit;\n      else if (type == \"stat\")\n        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);\n      else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n    blockCommentStart: jsonMode ? null : \"/*\",\n    blockCommentEnd: jsonMode ? null : \"*/\",\n    blockCommentContinue: jsonMode ? null : \" * \",\n    lineComment: jsonMode ? null : \"//\",\n    fold: \"brace\",\n    closeBrackets: \"()[]{}''\\\"\\\"``\",\n\n    helperType: jsonMode ? \"json\" : \"javascript\",\n    jsonldMode: jsonldMode,\n    jsonMode: jsonMode,\n\n    expressionAllowed: expressionAllowed,\n\n    skipExpression: function(state) {\n      parseJS(state, \"atom\", \"atom\", \"true\", new CodeMirror.StringStream(\"\", 2, null))\n    }\n  };\n});\n\nCodeMirror.registerHelper(\"wordChars\", \"javascript\", /[\\w$]/);\n\nCodeMirror.defineMIME(\"text/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/x-javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/json\", { name: \"javascript\", json: true });\nCodeMirror.defineMIME(\"application/x-json\", { name: \"javascript\", json: true });\nCodeMirror.defineMIME(\"application/manifest+json\", { name: \"javascript\", json: true })\nCodeMirror.defineMIME(\"application/ld+json\", { name: \"javascript\", jsonld: true });\nCodeMirror.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: true });\nCodeMirror.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: true });\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"yaml\", function() {\n\n  var cons = ['true', 'false', 'on', 'off', 'yes', 'no'];\n  var keywordRegex = new RegExp(\"\\\\b((\"+cons.join(\")|(\")+\"))$\", 'i');\n\n  return {\n    token: function(stream, state) {\n      var ch = stream.peek();\n      var esc = state.escaped;\n      state.escaped = false;\n      /* comments */\n      if (ch == \"#\" && (stream.pos == 0 || /\\s/.test(stream.string.charAt(stream.pos - 1)))) {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n\n      if (stream.match(/^('([^']|\\\\.)*'?|\"([^\"]|\\\\.)*\"?)/))\n        return \"string\";\n\n      if (state.literal && stream.indentation() > state.keyCol) {\n        stream.skipToEnd(); return \"string\";\n      } else if (state.literal) { state.literal = false; }\n      if (stream.sol()) {\n        state.keyCol = 0;\n        state.pair = false;\n        state.pairStart = false;\n        /* document start */\n        if(stream.match('---')) { return \"def\"; }\n        /* document end */\n        if (stream.match('...')) { return \"def\"; }\n        /* array list item */\n        if (stream.match(/\\s*-\\s+/)) { return 'meta'; }\n      }\n      /* inline pairs/lists */\n      if (stream.match(/^(\\{|\\}|\\[|\\])/)) {\n        if (ch == '{')\n          state.inlinePairs++;\n        else if (ch == '}')\n          state.inlinePairs--;\n        else if (ch == '[')\n          state.inlineList++;\n        else\n          state.inlineList--;\n        return 'meta';\n      }\n\n      /* list separator */\n      if (state.inlineList > 0 && !esc && ch == ',') {\n        stream.next();\n        return 'meta';\n      }\n      /* pairs separator */\n      if (state.inlinePairs > 0 && !esc && ch == ',') {\n        state.keyCol = 0;\n        state.pair = false;\n        state.pairStart = false;\n        stream.next();\n        return 'meta';\n      }\n\n      /* start of value of a pair */\n      if (state.pairStart) {\n        /* block literals */\n        if (stream.match(/^\\s*(\\||\\>)\\s*/)) { state.literal = true; return 'meta'; };\n        /* references */\n        if (stream.match(/^\\s*(\\&|\\*)[a-z0-9\\._-]+\\b/i)) { return 'variable-2'; }\n        /* numbers */\n        if (state.inlinePairs == 0 && stream.match(/^\\s*-?[0-9\\.\\,]+\\s?$/)) { return 'number'; }\n        if (state.inlinePairs > 0 && stream.match(/^\\s*-?[0-9\\.\\,]+\\s?(?=(,|}))/)) { return 'number'; }\n        /* keywords */\n        if (stream.match(keywordRegex)) { return 'keyword'; }\n      }\n\n      /* pairs (associative arrays) -> key */\n      if (!state.pair && stream.match(/^\\s*(?:[,\\[\\]{}&*!|>'\"%@`][^\\s'\":]|[^\\s,\\[\\]{}#&*!|>'\"%@`])[^#:]*(?=:($|\\s))/)) {\n        state.pair = true;\n        state.keyCol = stream.indentation();\n        return \"atom\";\n      }\n      if (state.pair && stream.match(/^:\\s*/)) { state.pairStart = true; return 'meta'; }\n\n      /* nothing found, continue */\n      state.pairStart = false;\n      state.escaped = (ch == '\\\\');\n      stream.next();\n      return null;\n    },\n    startState: function() {\n      return {\n        pair: false,\n        pairStart: false,\n        keyCol: 0,\n        inlinePairs: 0,\n        inlineList: 0,\n        literal: false,\n        escaped: false\n      };\n    },\n    lineComment: \"#\",\n    fold: \"indent\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/x-yaml\", \"yaml\");\nCodeMirror.defineMIME(\"text/yaml\", \"yaml\");\n\n});\n","// Imports\nimport ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ from \"../../../css-loader/dist/runtime/noSourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.CodeMirror-hints{position:absolute;z-index:10;overflow:hidden;list-style:none;margin:0;padding:2px;box-shadow:2px 3px 5px rgba(0,0,0,.2);border-radius:3px;border:1px solid silver;background:#fff;font-size:90%;font-family:monospace;max-height:20em;overflow-y:auto;box-sizing:border-box}.CodeMirror-hint{margin:0;padding:0 4px;border-radius:2px;white-space:pre;color:#000;cursor:pointer}li.CodeMirror-hint-active{background:#08f;color:#fff}`, \"\"]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ from \"../../../css-loader/dist/runtime/noSourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../css-loader/dist/runtime/api.js\";\nimport ___CSS_LOADER_GET_URL_IMPORT___ from \"../../../css-loader/dist/runtime/getUrl.js\";\nvar ___CSS_LOADER_URL_IMPORT_0___ = new URL(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJFhQXEbhTg7YAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAMklEQVQI12NkgIIvJ3QXMjAwdDN+OaEbysDA4MPAwNDNwMCwiOHLCd1zX07o6kBVGQEAKBANtobskNMAAAAASUVORK5CYII=\", import.meta.url);\nvar ___CSS_LOADER_URL_IMPORT_1___ = new URL(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJDw4cOCW1/KIAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAHElEQVQI12NggIL/DAz/GdA5/xkY/qPKMDAwAADLZwf5rvm+LQAAAABJRU5ErkJggg==\", import.meta.url);\nvar ___CSS_LOADER_URL_IMPORT_2___ = new URL(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAANlBMVEX/uwDvrwD/uwD/uwD/uwD/uwD/uwD/uwD/uwD6twD/uwAAAADurwD2tQD7uAD+ugAAAAD/uwDhmeTRAAAADHRSTlMJ8mN1EYcbmiixgACm7WbuAAAAVklEQVR42n3PUQqAIBBFUU1LLc3u/jdbOJoW1P08DA9Gba8+YWJ6gNJoNYIBzAA2chBth5kLmG9YUoG0NHAUwFXwO9LuBQL1giCQb8gC9Oro2vp5rncCIY8L8uEx5ZkAAAAASUVORK5CYII=\", import.meta.url);\nvar ___CSS_LOADER_URL_IMPORT_3___ = new URL(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAHlBMVEW7AAC7AACxAAC7AAC7AAAAAAC4AAC5AAD///+7AAAUdclpAAAABnRSTlMXnORSiwCK0ZKSAAAATUlEQVR42mWPOQ7AQAgDuQLx/z8csYRmPRIFIwRGnosRrpamvkKi0FTIiMASR3hhKW+hAN6/tIWhu9PDWiTGNEkTtIOucA5Oyr9ckPgAWm0GPBog6v4AAAAASUVORK5CYII=\", import.meta.url);\nvar ___CSS_LOADER_URL_IMPORT_4___ = new URL(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAMAAADzjKfhAAAACVBMVEUAAAAAAAC/v7914kyHAAAAAXRSTlMAQObYZgAAACNJREFUeNo1ioEJAAAIwmz/H90iFFSGJgFMe3gaLZ0od+9/AQZ0ADosbYraAAAAAElFTkSuQmCC\", import.meta.url);\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);\nvar ___CSS_LOADER_URL_REPLACEMENT_0___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_0___);\nvar ___CSS_LOADER_URL_REPLACEMENT_1___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_1___);\nvar ___CSS_LOADER_URL_REPLACEMENT_2___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_2___);\nvar ___CSS_LOADER_URL_REPLACEMENT_3___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_3___);\nvar ___CSS_LOADER_URL_REPLACEMENT_4___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_4___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.CodeMirror-lint-markers{width:16px}.CodeMirror-lint-tooltip{background-color:#ffd;border:1px solid #000;border-radius:4px 4px 4px 4px;color:#000;font-family:monospace;font-size:10pt;overflow:hidden;padding:2px 5px;position:fixed;white-space:pre;white-space:pre-wrap;z-index:100;max-width:600px;opacity:0;transition:opacity .4s;-moz-transition:opacity .4s;-webkit-transition:opacity .4s;-o-transition:opacity .4s;-ms-transition:opacity .4s}.CodeMirror-lint-mark{background-position:0 100%;background-repeat:repeat-x}.CodeMirror-lint-mark-warning{background-image:url(${___CSS_LOADER_URL_REPLACEMENT_0___})}.CodeMirror-lint-mark-error{background-image:url(${___CSS_LOADER_URL_REPLACEMENT_1___})}.CodeMirror-lint-marker{background-position:50%;background-repeat:no-repeat;cursor:pointer;display:inline-block;height:16px;width:16px;vertical-align:middle;position:relative}.CodeMirror-lint-message{padding-left:18px;background-position:0 0;background-repeat:no-repeat}.CodeMirror-lint-marker-warning,.CodeMirror-lint-message-warning{background-image:url(${___CSS_LOADER_URL_REPLACEMENT_2___})}.CodeMirror-lint-marker-error,.CodeMirror-lint-message-error{background-image:url(${___CSS_LOADER_URL_REPLACEMENT_3___})}.CodeMirror-lint-marker-multiple{background-image:url(${___CSS_LOADER_URL_REPLACEMENT_4___});background-repeat:no-repeat;background-position:100% 100%;width:100%;height:100%}.CodeMirror-lint-line-error{background-color:rgba(183,76,81,.08)}.CodeMirror-lint-line-warning{background-color:rgba(255,211,0,.1)}`, \"\"]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ from \"../../css-loader/dist/runtime/noSourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.cm-s-base16-dark.CodeMirror{background:#151515;color:#e0e0e0}.cm-s-base16-dark div.CodeMirror-selected{background:#303030}.cm-s-base16-dark .CodeMirror-line::selection,.cm-s-base16-dark .CodeMirror-line>span::selection,.cm-s-base16-dark .CodeMirror-line>span>span::selection{background:rgba(48,48,48,.99)}.cm-s-base16-dark .CodeMirror-line::-moz-selection,.cm-s-base16-dark .CodeMirror-line>span::-moz-selection,.cm-s-base16-dark .CodeMirror-line>span>span::-moz-selection{background:rgba(48,48,48,.99)}.cm-s-base16-dark .CodeMirror-gutters{background:#151515;border-right:0}.cm-s-base16-dark .CodeMirror-guttermarker{color:#ac4142}.cm-s-base16-dark .CodeMirror-guttermarker-subtle,.cm-s-base16-dark .CodeMirror-linenumber{color:#505050}.cm-s-base16-dark .CodeMirror-cursor{border-left:1px solid #b0b0b0}.cm-s-base16-dark .cm-animate-fat-cursor,.cm-s-base16-dark.cm-fat-cursor .CodeMirror-cursor{background-color:#8e8d8875!important}.cm-s-base16-dark span.cm-comment{color:#8f5536}.cm-s-base16-dark span.cm-atom,.cm-s-base16-dark span.cm-number{color:#aa759f}.cm-s-base16-dark span.cm-attribute,.cm-s-base16-dark span.cm-property{color:#90a959}.cm-s-base16-dark span.cm-keyword{color:#ac4142}.cm-s-base16-dark span.cm-string{color:#f4bf75}.cm-s-base16-dark span.cm-variable{color:#90a959}.cm-s-base16-dark span.cm-variable-2{color:#6a9fb5}.cm-s-base16-dark span.cm-def{color:#d28445}.cm-s-base16-dark span.cm-bracket{color:#e0e0e0}.cm-s-base16-dark span.cm-tag{color:#ac4142}.cm-s-base16-dark span.cm-link{color:#aa759f}.cm-s-base16-dark span.cm-error{background:#ac4142;color:#b0b0b0}.cm-s-base16-dark .CodeMirror-activeline-background{background:#202020}.cm-s-base16-dark .CodeMirror-matchingbracket{text-decoration:underline;color:#fff!important}`, \"\"]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ from \"../../css-loader/dist/runtime/noSourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.cm-s-base16-light.CodeMirror{background:#f5f5f5;color:#202020}.cm-s-base16-light div.CodeMirror-selected{background:#e0e0e0}.cm-s-base16-light .CodeMirror-line::selection,.cm-s-base16-light .CodeMirror-line>span::selection,.cm-s-base16-light .CodeMirror-line>span>span::selection{background:#e0e0e0}.cm-s-base16-light .CodeMirror-line::-moz-selection,.cm-s-base16-light .CodeMirror-line>span::-moz-selection,.cm-s-base16-light .CodeMirror-line>span>span::-moz-selection{background:#e0e0e0}.cm-s-base16-light .CodeMirror-gutters{background:#f5f5f5;border-right:0}.cm-s-base16-light .CodeMirror-guttermarker{color:#ac4142}.cm-s-base16-light .CodeMirror-guttermarker-subtle,.cm-s-base16-light .CodeMirror-linenumber{color:#b0b0b0}.cm-s-base16-light .CodeMirror-cursor{border-left:1px solid #505050}.cm-s-base16-light span.cm-comment{color:#8f5536}.cm-s-base16-light span.cm-atom,.cm-s-base16-light span.cm-number{color:#aa759f}.cm-s-base16-light span.cm-attribute,.cm-s-base16-light span.cm-property{color:#90a959}.cm-s-base16-light span.cm-keyword{color:#ac4142}.cm-s-base16-light span.cm-string{color:#f4bf75}.cm-s-base16-light span.cm-variable{color:#90a959}.cm-s-base16-light span.cm-variable-2{color:#6a9fb5}.cm-s-base16-light span.cm-def{color:#d28445}.cm-s-base16-light span.cm-bracket{color:#202020}.cm-s-base16-light span.cm-tag{color:#ac4142}.cm-s-base16-light span.cm-link{color:#aa759f}.cm-s-base16-light span.cm-error{background:#ac4142;color:#505050}.cm-s-base16-light .CodeMirror-activeline-background{background:#dddcdc}.cm-s-base16-light .CodeMirror-matchingbracket{color:#f5f5f5!important;background-color:#6a9fb5!important}`, \"\"]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../css-loader/dist/cjs.js??clonedRuleSet-14.use[1]!../../../postcss-loader/dist/cjs.js??clonedRuleSet-14.use[2]!../../../postcss-loader/dist/cjs.js??clonedRuleSet-14.use[3]!./show-hint.css\");\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = require(\"!../../../vue-style-loader/lib/addStylesClient.js\").default\nvar update = add(\"0299c970\", content, true, {\"sourceMap\":false,\"shadowMode\":false});","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../css-loader/dist/cjs.js??clonedRuleSet-14.use[1]!../../../postcss-loader/dist/cjs.js??clonedRuleSet-14.use[2]!../../../postcss-loader/dist/cjs.js??clonedRuleSet-14.use[3]!./lint.css\");\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = require(\"!../../../vue-style-loader/lib/addStylesClient.js\").default\nvar update = add(\"55ede122\", content, true, {\"sourceMap\":false,\"shadowMode\":false});","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../css-loader/dist/cjs.js??clonedRuleSet-14.use[1]!../../postcss-loader/dist/cjs.js??clonedRuleSet-14.use[2]!../../postcss-loader/dist/cjs.js??clonedRuleSet-14.use[3]!./base16-dark.css\");\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = require(\"!../../vue-style-loader/lib/addStylesClient.js\").default\nvar update = add(\"10dd2426\", content, true, {\"sourceMap\":false,\"shadowMode\":false});","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../css-loader/dist/cjs.js??clonedRuleSet-14.use[1]!../../postcss-loader/dist/cjs.js??clonedRuleSet-14.use[2]!../../postcss-loader/dist/cjs.js??clonedRuleSet-14.use[3]!./base16-light.css\");\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = require(\"!../../vue-style-loader/lib/addStylesClient.js\").default\nvar update = add(\"21518f5a\", content, true, {\"sourceMap\":false,\"shadowMode\":false});"],"names":["isLineComment","cm","lineNo","test","getTokenTypeAt","commentIndent","text","getLine","substr","spaceTo","search","out","getOption","lineIndent","match","length","countSpaces","line","i","onCursorActivity","state","markedSelection","operation","update","onChange","clear","start","myIndent","lastLineInFold","end","lastLine","indent","from","to","regex","this","firstLine","e","foldCode","path","elements","index","trimmed","trim","endsWith","name","split","filter","push","currentPath","map","join","codeMirror","addOverlay","token","stream","string","pos","next","val","old","prev","markedSelectionStyle","reset","on","off","CHUNK_SIZE","Pos","cmp","coverRange","addAt","array","cls","endLine","atEnd","mark","markText","className","undefined","splice","ranges","listSelections","somethingSelected","getCursor","coverStart","find","coverEnd","shift","pop","mod","CodeMirror","dialogDiv","template","bottom","dialog","wrap","getWrapperElement","appendChild","document","createElement","innerHTML","addClass","closeNotification","newVal","currentNotificationClose","defineExtension","callback","options","closed","me","close","inp","value","rmClass","parentNode","removeChild","focus","onClose","button","getElementsByTagName","selectValueOnOpen","select","onInput","onKeyUp","onKeyDown","keyCode","closeOnEnter","blur","e_stop","closeOnBlur","evt","relatedTarget","callbacks","buttons","blurring","b","e_preventDefault","setTimeout","doneTimer","duration","clearTimeout","ie_lt8","navigator","userAgent","documentMode","matching","bracketRegex","config","findMatchingBracket","where","getLineHandle","ch","afterCursor","re","charAt","dir","strict","style","found","scanForBracket","forward","maxScanLen","maxScanLineLength","maxScanLines","stack","lineEnd","Math","min","max","matchBrackets","autoclear","maxHighlightLen","maxHighlightLineLength","highlightNonMatching","marks","empty","head","focused","doMatchBrackets","currentlyHighlighted","clearHighlighted","defineOption","Init","oldConfig","WORD","RANGE","registerHelper","editor","word","range","cur","curLine","curWord","slice","list","seen","RegExp","source","m","exec","lastIndexOf","Object","prototype","hasOwnProperty","call","HINT_ELEMENT_CLASS","ACTIVE_HINT_ELEMENT_CLASS","Completion","widget","debounce","tick","startPos","startLen","getSelection","updateOnCursorActivity","self","activityFunc","cursorActivity","showHint","getHints","async","newOpts","hint","prop","parseOptions","selections","supportsSelection","anchor","completionActive","completion","signal","requestAnimationFrame","window","fn","cancelAnimationFrame","hintOptions","defaultOptions","resolve","getText","buildKeyMap","handle","baseMap","Up","moveFocus","Down","PageUp","menuSize","PageDown","Home","setFocus","End","Enter","pick","Tab","Esc","mac","platform","custom","customKeys","ourMap","addBinding","key","bound","extra","extraKeys","getHintElement","hintsElement","el","nodeName","toUpperCase","Widget","data","id","floor","random","picked","ownerDocument","getInputField","parentWindow","defaultView","hints","setAttribute","theme","selectedHint","completions","elt","render","createTextNode","displayText","hintId","container","body","cursorCoords","alignWithWord","left","top","below","offsetLeft","offsetTop","isContainerPositioned","indexOf","getComputedStyle","position","offsetParent","offsetParentPosition","getBoundingClientRect","bodyPosition","scrollLeft","scrollTop","winW","innerWidth","offsetWidth","documentElement","winH","innerHeight","offsetHeight","startScroll","box","moveOnOverlap","DOMRect","scrolls","paddingForScrollbar","scrollHeight","clientHeight","getScrollInfo","overlapY","height","spaceAbove","closingOnBlur","overlapX","right","display","nativeBarWidth","width","node","firstChild","nextSibling","paddingRight","addKeyMap","keyMap","n","avoidWrap","changeActive","screenAmount","closeOnUnfocus","onBlur","onFocus","onScroll","curScroll","newTop","point","pageYOffset","t","target","srcElement","completeOnSingleClick","selectedHintRange","getSelectedHintRange","scrollToActive","childNodes","applicableHelpers","helpers","result","fetchHints","then","resolveAutoHints","words","getHelpers","resolved","app","run","getHelper","fromList","anyword","active","replaceRange","scrollIntoView","closeOnPick","identStart","closeCharacters","disable","first","myTick","finishUpdate","completeSingle","removeKeyMap","input","removeAttribute","replace","node1","node2","firstNode","margin","scrollMargin","term","getTokenAt","commands","autocomplete","auto","GUTTER_ID","LINT_LINE_ID","showTooltip","content","tt","clientY","clientX","cloneNode","lint","selfContain","opacity","rm","hideTooltip","showTooltipFor","tooltip","hide","poll","setInterval","nodeType","host","clearInterval","LintState","conf","hasGutter","marked","Function","getAnnotations","linterOptions","defaults","timeout","onMouseOver","waitingFor","highlightLines","tooltips","delay","lintOnChange","formatAnnotation","onUpdateLinting","clearMarks","clearGutter","clearErrorLines","eachLine","has","wrapClass","removeLineClass","makeMarker","labels","severity","multiple","marker","inner","getMaxSeverity","a","groupByLine","annotations","lines","ann","annotationTooltip","tip","messageHTML","message","lintAsync","abort","getValue","arg2","updateLinting","startLinting","issues","annotationsNotSorted","anns","maxSeverity","tipLabel","createDocumentFragment","__annotation","setGutterMarker","addLineClass","popupTooltips","x","y","spans","findMarksAt","coordsChar","gutters","hasLintGutter","jsyaml","console","error","loadAll","loc","column","doFold","noFold","regexpFlags","regexp","flags","ignoreCase","global","multiline","ensureFlags","current","maybeMultiline","searchRegexpForward","doc","last","lastIndex","searchRegexpForwardMultiline","chunk","before","inside","startLine","startCh","lastMatchIn","endMargin","newMatch","searchRegexpBackward","searchRegexpBackwardMultiline","chunkSize","adjustPos","orig","folded","foldFunc","mid","len","searchStringForward","query","caseFold","fold","cutFrom","endString","searchStringBackward","topString","SearchCursor","atOccurrence","afterEmptyMatch","clipPos","matches","reverse","String","normalize","str","toLowerCase","findNext","findPrevious","cmpPos","newText","origin","splitLines","defineDocExtension","getSearchCursor","setSelections","cmds","posEq","killRing","addToRing","growRingTop","getFromRing","popFromRing","lastKill","_kill","ring","getRange","isClean","gen","changeGeneration","byChar","findPosH","byWord","byLine","findPosV","sel","goalColumn","byPage","byParagraph","no","sawText","fst","lst","hasText","bySentence","sawWord","byExpr","after","newPos","getPrefix","precise","digits","emacsPrefix","clearPrefix","Number","repeated","cmd","f","execCommand","prefix","findEnd","by","move","extendSelection","motion","killTo","cursor","_killRegion","selection","addPrefix","digit","maybeClearPrefix","maybeDuplicateInput","prefixPreservingKeys","arg","emacsPrefixMap","event","dup","one","txt","replaceSelection","maybeRemovePrefixMap","prefixMap","clearMark","setExtending","setCursor","makePrompt","msg","fragment","getInput","openDialog","prompt","operateOnWord","op","toEnclosingExpr","setMark","getExtending","killRegion","killLineEmacs","killRingSave","yank","setSelection","yankPop","forwardChar","backwardChar","deleteChar","deleteForwardChar","deleteBackwardChar","forwardWord","backwardWord","killWord","backwardKillWord","nextLine","previousLine","scrollDownCommand","scrollUpCommand","backwardParagraph","forwardParagraph","backwardSentence","forwardSentence","killSentence","backwardKillSentence","killSexp","backwardKillSexp","forwardSexp","backwardSexp","markSexp","transposeSexps","leftStart","leftEnd","rightEnd","rightStart","backwardUpList","justOneSpace","openLine","transposeCharsRepeatable","capitalizeWord","w","letter","upcaseWord","downcaseWord","undoRepeatable","keyboardQuit","newline","gotoLine","num","isNaN","indentRigidly","indentSelection","exchangePointAndMark","quotedInsertTab","universalArgument","emacs","kill","normalizeKeyMap","regPrefix","d","findPosSubword","type","cat","isWordChar","moveSubword","extendSelectionsBy","extend","insertLine","above","isReadOnly","Pass","newSelection","at","indentLine","wordAt","addCursorToSelection","newRanges","newAnchor","newHead","newRange","isSelectedRange","goSubwordLeft","goSubwordRight","scrollLineUp","info","visibleBottomLine","lineAtHeight","scrollTo","defaultTextHeight","scrollLineDown","visibleTopLine","splitSelectionByLine","lineRanges","singleSelectionTop","scroll","selectLine","extended","insertLineAfter","insertLineBefore","selectNextOccurrence","fullWord","sublimeFindFullWord","addSelection","skipAndSelectNextOccurrence","prevAnchor","prevHead","addCursorToPrevLine","addCursorToNextLine","mirror","selectBetweenBrackets","opening","closing","puncType","sortLines","caseSensitive","direction","selected","toSort","sort","au","bu","modifyWordOrSelection","indices","replacements","replaceSelections","getTarget","findAndGoTo","selectScope","goToBracket","swapLineUp","linesToMove","newSels","swapLineDown","toggleCommentIndented","toggleComment","joinLines","joined","offset","obj","actual","duplicateLine","rangeCount","reverseSortLines","sortLinesInsensitive","reverseSortLinesInsensitive","nextBookmark","sublimeBookmarks","prevBookmark","unshift","toggleBookmark","findMarks","j","sublimeBookmark","k","clearWhenEmpty","clearBookmarks","selectBookmarks","smartBackspace","cursors","indentUnit","toStartOfLine","countColumn","deletePos","prevIndent","findColumn","delLineRight","upcaseAtCursor","downcaseAtCursor","setSublimeMark","sublimeMark","setBookmark","selectToSublimeMark","deleteToSublimeMark","tmp","sublimeKilled","swapWithSublimeMark","sublimeYank","showInCenter","findUnder","findUnderPrevious","findAllUnder","primaryIndex","macSublime","pcSublime","default","macDefault","sublime","initVim$1","transformCursor","vim","insertMode","visualBlock","defaultKeymap","keys","toKeys","context","action","motionArgs","linewise","toJumplist","wordEnd","bigWord","inclusive","explicitRepeat","toFirstChar","repeatOffset","isEdit","actionArgs","matchIndent","sameLine","operator","operatorArgs","indentRight","toLower","operatorMotionArgs","visualLine","shouldMoveCursor","insertAt","interlaceInsertRepeat","blockwise","keepSpaces","fullLine","exitVisualBlock","increase","backtrack","textObjectInner","searchArgs","querySrc","wholeWordOnly","defaultKeymapLength","defaultExCommandMap","shortName","possiblyAsync","excludeFromCommandHistory","enterVimMode","setOption","mode","maybeInitVimState","getOnPasteFn","leaveVimMode","highlightTimeout","detachVimMap","$customCursor","attach","attachVimMap","curOp","selectionChanged","cmKey","vimKey","cmKeyToVimKey","vimApi","findKey","modifiers","Shift","Ctrl","Alt","Cmd","Mod","CapsLock","specialKeys","Backspace","Delete","Insert","pieces","lastPiece","hasCharacter","piece","isUpperCase","onPasteFn","offsetCursor","actions","enterInsertMode","numberRegex","wordCharTest","bigWordCharTest","makeKeyRange","size","fromCharCode","upperCaseChars","upperCaseAlphabet","lowerCaseAlphabet","numbers","validMarks","concat","validRegisters","_","isLine","isLowerCase","isMatchableSymbol","isNumber","isWhiteSpaceString","isEndOfSentenceSymbol","inArray","arr","defaultValue","aliases","Error","cfg","option","scope","local","vimGlobalState","lastInsertModeKeyTimer","createCircularJumpList","pointer","tail","buffer","Array","add","oldCur","newCur","curMark","useNextSlot","trashMark","markPos","cursorEqual","inc","oldPointer","cachedCursor","createInsertModeChanges","c","changes","expectCursorActivityForChange","MacroModeState","latestRegister","isPlaying","isRecording","replaySearchQueries","onRecordingDone","lastInsertModeChanges","inputState","InputState","lastEditInputState","lastEditActionCommand","lastHPos","lastHSPos","lastMotion","insertModeRepeat","visualMode","lastSelection","lastPastedText","resetVimGlobalState","optionName","searchQuery","searchIsReversed","lastSubstituteReplacePart","jumpList","macroModeState","lastCharacterSearch","increment","selectedCharacter","registerController","RegisterController","searchHistoryController","HistoryController","exCommandHistoryController","exitMacroRecordMode","enterMacroRecordMode","registerName","register","getRegister","dom","class","getRegisterController","resetVimGlobalState_","getVimGlobalState_","maybeInitVimState_","suppressErrorLogging","InsertModeKey","lhs","rhs","ctx","exCommandDispatcher","unmap","noremap","toCtxArray","ctxsToMap","actualLength","origLength","mapping","newMapping","_mapCommand","mappedCtxs","mapclear","userKeymap","contexts","defineEx","func","exCommands","commandMap_","handleKey","command","multiSelectHandleKey","handleMacroRecording","clearInputState","logKey","handleEsc","exitVisualMode","exitInsertMode","doKeyToKey","substring","handleKeyInsertMode","keyBuffer","keysAreChars","commandDispatcher","matchCommand","thisMatch","here","handleKeyNonInsertMode","keysMatcher","mainKey","operatorShortcut","pushRepeatDigit","isVimOp","processCommand","handleEx","defineMotion","defineAction","defineOperator","mapCommand","defineRegister","prefixRepeat","motionRepeat","reason","Register","insertModeChanges","searchQueries","registers","unnamedRegister","historyBuffer","iterator","initialPrefix","getRepeat","repeat","parseInt","setText","pushText","pushInsertModeChanges","pushSearchQuery","toString","isValidRegister","append","shiftNumericRegisters_","nextMatch","up","element","pushInput","bestMatch","commandMatches","full","partial","character","lastChar","repeatOverride","processMotion","processOperator","processOperatorMotion","processAction","processSearch","processEx","copyArgs","evalInput","updateCmSelection","repeatIsExplicit","recordLastEdit","getSearchState","setReversed","promptPrefix","originalQuery","getQuery","originalScrollPos","handleQuery","showPrompt","onPromptClose","desc","onPromptKeyUp","onPromptKeyDown","expandWordUnderCursor","isKeyword","escapeRegex","smartCase","updateSearchQuery","showConfirm","logSearchQuery","parsedQuery","keyName","selectionEnd","selectionStart","clearSearchHighlight","exArgs","origHead","copyCursor","clipCursorToContent","origAnchor","oldHead","oldAnchor","noRepeat","motionResult","motions","recordJumpPosition","Infinity","updateMark","cursorIsBefore","lastSel","lineOffset","abs","chOffset","curStart","curEnd","cmSel","cursorMin","cursorMax","makeCmSelection","lineLength","expandSelectionToLine","clipToLine","exclusive","primary","operatorMoveTo","operators","actionCommand","moveToTopLine","_head","getUserVisibleLines","findFirstNonWhiteSpaceCharacter","moveToMiddleLine","moveToBottomLine","expandToLine","_cm","isReversed","highlightSearchMatches","findAndSelectNextInclusive","prevInputState","findNextFromAndToInclusive","subMode","goToMark","getMarkPos","moveToOtherHighlightedEnd","jumpToMark","best","isWrongDirection","equal","between","cursorIsBetween","moveByCharacters","moveByLines","endCh","moveByDisplayLines","moveByScroll","moveToColumn","moveToEol","posV","hasMarkedText","moveToStartOfLine","charCoords","res","hitSide","lastCharCoords","goalCoords","resCoords","moveByPage","moveByParagraph","findParagraph","moveBySentence","findSentence","scrollbox","dest","moveByWords","moveToWord","moveTillCharacter","moveToCharacter","recordLastCharacterSearch","moveToSymbol","findSymbol","moveToFirstNonWhiteSpaceCharacter","moveToMatchedSymbol","symbol","lineText","matched","moveToLineOrEdgeOfDocument","lineNum","moveToStartOfDisplayLine","moveToEndOfDisplayLine","sticky","textObjectManipulation","mirroredPairs","selfPaired","selectCompanionObject","findBeginningAndEnd","expandTagUnderCursor","getSentence","expandSelection","repeatLastCharacterSearch","lastSearch","moveH","fillArray","times","change","args","finalHead","MAX_VALUE","replacement","lastState","prevLineEnd","wasLastLine","newlineAndIndent","indentMore","indentLess","indentAuto","_args","changeCase","getSelections","swapped","toSwap","endPos","jumpListWalk","lineHeight","delta","ceil","newBottom","scrollToCursor","lineLastCharPos","lineLastCharCoords","replayMacro","executeMacroRegister","toggleOverwrite","overwrite","getLastEditPos","onKeyEventTargetKeyDown","selectForInsert","toggleVisualMode","reselectLastSelection","_actionArgs","updateLastSelection","anchorMark","headMark","finalCh","curFinalPos","newLineAndEnterInsertMode","newlineFn","newlineAndIndentContinueComment","paste","tabSize","whitespaceLength","tabs","spaces","currentLine","chompedText","wasChomped","firstIndent","wspace","newIndent","quotient","curPosFinal","idx","lastSelectionCurEnd","selectedArea","getSelectedAreaRange","selectedText","emptyStrings","selectBlock","posFromIndex","indexFromPos","lastCh","extendLineToColumn","undo","repeatFn","redo","setRegister","markName","replaceTo","replaceWith","replaceWithStr","incrementNumberToken","numberStr","lineStr","baseStr","base","number","zeroPadding","repeatLastEdit","includeLineBreak","maxCh","ret","offsetLine","offsetCh","commandMatch","pressed","mapped","prefixLen","pressedPrefix","mappedPrefix","cur1","cur2","arguments","apply","cur3","cur1before2","cur2before3","s","isClipped","curHead","primIndex","getIndex","wasClipped","baseCh","headCh","newDir","lineHead","atAnchor","atHead","getCurrentSelectedAreaRange","getLastSelectedAreaRange","block","headOffset","anchorOffset","fromCh","toCh","getHead","moveHead","firstNonWS","_forward","noSymbol","wordStart","findMatchingTag","findEnclosingTag","tags","open","symbolToMode","findSymbolModes","bracket","isComplete","nextCh","symb","depth","reverseSymb","section","init","curMoveThrough","comment","method","preprocess","lineCount","curCh","lineLen","findWord","emptyLineIsWord","charTests","stop","foundWord","eodCh","shortCircuit","firstWord","lastWord","keepHPos","retval","charIdxInLine","includeChar","isEmpty","isBoundary","any","startState","nextChar","curr","ln","lastSentencePos","curr_index","last_valid","skip_empty_lines","bracketRegexp","openSym","curChar","chars","firstIndex","SearchState","searchState_","splitBySlash","argString","splitBySeparator","findUnescapedSlashes","findUnescapedSeparators","separator","slashes","tokens","escapeNextChar","translateRegex","specials","unescape","specialComesNext","setQuery","getOverlay","searchOverlay","setOverlay","overlay","reversed","getScrollbarAnnotate","annotate","setScrollbarAnnotate","charUnescapes","translateRegexReplace","unescapes","unescapeRegexReplace","StringStream","output","eol","peek","matcher","parseQuery","lastSearchRegister","regexPart","forceIgnoreCase","flagsPart","pre","$color","$whiteSpace","openNotification","alert","innerText","$fontFamily","autocorrect","autocapitalize","spellcheck","shortText","textContent","regexEqual","r1","r2","props","rawQuery","matchSol","sol","backUp","skipToEnd","searchState","removeOverlay","showMatchesOnScrollbar","lastEndPos","isInRange","scrollInfo","occludeToleranceTop","occludeToleranceBottom","bottomY","done","history","ExCommandDispatcher","buildCommandMap_","opt_params","that","_processCommand","commandHistoryRegister","previousCommand","inputStream","commandName","params","parseInput_","matchCommand_","parseCommandArgs_","toInput","eatWhile","eat","parseLineSpec_","numberMatch","parseLineSpecOffset_","offsetMatch","delim","argDelimiter","user","colorscheme","mapArgs","imap","nmap","vmap","set","setArgs","setCfg","expr","forceGet","optionIsBoolean","oldValue","setOptionReturn","setlocal","setglobal","regArgs","regInfo","unique","pattern","parseArgs","eatSpace","opts","decimal","hex","octal","err","lineStart","radix","numPart","textPart","matchPart","comparePatternFn","compareFn","textOld","anum","bnum","vglobal","inverted","matchedLines","nextCommand","getLineNumber","substitute","trailing","count","replacePart","confirm","doReplace","write","save","nohlsearch","delmarks","sym","startMark","finishMark","charCodeAt","finish","searchCursor","exMode","lastPos","modifiedLineNumber","replaceAll","unmodifiedLineNumber","findNextValidMatch","lastMatchTo","_value","savedCallback","insertModeChangeRegister","lastChange","logInsertModeChange","imc","repeatInsertModeChanges","changeObj","ignoreCount","selectionCount","maybeReset","handleExternalSelection","onKeyFound","lookupKey","repeatForInsert","isAction","cachedInputState","repeatCommand","repeatInsert","changeObject","keyHandler","binding","cloneVimState","constructor","forEach","o","isArray","isHandled","wasInVisualBlock","wasMultiselect","isInMultiSelectMode","status","inVirtualSelectionMode","forEachSelection","virtualSelection","insert","detach","fallthrough","initVim","CodeMirror5","Vim","defineMode","parserConfig","statementIndent","jsonldMode","jsonld","jsonMode","json","trackScope","isTS","typescript","wordRE","wordCharacters","keywords","kw","A","B","C","D","atom","isOperatorChar","isJsonldKeyword","readRegexp","escaped","inSet","tp","cont","tokenBase","tokenize","tokenString","tokenComment","expressionAllowed","tokenQuasi","lexical","lastType","propertyIsEnumerable","quote","maybeEnd","brackets","findFatArrow","fatArrowAt","arrow","sawSomething","atomicTypes","JSLexical","indented","align","inScope","varname","v","localVars","cx","vars","parseJS","cc","combinator","expression","statement","lex","pass","inList","newContext","registerVarScoped","Var","globalVars","Context","isModifier","defaultVars","pushcontext","pushblockcontext","popcontext","pushlex","outer","poplex","expect","wanted","exp","vardef","parenExpr","maybeexpression","maybeelse","functiondef","forspec","enumdef","typename","typeexpr","maybelabel","maybeCatchBinding","afterExport","afterImport","funarg","expressionInner","expressionNoComma","noComma","arrowBodyNoComma","arrowBody","commasep","maybeop","maybeoperatorNoComma","maybeoperatorComma","classExpression","arrayLiteral","contCommasep","objprop","quasi","maybeTarget","property","continueQuasi","targetNoComma","maybeTypeArgs","getterSetter","afterprop","maybetype","what","sep","proceed","maybetypeOrIn","mayberettype","isKW","afterType","typeprops","typearg","maybeReturnType","quasiType","typeprop","functiondecl","continueQuasiType","typeparam","maybeTypeDefault","maybeAssign","vardefCont","eltpattern","proppattern","_type","forspec1","forspec2","classNameAfter","classBody","classfield","isInterface","maybeFrom","exportField","importSpec","maybeMoreImports","maybeAs","enummember","isContinuedStatement","textAfter","basecolumn","indentation","firstChar","doubleIndentSwitch","electricInput","blockCommentStart","blockCommentEnd","blockCommentContinue","lineComment","closeBrackets","helperType","skipExpression","defineMIME","cons","keywordRegex","esc","literal","keyCol","pair","pairStart","inlinePairs","inlineList","___CSS_LOADER_EXPORT___","module","___CSS_LOADER_URL_IMPORT_0___","URL","___CSS_LOADER_URL_IMPORT_1___","___CSS_LOADER_URL_IMPORT_2___","___CSS_LOADER_URL_IMPORT_3___","___CSS_LOADER_URL_IMPORT_4___","___CSS_LOADER_URL_REPLACEMENT_0___","___CSS_LOADER_URL_REPLACEMENT_1___","___CSS_LOADER_URL_REPLACEMENT_2___","___CSS_LOADER_URL_REPLACEMENT_3___","___CSS_LOADER_URL_REPLACEMENT_4___","__esModule","locals","exports"],"sourceRoot":""}